{'date': '2024-05-17 17:53:20', 'nodes': [{'title': '留言板', 'number': 9, 'url': 'https://github.com/jygzyc/notes/discussions/9', 'createdAt': '2024-04-21T13:08:27Z', 'lastEditedAt': '2024-04-22T16:15:27Z', 'updatedAt': '2024-05-15T06:39:49Z', 'body': '<!-- message -->\r\n搞一个留言板方便交流\r\n', 'bodyText': '搞一个留言板方便交流', 'author': {'login': 'jygzyc'}, 'category': {'name': '0002-留言'}, 'labels': {'nodes': [{'name': 'site_message'}]}, 'comments': {'nodes': [{'body': '这里是一条测试评论', 'author': {'login': 'jygzyc'}}]}}, {'title': '半小时学习Rust', 'number': 8, 'url': 'https://github.com/jygzyc/notes/discussions/8', 'createdAt': '2024-04-19T03:02:41Z', 'lastEditedAt': '2024-04-24T17:20:01Z', 'updatedAt': '2024-04-24T17:20:01Z', 'body': '# 半小时学习Rust\r\n\r\n> 个人笔记：为了理解rust，添加了一些tip\r\n\r\n为了提高编程语言的流畅性，人们必须阅读大量编程语言的相关知识。但如果你不知道它的含义，你怎么能读这么多呢？\r\n在本文中，我不会专注于一两个概念，而是尝试尽可能多地浏览 Rust 片段，并解释它们包含的关键字和符号的含义。\r\n准备好了吗？冲！[^1] [^2] （根据情况更新笔记）\r\n\r\n`let`引入了一个变量绑定：\r\n\r\n```rust\r\nlet x; // 声明 "x"\r\nx = 42; // 将 42 分配给“x”\r\n```\r\n\r\n也可以写成一行：\r\n\r\n```rust\r\nlet x = 42;\r\n```\r\n\r\n您可以使用`:`显式地指定变量的类型，这是类型注解：\r\n\r\n```rust\r\nlet x: i32; // `i32` 是一个有符号的 32 位整数\r\nx = 42;\r\n// 有 i8、i16、i32、i64、i128 表示其他位数的有符号整数\r\n// 还有 u8、u16、u32、u64、u128 表示无符号整数\r\n```\r\n\r\n这也可以写成一行：\r\n\r\n```rust\r\nlet x: i32 = 42;\r\n```\r\n\r\n如果您声明一个变量并稍后对其进行初始化，在初始化之前编译器将阻止您使用它。\r\n\r\n```rust\r\nlet x;\r\nfoobar(x); // error: borrow of possibly-uninitialized variable: `x`\r\nx = 42;\r\n```\r\n\r\n下面这样做是完全没问题的：\r\n\r\n```rust\r\nlet x;\r\nx = 42;\r\nfoobar(x); // `x` 的类型可以推断出来\r\n```\r\n\r\n下划线`_`是一个特殊名称——或者更确切地说，是“缺乏名称”。`_`基本上意味着扔掉一些东西：\r\n\r\n```rust\r\n// *什么也没做*，因为 42 是一个常数\r\nlet _ = 42;\r\n\r\n// 这调用了 `get_thing` 但丢弃了它的结果\r\nlet _ = get_thing();\r\n```\r\n\r\n以下划线“开头”的名称是常规名称，有一点特殊的是，编译器不会警告它们未被使用\r\n\r\n```rust\r\n// 我们最终可能会使用 `_x`，但我们的代码仍在编写中\r\n// 我们现在只想摆脱编译器的警告。\r\nlet _x = 42；\r\n```\r\n\r\n可以引入具有相同名称的单独绑定，它会“隐藏”前一个变量绑定：\r\n\r\n```rust\r\nlet x = 13;\r\nlet x = x + 3;\r\n// 该行之后使用“x”仅引用第二个“x”，\r\n// 第一个“x”不再存在。\r\n```\r\n\r\nRust 有`tuple`——元组类型，您可以将其视为“固定长度的不同类型的集合”。\r\n\r\n```rust\r\nlet pair = (\'a\', 17);\r\npair.0; // this is \'a\'\r\npair.1; // this is 17\r\n```\r\n\r\n如果我们真的想给元组中变量增加类型注解，可以用`pair`：\r\n\r\n```rust\r\nlet pair: (char, i32) = (\'a\', 17);\r\n```\r\n\r\n元组可以通过赋值的方式被“解构”(destructured)，这意味着它们被分解为各自的字段：\r\n\r\n```rust\r\nlet (some_char, some_int) = (\'a\', 17);\r\n// 现在，`some_char` 是 \'a\'，`some_int` 是 17\r\n```\r\n\r\n当函数返回元组类型时特别管用：\r\n\r\n```rust\r\nlet (left, right) = slice.split_at(middle);\r\n```\r\n\r\n当然，在解构一个元组时，可以用 `_` 舍弃掉一部分字段：\r\n\r\n```rust\r\nlet (_, right) = slice.split_at(middle);\r\n```\r\n\r\n分号表示语句的结尾：\r\n\r\n```rust\r\nlet x = 3;\r\nlet y = 5;\r\nlet z = y + x;\r\n```\r\n\r\n这意味着语句可以写成多行：\r\n\r\n```rust\r\nlet x = vec![1, 2, 3, 4, 5, 6, 7, 8]\r\n    .iter()\r\n    .map(|x| x + 3)\r\n    .fold(0, |x, y| x + y);\r\n```\r\n\r\n（我们稍后会讨论这些代码的实际含义）。\r\n\r\n`fn`用来声明一个函数。\r\n\r\n下面是一个 void 函数：\r\n\r\n```rust\r\nfn greet() {\r\n    println!("Hi there!");\r\n}\r\n```\r\n\r\n下面是一个返回 32 位有符号整数的函数。使用箭头指示其返回类型：\r\n\r\n```rust\r\nfn fair_dice_roll() -> i32 {\r\n    4\r\n}\r\n```\r\n\r\n一对大括号声明一个块，它有自己的作用域：\r\n\r\n```rust\r\n// 这首先会打印“in”，然后是“out”\r\nfn main() {\r\n    let x = "out";\r\n    {\r\n        // 这是一个不同的“x”\r\n        let x = "in";\r\n        println!("{}", x);\r\n    }\r\n    println!("{}", x);\r\n}\r\n```\r\n\r\n“块”也是表达式，意味着它们的计算结果为一个值。\r\n\r\n```rust\r\n// 这条语句\r\nlet x = 42;\r\n\r\n// 和这条语句等价\r\nlet x = { 42 };\r\n```\r\n\r\n在一个块中，可以有多条语句：\r\n\r\n```rust\r\nlet x = {\r\n    let y = 1; // 第一个声明\r\n    let z = 2; // 第二个声明\r\n    y + z // 这是 *结尾*，即整个块的计算结果\r\n};\r\n```\r\n\r\n这就是为什么“省略函数末尾的分号”与“返回这个值”相同，即，下面的两个函数是等效的：\r\n\r\n```rust\r\nfn fair_dice_roll() -> i32 {\r\n    return 4;\r\n}\r\n\r\nfn fair_dice_roll() -> i32 {\r\n    4\r\n}\r\n```\r\n\r\n`if` 条件也可以是表达式：\r\n\r\n```rust\r\nfn fair_dice_roll() -> i32 {\r\n    if feeling_lucky {\r\n        6\r\n    } else {\r\n        4\r\n    }\r\n}\r\n```\r\n\r\n`match` 也是一个表达式：\r\n\r\n```rust\r\nfn fair_dice_roll() -> i32 {\r\n    match feeling_lucky {\r\n        true => 6,\r\n        false => 4,\r\n    }\r\n}\r\n```\r\n\r\n“点”`.`通常用于访问值的字段：\r\n\r\n```rust\r\nlet a = (10, 20);\r\na.0; // this is 10\r\n\r\nlet amos = get_some_struct();\r\namos.nickname; // this is "fasterthanlime"\r\n```\r\n\r\n或者调用方法：\r\n\r\n```rust\r\nlet nick = "fasterthanlime";\r\nnick.len(); // this is 14\r\n```\r\n\r\n“双冒号”`::`与此类似，但它的操作对象是命名空间。\r\n在此示例中，`std`是一个 crate（相当于一个库），`cmp`是一个模块（相当于一个源文件），`min`是一个函数：  \r\n\r\n```rust\r\nlet least = std::cmp::min(3, 8); // this is 3\r\n```\r\n\r\n`use`指令可用于将其他命名空间名称引入到当前：\r\n\r\n```rust\r\nuse std::cmp::min;\r\n\r\nlet least = min(7, 1); // this is 1\r\n```\r\n\r\n在`use`指令中，大括号还有另一个含义：它们是一组名称（`glob`）。如果我们想用`use`同时导入`min`和`max`，那么可以： \r\n\r\n```rust\r\n// this works:\r\nuse std::cmp::min;\r\nuse std::cmp::max;\r\n\r\n// this also works:\r\nuse std::cmp::{min, max};\r\n\r\n// this also works!\r\nuse std::{cmp::min, cmp::max};\r\n```\r\n\r\n通配符 `*` 允许您导入命名空间下所有名称：\r\n\r\n```rust\r\n// 这不仅将“min”和“max”引入代码中，而且并包括模块中的其他名称\r\nuse std::cmp::*;\r\n```\r\n\r\n类型也是命名空间，方法可以作为常规函数调用：\r\n\r\n```rust\r\nlet x = "amos".len(); // this is 4\r\nlet x = str::len("amos"); // this is also 4\r\n```\r\n\r\n`str`是基本类型(primitive type)，但默认命名空间下也有许多非基本类型。\r\n\r\n```rust\r\n// `Vec` 是一个常规结构，而不是原始类型\r\nlet v = Vec::new();\r\n\r\n// 这是和上述完全等价的代码，但具有访问到“Vec”的*完整*路径\r\nlet v = std::vec::Vec::new();\r\n```\r\n\r\n这是因为 Rust 会在每个模块的开头插入它：\r\n\r\n```rust\r\nuse std::prelude::v1::*;\r\n```\r\n\r\n（这反过来又会导入其他许多符号，如`Vec`、`String`、`Option`和`Result`）。\r\n\r\n结构体使用`struct`关键字声明：\r\n\r\n```rust\r\nstruct Vec2 {\r\n    x: f64, // 64 位浮点，又名“双精度”\r\n    y: f64,\r\n}\r\n```\r\n\r\n它们可以使用“结构体文字”进行初始化：\r\n\r\n```rust\r\nlet v1 = Vec2 { x: 1.0, y: 3.0 };\r\nlet v2 = Vec2 { y: 2.0, x: 4.0 };\r\n// the order does not matter, only the names do\r\n```\r\n\r\n有一个快捷方式可以从另一个结构体初始化剩余字段：\r\n\r\n```rust\r\nlet v3 = Vec2 {\r\n    x: 14.0,\r\n    ..v2\r\n};\r\n```\r\n\r\n这被称为“结构更新语法”（struct update syntax），只能发生在最后一个位置，并且不能后跟逗号。\r\n请注意，“剩余字段”可以是“所有字段”：\r\n\r\n```rust\r\nlet v4 = Vec2 { ..v3 };\r\n```\r\n\r\n结构体和元组一样，可以被解构。\r\n下面是一个有效的`let`模式：\r\n\r\n```rust\r\nlet (left, right) = slice.split_at(middle);\r\n```\r\n\r\n也可以这样：\r\n\r\n```rust\r\nlet v = Vec2 { x: 3.0, y: 6.0 };\r\nlet Vec2 { x, y } = v;\r\n// `x` is now 3.0, `y` is now `6.0`\r\n```\r\n\r\n还有这个：\r\n\r\n```rust\r\nlet Vec2 { x, .. } = v;\r\n// this throws away `v.y`\r\n```\r\n\r\n`let`模式可以用作`if`中的条件：\r\n\r\n```rust\r\nstruct Number {\r\n    odd: bool,\r\n    value: i32,\r\n}\r\n\r\nfn main() {\r\n    let one = Number { odd: true, value: 1 };\r\n    let two = Number { odd: false, value: 2 };\r\n    print_number(one);\r\n    print_number(two);\r\n}\r\n\r\nfn print_number(n: Number) {\r\n    if let Number { odd: true, value } = n {\r\n        println!("Odd number: {}", value);\r\n    } else if let Number { odd: false, value } = n {\r\n        println!("Even number: {}", value);\r\n    }\r\n}\r\n\r\n// this prints:\r\n// Odd number: 1\r\n// Even number: 2\r\n```\r\n\r\n`match`匹配也是一种模式，就像`if let`:\r\n\r\n```rust\r\nfn print_number(n: Number) {\r\n    match n {\r\n        Number { odd: true, value } => println!("Odd number: {}", value),\r\n        Number { odd: false, value } => println!("Even number: {}", value),\r\n    }\r\n}\r\n\r\n// this prints the same as before\r\n```\r\n\r\n`match`必须是详尽的，至少需要一个分支来进行匹配\r\n\r\n```rust\r\nfn print_number(n: Number) {\r\n    match n {\r\n        Number { value: 1, .. } => println!("One"),\r\n        Number { value: 2, .. } => println!("Two"),\r\n        Number { value, .. } => println!("{}", value),\r\n        // if that last arm didn\'t exist, we would get a compile-time error\r\n    }\r\n}\r\n```\r\n\r\n如果这很麻烦，可以用`_`来匹配所有模式：\r\n\r\n```rust\r\nfn print_number(n: Number) {\r\n    match n.value {\r\n        1 => println!("One"),\r\n        2 => println!("Two"),\r\n        _ => println!("{}", n.value),\r\n    }\r\n}\r\n```\r\n\r\n您可以在自己的类型上声明方法：\r\n\r\n```rust\r\nstruct Number {\r\n    odd: bool,\r\n    value: i32,\r\n}\r\n\r\nimpl Number {\r\n    fn is_strictly_positive(self) -> bool {\r\n        self.value > 0\r\n    }\r\n}\r\n```\r\n\r\n并像往常一样使用它们：\r\n\r\n```rust\r\nfn main() {\r\n    let minus_two = Number {\r\n        odd: false,\r\n        value: -2,\r\n    };\r\n    println!("positive? {}", minus_two.is_strictly_positive());\r\n    // this prints "positive? false"\r\n}\r\n```\r\n\r\n默认情况下，变量绑定是不可变的，这意味着它的变量值不能改变：\r\n\r\n```rust\r\nfn main() {\r\n    let n = Number {\r\n        odd: true,\r\n        value: 17,\r\n    };\r\n    n.odd = false; // error: cannot assign to `n.odd`,\r\n                   // as `n` is not declared to be mutable\r\n}\r\n```\r\n\r\n而且它们不能被赋值更改：\r\n\r\n```rust\r\nfn main() {\r\n    let n = Number {\r\n        odd: true,\r\n        value: 17,\r\n    };\r\n    n = Number {\r\n        odd: false,\r\n        value: 22,\r\n    }; // error: cannot assign twice to immutable variable `n`\r\n}\r\n```\r\n\r\n`mut`允许变量绑定可更改：\r\n\r\n```rust\r\nfn main() {\r\n    let mut n = Number {\r\n        odd: true,\r\n        value: 17,\r\n    }\r\n    n.value = 19; // all good\r\n}\r\n```\r\n\r\n`trait`是多种类型拥有的共同点：\r\n\r\n```rust\r\ntrait Signed {\r\n    fn is_strictly_negative(self) -> bool;\r\n}\r\n```\r\n\r\n您可以实现：\r\n\r\n- 为任意类型实现你自己定义的trait\r\n- 为你的类型实现任意类型的trait\r\n- 不允许为别人的类型实现别人的trait\r\n\r\n这些被称为“孤立规则”(orphan rules)。\r\n\r\n下面是自定义trait在自定义类型上的实现：\r\n\r\n```rust\r\nimpl Signed for Number {\r\n    fn is_strictly_negative(self) -> bool {\r\n        self.value < 0\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let n = Number { odd: false, value: -44 };\r\n    println!("{}", n.is_strictly_negative()); // prints "true"\r\n}\r\n```\r\n\r\n我们在外部类型（甚至是基本类型）上的实现的自定义trait：\r\n\r\n```rust\r\nimpl Signed for i32 {\r\n    fn is_strictly_negative(self) -> bool {\r\n        self < 0\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let n: i32 = -44;\r\n    println!("{}", n.is_strictly_negative()); // prints "true"\r\n}\r\n```\r\n\r\n自定义类型的外部trait：\r\n\r\n```rust\r\n// `Neg` 特性用于重载 `-`，\r\n// 一元减运算符。\r\nimpl std::ops::Neg for Number {\r\n    type Output = Number;\r\n\r\n    fn neg(self) -> Number {\r\n        Number {\r\n            value: -self.value,\r\n            odd: self.odd,\r\n        }        \r\n    }\r\n}\r\n\r\nfn main() {\r\n    let n = Number { odd: true, value: 987 };\r\n    let m = -n; // this is only possible because we implemented `Neg`\r\n    println!("{}", m.value); // prints "-987"\r\n}\r\n```\r\n\r\n`impl`块总是用来为类型实现方法，因此，在该块内，`Self`可以指代该类型:\r\n\r\n```rust\r\nimpl std::ops::Neg for Number {\r\n    type Output = Self;\r\n\r\n    fn neg(self) -> Self {\r\n        Self {\r\n            value: -self.value,\r\n            odd: self.odd,\r\n        }        \r\n    }\r\n}\r\n```\r\n\r\n有些trait是“标记”——它们并不是说类型实现了某些方法，而是说可以用类型完成某些事情。\r\n例如`i32`实现`Copy` trait(简单地讲，`i32`是可复制的)，所以下面的代码工作正常:\r\n\r\n```rust\r\nfn main() {\r\n    let a: i32 = 15;\r\n    let b = a; // `a` is copied\r\n    let c = a; // `a` is copied again\r\n}\r\n```\r\n\r\n这也是正常的：\r\n\r\n```rust\r\nfn print_i32(x: i32) {\r\n    println!("x = {}", x);\r\n}\r\n\r\nfn main() {\r\n    let a: i32 = 15;\r\n    print_i32(a); // `a` is copied\r\n    print_i32(a); // `a` is copied again\r\n}\r\n```\r\n\r\n但`Number`类型没有实现`Copy`，所以下面的代码不起作用：\r\n\r\n```rust\r\nfn main() {\r\n    let n = Number { odd: true, value: 51 };\r\n    let m = n; // `n` is moved into `m`\r\n    let o = n; // error: use of moved value: `n`\r\n}\r\n```\r\n\r\n这也不行：\r\n\r\n```rust\r\nfn print_number(n: Number) {\r\n    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);\r\n}\r\n\r\nfn main() {\r\n    let n = Number { odd: true, value: 51 };\r\n    print_number(n); // `n` is moved\r\n    print_number(n); // error: use of moved value: `n`\r\n}\r\n```\r\n\r\n但如果采用不可变的引用`print_number`，就是可行的：\r\n\r\n```rust\r\nfn print_number(n: &Number) {\r\n    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);\r\n}\r\n\r\nfn main() {\r\n    let n = Number { odd: true, value: 51 };\r\n    print_number(&n); // `n` is borrowed for the time of the call\r\n    print_number(&n); // `n` is borrowed again\r\n}\r\n```\r\n\r\n如果变量被声明为可变的，则函数参数使用可变引用也可以工作:\r\n\r\n```rust\r\nfn invert(n: &mut Number) {\r\n    n.value = -n.value;\r\n}\r\nfn print_number(n: &Number) {\r\n    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);\r\n}\r\nfn main() {\r\n    // this time, `n` is mutable\r\n    let mut n = Number { odd: true, value: 51 };\r\n    print_number(&n);\r\n    invert(&mut n); // `n is borrowed mutably - everything is explicit\r\n    print_number(&n);\r\n}\r\n```\r\n\r\nTrait 方法中的`self`参数可以使用引用，也可以使用不可变引用\r\n\r\n```rust\r\nimpl std::clone::Clone for Number {\r\n    fn clone(&self) -> Self {\r\n        Self { ..*self }\r\n    }\r\n```\r\n\r\n当调用trait的方法时，receiver隐式地被借用\r\n\r\n```rust\r\nfn main() {\r\n    let n = Number { odd: true, value: 51 };\r\n    let mut m = n.clone();\r\n    m.value += 100;\r\n    \r\n    print_number(&n);\r\n    print_number(&m);\r\n}\r\n```\r\n\r\n强调一点，下面的代码是等价的:\r\n\r\n```rust\r\nlet m = n.clone();\r\n\r\nlet m = std::clone::Clone::clone(&n);\r\n```\r\n\r\n像 `Copy` 这样的 Marker traits 是没有实现原对象trait方法的\r\n\r\n```rust\r\n// note: `Copy` requires that `Clone` is implemented too\r\nimpl std::clone::Clone for Number {\r\n    fn clone(&self) -> Self {\r\n        Self { ..*self }\r\n    }\r\n}\r\n\r\nimpl std::marker::Copy for Number {}\r\n```\r\n\r\n现在`Clone`仍然可以使用:\r\n\r\n```rust\r\nfn main() {\r\n    let n = Number { odd: true, value: 51 };\r\n    let m = n.clone();\r\n    let o = n.clone();\r\n}\r\n```\r\n\r\n但是`Number`的值不会被转移了\r\n\r\n```rust\r\nfn main() {\r\n    let n = Number { odd: true, value: 51 };\r\n    let m = n; // `m` is a copy of `n`\r\n    let o = n; // same. `n` is neither moved nor borrowed.\r\n}\r\n```\r\n\r\n一些`trait`太通用了，我们可以通过derive属性自动实现它们:\r\n\r\n```rust\r\n#[derive(Clone, Copy)]\r\nstruct Number {\r\n    odd: bool,\r\n    value: i32,\r\n}\r\n\r\n// this expands to `impl Clone for Number` and `impl Copy for Number` blocks.\r\n```\r\n\r\n函数可以是泛型的:\r\n\r\n```rust\r\nfn foobar<T>(arg: T) {\r\n    // do something with `arg`\r\n}\r\n```\r\n\r\n它们可以有多个“类型参数”，类型参数用在函数声明和函数体中，用来替代具体的类型:\r\n\r\n```rust\r\nfn foobar<L, R>(left: L, right: R) {\r\n    // do something with `left` and `right`\r\n}\r\n```\r\n\r\n类型参数通常有“约束”，所以你可以用它做一些额外的事情。\r\n\r\n最简单的约束就是trait名称:\r\n\r\n```rust\r\nfn print<T: Display>(value: T) {\r\n    println!("value = {}", value);\r\n}\r\n\r\nfn print<T: Debug>(value: T) {\r\n    println!("value = {:?}", value);\r\n}\r\n```\r\n\r\n类型参数约束可以有更长的语法：\r\n\r\n```rust\r\nfn print<T>(value: T)\r\nwhere\r\n    T: Display,\r\n{\r\n    println!("value = {}", value);\r\n}\r\n```\r\n\r\n约束还可以变得更加复杂，比如要求类型参数要实现多种trait:\r\n\r\n```rust\r\nuse std::fmt::Debug;\r\n\r\nfn compare<T>(left: T, right: T)\r\nwhere\r\n    T: Debug + PartialEq,\r\n{\r\n    println!("{:?} {} {:?}", left, if left == right { "==" } else { "!=" }, right);\r\n}\r\n\r\nfn main() {\r\n    compare("tea", "coffee");\r\n    // prints: "tea" != "coffee"\r\n}\r\n```\r\n\r\n泛型函数可以被当作一个命名空间，包含无穷多个不同具体类型的函数。\r\n\r\n类似`crate`、`module`和`type`，泛型函数可以使用`::`导航:\r\n\r\n```rust\r\nfn main() {\r\n    use std::any::type_name;\r\n    println!("{}", type_name::<i32>()); // prints "i32"\r\n    println!("{}", type_name::<(f64, char)>()); // prints "(f64, char)"\r\n}\r\n```\r\n\r\n这被亲切地称之为[turbofish 语法](https://turbo.fish/)，因为`::<>`看起来像条鱼。:)\r\n\r\n结构体也可以是泛型的:\r\n\r\n```rust\r\nstruct Pair<T> {\r\n    a: T,\r\n    b: T,\r\n}\r\n\r\nfn print_type_name<T>(_val: &T) {\r\n    println!("{}", std::any::type_name::<T>());\r\n}\r\n\r\nfn main() {\r\n    let p1 = Pair { a: 3, b: 9 };\r\n    let p2 = Pair { a: true, b: false };\r\n    print_type_name(&p1); // prints "Pair<i32>"\r\n    print_type_name(&p2); // prints "Pair<bool>"\r\n}\r\n```\r\n\r\n标准库中的类型`Vec`(即分配在堆上的数组)就是泛型实现的:\r\n\r\n```rust\r\nfn main() {\r\n    let mut v1 = Vec::new();\r\n    v1.push(1);\r\n    let mut v2 = Vec::new();\r\n    v2.push(false);\r\n    print_type_name(&v1); // prints "Vec<i32>"\r\n    print_type_name(&v2); // prints "Vec<bool>"\r\n}\r\n```\r\n\r\n谈到Vec，有个宏(macro)可以通过字面方式声明Vec变量:\r\n\r\n> Tip：Rust中可以使用`!`定义一个宏，例如`println!`这样的宏；也可以使用上文中`#[derive]`这样的方式进行自定义\r\n\r\n\r\n```rust\r\nfn main() {\r\n    let v1 = vec![1, 2, 3];\r\n    let v2 = vec![true, false, true];\r\n    print_type_name(&v1); // prints "Vec<i32>"\r\n    print_type_name(&v2); // prints "Vec<bool>"\r\n}\r\n```\r\n\r\n类似`name!()`、`name![]`、`name!{}`都是调用宏的方式，宏会被展开成正常的代码。\r\n\r\n事实上，`println`就是一个宏:\r\n\r\n```rust\r\nfn main() {\r\n    println!("{}", "Hello there!");\r\n}\r\n```\r\n\r\n其展开代码和下面的代码功能一样:\r\n\r\n```rust\r\nfn main() {\r\n    use std::io::{self, Write};\r\n    io::stdout().lock().write_all(b"Hello there!\\n").unwrap();\r\n}\r\n```\r\n\r\n`panic`也是一个宏，用来直接停止代码执行并抛出错误信息，同时附带文件名和代码行号（需启用该功能）\r\n\r\n```rust\r\nfn main() {\r\n    panic!("This panics");\r\n}\r\n// output: thread \'main\' panicked at \'This panics\', src/main.rs:3:5\r\n```\r\n\r\n有些方法也会出现`panic`。例如，`Option`类型可以包含某些内容，也可以不包含任何内容。如果对它调用`.unwrap()`，并且它不包含任何内容，则会执行`panic`宏：\r\n\r\n```rust\r\nfn main() {\r\n    let o1: Option<i32> = Some(128);\r\n    o1.unwrap(); // this is fine\r\n\r\n    let o2: Option<i32> = None;\r\n    o2.unwrap(); // this panics!\r\n}\r\n\r\n// output: thread \'main\' panicked at \'called `Option::unwrap()` on a `None` value\', src/libcore/option.rs:378:21\r\n```\r\n\r\n> Tip：Panic 是 Rust 中的一个错误处理机制，当程序遇到无法处理的错误时，它会立即终止当前线程的执行，并开始回溯(unwinding)过程。一般如下情况会出现 Panic:\r\n>\r\n> 1. 显式调用`panic!`宏。\r\n> 2. 某些运行时检查失败，例如数组越界。 [^3]\r\n\r\n`Option`并不是一个结构体，而是一个枚举类型(enum)，它包含两个值:\r\n\r\n```rust\r\nenum Option<T> {\r\n    None,\r\n    Some(T),\r\n}\r\n\r\nimpl<T> Option<T> {\r\n    fn unwrap(self) -> T {\r\n        // enums variants can be used in patterns:\r\n        match self {\r\n            Self::Some(t) => t,\r\n            Self::None => panic!(".unwrap() called on a None option"),\r\n        }\r\n    }\r\n}\r\n\r\nuse self::Option::{None, Some};\r\n\r\nfn main() {\r\n    let o1: Option<i32> = Some(128);\r\n    o1.unwrap(); // this is fine\r\n\r\n    let o2: Option<i32> = None;\r\n    o2.unwrap(); // this panics!\r\n}\r\n\r\n// output: thread \'main\' panicked at \'.unwrap() called on a None option\', src/main.rs:11:27\r\n```\r\n\r\n`Result`也是一个枚举类型。它既可以包含某些结果，也可以包含一个error:\r\n\r\n```rust\r\nenum Result<T, E> {\r\n    Ok(T),\r\n    Err(E),\r\n}\r\n```\r\n\r\n如果包含error，unwrapped时也会触发`panic`。\r\n\r\n变量绑定存在“生命周期”:\r\n\r\n```rust\r\nfn main() {\r\n    // `x` doesn\'t exist yet\r\n    {\r\n        let x = 42; // `x` starts existing\r\n        println!("x = {}", x);\r\n        // `x` stops existing\r\n    }\r\n    // `x` no longer exists\r\n}\r\n```\r\n\r\n类似地，引用同样存在生命周期:\r\n\r\n```rust\r\nfn main() {\r\n    // `x` doesn\'t exist yet\r\n    {\r\n        let x = 42; // `x` starts existing\r\n        let x_ref = &x; // `x_ref` starts existing - it borrows `x`\r\n        println!("x_ref = {}", x_ref);\r\n        // `x_ref` stops existing\r\n        // `x` stops existing\r\n    }\r\n    // `x` no longer exists\r\n}\r\n```\r\n\r\n引用的生命周期无法超过它借用的变量的生命周期:\r\n\r\n```rust\r\nfn main() {\r\n    let x_ref = {\r\n        let x = 42;\r\n        &x\r\n    };\r\n    println!("x_ref = {}", x_ref);\r\n    // error: `x` does not live long enough\r\n}\r\n```\r\n\r\n一个变量可以不可变地引用多次:\r\n\r\n```rust\r\nfn main() {\r\n    let x = 42;\r\n    let x_ref1 = &x;\r\n    let x_ref2 = &x;\r\n    let x_ref3 = &x;\r\n    println!("{} {} {}", x_ref1, x_ref2, x_ref3);\r\n}\r\n```\r\n\r\n在借用的时候，变量不能被修改:\r\n\r\n```rust\r\nfn main() {\r\n    let mut x = 42;\r\n    let x_ref = &x;\r\n    x = 13;\r\n    println!("x_ref = {}", x_ref);\r\n    // error: cannot assign to `x` because it is borrowed\r\n}\r\n```\r\n\r\n当不可变地借用时，不能同时可变地的借用:\r\n\r\n> Tip：即不能对一个变量同时创建不可变和可变的引用\r\n\r\n```rust\r\nfn main() {\r\n    let mut x = 42;\r\n    let x_ref1 = &x;\r\n    let x_ref2 = &mut x;\r\n    // error: cannot borrow `x` as mutable because it is also borrowed as immutable\r\n    println!("x_ref1 = {}", x_ref1);\r\n}\r\n```\r\n\r\n函数参数中的引用同样存在生命周期：\r\n\r\n```rust\r\nfn print(x: &i32) {\r\n    // `x` is borrowed (from the outside) for the\r\n    // entire time this function is called.\r\n}\r\n```\r\n\r\n\r\n[^1]: [A half-hour to learn Rust](https://fasterthanli.me/articles/a-half-hour-to-learn-rust)\r\n[^2]: [Rust半小时教程](https://colobu.com/2020/03/05/A-half-hour-to-learn-Rust/)\r\n[^3]: [深入探索 Rust 中的 Panic 机制](https://juejin.cn/post/7314144983018782761)', 'bodyText': '半小时学习Rust\n\n个人笔记：为了理解rust，添加了一些tip\n\n为了提高编程语言的流畅性，人们必须阅读大量编程语言的相关知识。但如果你不知道它的含义，你怎么能读这么多呢？\n在本文中，我不会专注于一两个概念，而是尝试尽可能多地浏览 Rust 片段，并解释它们包含的关键字和符号的含义。\n准备好了吗？冲！1 2 （根据情况更新笔记）\nlet引入了一个变量绑定：\nlet x; // 声明 "x"\nx = 42; // 将 42 分配给“x”\n也可以写成一行：\nlet x = 42;\n您可以使用:显式地指定变量的类型，这是类型注解：\nlet x: i32; // `i32` 是一个有符号的 32 位整数\nx = 42;\n// 有 i8、i16、i32、i64、i128 表示其他位数的有符号整数\n// 还有 u8、u16、u32、u64、u128 表示无符号整数\n这也可以写成一行：\nlet x: i32 = 42;\n如果您声明一个变量并稍后对其进行初始化，在初始化之前编译器将阻止您使用它。\nlet x;\nfoobar(x); // error: borrow of possibly-uninitialized variable: `x`\nx = 42;\n下面这样做是完全没问题的：\nlet x;\nx = 42;\nfoobar(x); // `x` 的类型可以推断出来\n下划线_是一个特殊名称——或者更确切地说，是“缺乏名称”。_基本上意味着扔掉一些东西：\n// *什么也没做*，因为 42 是一个常数\nlet _ = 42;\n\n// 这调用了 `get_thing` 但丢弃了它的结果\nlet _ = get_thing();\n以下划线“开头”的名称是常规名称，有一点特殊的是，编译器不会警告它们未被使用\n// 我们最终可能会使用 `_x`，但我们的代码仍在编写中\n// 我们现在只想摆脱编译器的警告。\nlet _x = 42；\n可以引入具有相同名称的单独绑定，它会“隐藏”前一个变量绑定：\nlet x = 13;\nlet x = x + 3;\n// 该行之后使用“x”仅引用第二个“x”，\n// 第一个“x”不再存在。\nRust 有tuple——元组类型，您可以将其视为“固定长度的不同类型的集合”。\nlet pair = (\'a\', 17);\npair.0; // this is \'a\'\npair.1; // this is 17\n如果我们真的想给元组中变量增加类型注解，可以用pair：\nlet pair: (char, i32) = (\'a\', 17);\n元组可以通过赋值的方式被“解构”(destructured)，这意味着它们被分解为各自的字段：\nlet (some_char, some_int) = (\'a\', 17);\n// 现在，`some_char` 是 \'a\'，`some_int` 是 17\n当函数返回元组类型时特别管用：\nlet (left, right) = slice.split_at(middle);\n当然，在解构一个元组时，可以用 _ 舍弃掉一部分字段：\nlet (_, right) = slice.split_at(middle);\n分号表示语句的结尾：\nlet x = 3;\nlet y = 5;\nlet z = y + x;\n这意味着语句可以写成多行：\nlet x = vec![1, 2, 3, 4, 5, 6, 7, 8]\n    .iter()\n    .map(|x| x + 3)\n    .fold(0, |x, y| x + y);\n（我们稍后会讨论这些代码的实际含义）。\nfn用来声明一个函数。\n下面是一个 void 函数：\nfn greet() {\n    println!("Hi there!");\n}\n下面是一个返回 32 位有符号整数的函数。使用箭头指示其返回类型：\nfn fair_dice_roll() -> i32 {\n    4\n}\n一对大括号声明一个块，它有自己的作用域：\n// 这首先会打印“in”，然后是“out”\nfn main() {\n    let x = "out";\n    {\n        // 这是一个不同的“x”\n        let x = "in";\n        println!("{}", x);\n    }\n    println!("{}", x);\n}\n“块”也是表达式，意味着它们的计算结果为一个值。\n// 这条语句\nlet x = 42;\n\n// 和这条语句等价\nlet x = { 42 };\n在一个块中，可以有多条语句：\nlet x = {\n    let y = 1; // 第一个声明\n    let z = 2; // 第二个声明\n    y + z // 这是 *结尾*，即整个块的计算结果\n};\n这就是为什么“省略函数末尾的分号”与“返回这个值”相同，即，下面的两个函数是等效的：\nfn fair_dice_roll() -> i32 {\n    return 4;\n}\n\nfn fair_dice_roll() -> i32 {\n    4\n}\nif 条件也可以是表达式：\nfn fair_dice_roll() -> i32 {\n    if feeling_lucky {\n        6\n    } else {\n        4\n    }\n}\nmatch 也是一个表达式：\nfn fair_dice_roll() -> i32 {\n    match feeling_lucky {\n        true => 6,\n        false => 4,\n    }\n}\n“点”.通常用于访问值的字段：\nlet a = (10, 20);\na.0; // this is 10\n\nlet amos = get_some_struct();\namos.nickname; // this is "fasterthanlime"\n或者调用方法：\nlet nick = "fasterthanlime";\nnick.len(); // this is 14\n“双冒号”::与此类似，但它的操作对象是命名空间。\n在此示例中，std是一个 crate（相当于一个库），cmp是一个模块（相当于一个源文件），min是一个函数：\nlet least = std::cmp::min(3, 8); // this is 3\nuse指令可用于将其他命名空间名称引入到当前：\nuse std::cmp::min;\n\nlet least = min(7, 1); // this is 1\n在use指令中，大括号还有另一个含义：它们是一组名称（glob）。如果我们想用use同时导入min和max，那么可以：\n// this works:\nuse std::cmp::min;\nuse std::cmp::max;\n\n// this also works:\nuse std::cmp::{min, max};\n\n// this also works!\nuse std::{cmp::min, cmp::max};\n通配符 * 允许您导入命名空间下所有名称：\n// 这不仅将“min”和“max”引入代码中，而且并包括模块中的其他名称\nuse std::cmp::*;\n类型也是命名空间，方法可以作为常规函数调用：\nlet x = "amos".len(); // this is 4\nlet x = str::len("amos"); // this is also 4\nstr是基本类型(primitive type)，但默认命名空间下也有许多非基本类型。\n// `Vec` 是一个常规结构，而不是原始类型\nlet v = Vec::new();\n\n// 这是和上述完全等价的代码，但具有访问到“Vec”的*完整*路径\nlet v = std::vec::Vec::new();\n这是因为 Rust 会在每个模块的开头插入它：\nuse std::prelude::v1::*;\n（这反过来又会导入其他许多符号，如Vec、String、Option和Result）。\n结构体使用struct关键字声明：\nstruct Vec2 {\n    x: f64, // 64 位浮点，又名“双精度”\n    y: f64,\n}\n它们可以使用“结构体文字”进行初始化：\nlet v1 = Vec2 { x: 1.0, y: 3.0 };\nlet v2 = Vec2 { y: 2.0, x: 4.0 };\n// the order does not matter, only the names do\n有一个快捷方式可以从另一个结构体初始化剩余字段：\nlet v3 = Vec2 {\n    x: 14.0,\n    ..v2\n};\n这被称为“结构更新语法”（struct update syntax），只能发生在最后一个位置，并且不能后跟逗号。\n请注意，“剩余字段”可以是“所有字段”：\nlet v4 = Vec2 { ..v3 };\n结构体和元组一样，可以被解构。\n下面是一个有效的let模式：\nlet (left, right) = slice.split_at(middle);\n也可以这样：\nlet v = Vec2 { x: 3.0, y: 6.0 };\nlet Vec2 { x, y } = v;\n// `x` is now 3.0, `y` is now `6.0`\n还有这个：\nlet Vec2 { x, .. } = v;\n// this throws away `v.y`\nlet模式可以用作if中的条件：\nstruct Number {\n    odd: bool,\n    value: i32,\n}\n\nfn main() {\n    let one = Number { odd: true, value: 1 };\n    let two = Number { odd: false, value: 2 };\n    print_number(one);\n    print_number(two);\n}\n\nfn print_number(n: Number) {\n    if let Number { odd: true, value } = n {\n        println!("Odd number: {}", value);\n    } else if let Number { odd: false, value } = n {\n        println!("Even number: {}", value);\n    }\n}\n\n// this prints:\n// Odd number: 1\n// Even number: 2\nmatch匹配也是一种模式，就像if let:\nfn print_number(n: Number) {\n    match n {\n        Number { odd: true, value } => println!("Odd number: {}", value),\n        Number { odd: false, value } => println!("Even number: {}", value),\n    }\n}\n\n// this prints the same as before\nmatch必须是详尽的，至少需要一个分支来进行匹配\nfn print_number(n: Number) {\n    match n {\n        Number { value: 1, .. } => println!("One"),\n        Number { value: 2, .. } => println!("Two"),\n        Number { value, .. } => println!("{}", value),\n        // if that last arm didn\'t exist, we would get a compile-time error\n    }\n}\n如果这很麻烦，可以用_来匹配所有模式：\nfn print_number(n: Number) {\n    match n.value {\n        1 => println!("One"),\n        2 => println!("Two"),\n        _ => println!("{}", n.value),\n    }\n}\n您可以在自己的类型上声明方法：\nstruct Number {\n    odd: bool,\n    value: i32,\n}\n\nimpl Number {\n    fn is_strictly_positive(self) -> bool {\n        self.value > 0\n    }\n}\n并像往常一样使用它们：\nfn main() {\n    let minus_two = Number {\n        odd: false,\n        value: -2,\n    };\n    println!("positive? {}", minus_two.is_strictly_positive());\n    // this prints "positive? false"\n}\n默认情况下，变量绑定是不可变的，这意味着它的变量值不能改变：\nfn main() {\n    let n = Number {\n        odd: true,\n        value: 17,\n    };\n    n.odd = false; // error: cannot assign to `n.odd`,\n                   // as `n` is not declared to be mutable\n}\n而且它们不能被赋值更改：\nfn main() {\n    let n = Number {\n        odd: true,\n        value: 17,\n    };\n    n = Number {\n        odd: false,\n        value: 22,\n    }; // error: cannot assign twice to immutable variable `n`\n}\nmut允许变量绑定可更改：\nfn main() {\n    let mut n = Number {\n        odd: true,\n        value: 17,\n    }\n    n.value = 19; // all good\n}\ntrait是多种类型拥有的共同点：\ntrait Signed {\n    fn is_strictly_negative(self) -> bool;\n}\n您可以实现：\n\n为任意类型实现你自己定义的trait\n为你的类型实现任意类型的trait\n不允许为别人的类型实现别人的trait\n\n这些被称为“孤立规则”(orphan rules)。\n下面是自定义trait在自定义类型上的实现：\nimpl Signed for Number {\n    fn is_strictly_negative(self) -> bool {\n        self.value < 0\n    }\n}\n\nfn main() {\n    let n = Number { odd: false, value: -44 };\n    println!("{}", n.is_strictly_negative()); // prints "true"\n}\n我们在外部类型（甚至是基本类型）上的实现的自定义trait：\nimpl Signed for i32 {\n    fn is_strictly_negative(self) -> bool {\n        self < 0\n    }\n}\n\nfn main() {\n    let n: i32 = -44;\n    println!("{}", n.is_strictly_negative()); // prints "true"\n}\n自定义类型的外部trait：\n// `Neg` 特性用于重载 `-`，\n// 一元减运算符。\nimpl std::ops::Neg for Number {\n    type Output = Number;\n\n    fn neg(self) -> Number {\n        Number {\n            value: -self.value,\n            odd: self.odd,\n        }        \n    }\n}\n\nfn main() {\n    let n = Number { odd: true, value: 987 };\n    let m = -n; // this is only possible because we implemented `Neg`\n    println!("{}", m.value); // prints "-987"\n}\nimpl块总是用来为类型实现方法，因此，在该块内，Self可以指代该类型:\nimpl std::ops::Neg for Number {\n    type Output = Self;\n\n    fn neg(self) -> Self {\n        Self {\n            value: -self.value,\n            odd: self.odd,\n        }        \n    }\n}\n有些trait是“标记”——它们并不是说类型实现了某些方法，而是说可以用类型完成某些事情。\n例如i32实现Copy trait(简单地讲，i32是可复制的)，所以下面的代码工作正常:\nfn main() {\n    let a: i32 = 15;\n    let b = a; // `a` is copied\n    let c = a; // `a` is copied again\n}\n这也是正常的：\nfn print_i32(x: i32) {\n    println!("x = {}", x);\n}\n\nfn main() {\n    let a: i32 = 15;\n    print_i32(a); // `a` is copied\n    print_i32(a); // `a` is copied again\n}\n但Number类型没有实现Copy，所以下面的代码不起作用：\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n; // `n` is moved into `m`\n    let o = n; // error: use of moved value: `n`\n}\n这也不行：\nfn print_number(n: Number) {\n    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);\n}\n\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    print_number(n); // `n` is moved\n    print_number(n); // error: use of moved value: `n`\n}\n但如果采用不可变的引用print_number，就是可行的：\nfn print_number(n: &Number) {\n    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);\n}\n\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    print_number(&n); // `n` is borrowed for the time of the call\n    print_number(&n); // `n` is borrowed again\n}\n如果变量被声明为可变的，则函数参数使用可变引用也可以工作:\nfn invert(n: &mut Number) {\n    n.value = -n.value;\n}\nfn print_number(n: &Number) {\n    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);\n}\nfn main() {\n    // this time, `n` is mutable\n    let mut n = Number { odd: true, value: 51 };\n    print_number(&n);\n    invert(&mut n); // `n is borrowed mutably - everything is explicit\n    print_number(&n);\n}\nTrait 方法中的self参数可以使用引用，也可以使用不可变引用\nimpl std::clone::Clone for Number {\n    fn clone(&self) -> Self {\n        Self { ..*self }\n    }\n当调用trait的方法时，receiver隐式地被借用\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    let mut m = n.clone();\n    m.value += 100;\n    \n    print_number(&n);\n    print_number(&m);\n}\n强调一点，下面的代码是等价的:\nlet m = n.clone();\n\nlet m = std::clone::Clone::clone(&n);\n像 Copy 这样的 Marker traits 是没有实现原对象trait方法的\n// note: `Copy` requires that `Clone` is implemented too\nimpl std::clone::Clone for Number {\n    fn clone(&self) -> Self {\n        Self { ..*self }\n    }\n}\n\nimpl std::marker::Copy for Number {}\n现在Clone仍然可以使用:\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n.clone();\n    let o = n.clone();\n}\n但是Number的值不会被转移了\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n; // `m` is a copy of `n`\n    let o = n; // same. `n` is neither moved nor borrowed.\n}\n一些trait太通用了，我们可以通过derive属性自动实现它们:\n#[derive(Clone, Copy)]\nstruct Number {\n    odd: bool,\n    value: i32,\n}\n\n// this expands to `impl Clone for Number` and `impl Copy for Number` blocks.\n函数可以是泛型的:\nfn foobar<T>(arg: T) {\n    // do something with `arg`\n}\n它们可以有多个“类型参数”，类型参数用在函数声明和函数体中，用来替代具体的类型:\nfn foobar<L, R>(left: L, right: R) {\n    // do something with `left` and `right`\n}\n类型参数通常有“约束”，所以你可以用它做一些额外的事情。\n最简单的约束就是trait名称:\nfn print<T: Display>(value: T) {\n    println!("value = {}", value);\n}\n\nfn print<T: Debug>(value: T) {\n    println!("value = {:?}", value);\n}\n类型参数约束可以有更长的语法：\nfn print<T>(value: T)\nwhere\n    T: Display,\n{\n    println!("value = {}", value);\n}\n约束还可以变得更加复杂，比如要求类型参数要实现多种trait:\nuse std::fmt::Debug;\n\nfn compare<T>(left: T, right: T)\nwhere\n    T: Debug + PartialEq,\n{\n    println!("{:?} {} {:?}", left, if left == right { "==" } else { "!=" }, right);\n}\n\nfn main() {\n    compare("tea", "coffee");\n    // prints: "tea" != "coffee"\n}\n泛型函数可以被当作一个命名空间，包含无穷多个不同具体类型的函数。\n类似crate、module和type，泛型函数可以使用::导航:\nfn main() {\n    use std::any::type_name;\n    println!("{}", type_name::<i32>()); // prints "i32"\n    println!("{}", type_name::<(f64, char)>()); // prints "(f64, char)"\n}\n这被亲切地称之为turbofish 语法，因为::<>看起来像条鱼。:)\n结构体也可以是泛型的:\nstruct Pair<T> {\n    a: T,\n    b: T,\n}\n\nfn print_type_name<T>(_val: &T) {\n    println!("{}", std::any::type_name::<T>());\n}\n\nfn main() {\n    let p1 = Pair { a: 3, b: 9 };\n    let p2 = Pair { a: true, b: false };\n    print_type_name(&p1); // prints "Pair<i32>"\n    print_type_name(&p2); // prints "Pair<bool>"\n}\n标准库中的类型Vec(即分配在堆上的数组)就是泛型实现的:\nfn main() {\n    let mut v1 = Vec::new();\n    v1.push(1);\n    let mut v2 = Vec::new();\n    v2.push(false);\n    print_type_name(&v1); // prints "Vec<i32>"\n    print_type_name(&v2); // prints "Vec<bool>"\n}\n谈到Vec，有个宏(macro)可以通过字面方式声明Vec变量:\n\nTip：Rust中可以使用!定义一个宏，例如println!这样的宏；也可以使用上文中#[derive]这样的方式进行自定义\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n    let v2 = vec![true, false, true];\n    print_type_name(&v1); // prints "Vec<i32>"\n    print_type_name(&v2); // prints "Vec<bool>"\n}\n类似name!()、name![]、name!{}都是调用宏的方式，宏会被展开成正常的代码。\n事实上，println就是一个宏:\nfn main() {\n    println!("{}", "Hello there!");\n}\n其展开代码和下面的代码功能一样:\nfn main() {\n    use std::io::{self, Write};\n    io::stdout().lock().write_all(b"Hello there!\\n").unwrap();\n}\npanic也是一个宏，用来直接停止代码执行并抛出错误信息，同时附带文件名和代码行号（需启用该功能）\nfn main() {\n    panic!("This panics");\n}\n// output: thread \'main\' panicked at \'This panics\', src/main.rs:3:5\n有些方法也会出现panic。例如，Option类型可以包含某些内容，也可以不包含任何内容。如果对它调用.unwrap()，并且它不包含任何内容，则会执行panic宏：\nfn main() {\n    let o1: Option<i32> = Some(128);\n    o1.unwrap(); // this is fine\n\n    let o2: Option<i32> = None;\n    o2.unwrap(); // this panics!\n}\n\n// output: thread \'main\' panicked at \'called `Option::unwrap()` on a `None` value\', src/libcore/option.rs:378:21\n\nTip：Panic 是 Rust 中的一个错误处理机制，当程序遇到无法处理的错误时，它会立即终止当前线程的执行，并开始回溯(unwinding)过程。一般如下情况会出现 Panic:\n\n显式调用panic!宏。\n某些运行时检查失败，例如数组越界。 3\n\n\nOption并不是一个结构体，而是一个枚举类型(enum)，它包含两个值:\nenum Option<T> {\n    None,\n    Some(T),\n}\n\nimpl<T> Option<T> {\n    fn unwrap(self) -> T {\n        // enums variants can be used in patterns:\n        match self {\n            Self::Some(t) => t,\n            Self::None => panic!(".unwrap() called on a None option"),\n        }\n    }\n}\n\nuse self::Option::{None, Some};\n\nfn main() {\n    let o1: Option<i32> = Some(128);\n    o1.unwrap(); // this is fine\n\n    let o2: Option<i32> = None;\n    o2.unwrap(); // this panics!\n}\n\n// output: thread \'main\' panicked at \'.unwrap() called on a None option\', src/main.rs:11:27\nResult也是一个枚举类型。它既可以包含某些结果，也可以包含一个error:\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n如果包含error，unwrapped时也会触发panic。\n变量绑定存在“生命周期”:\nfn main() {\n    // `x` doesn\'t exist yet\n    {\n        let x = 42; // `x` starts existing\n        println!("x = {}", x);\n        // `x` stops existing\n    }\n    // `x` no longer exists\n}\n类似地，引用同样存在生命周期:\nfn main() {\n    // `x` doesn\'t exist yet\n    {\n        let x = 42; // `x` starts existing\n        let x_ref = &x; // `x_ref` starts existing - it borrows `x`\n        println!("x_ref = {}", x_ref);\n        // `x_ref` stops existing\n        // `x` stops existing\n    }\n    // `x` no longer exists\n}\n引用的生命周期无法超过它借用的变量的生命周期:\nfn main() {\n    let x_ref = {\n        let x = 42;\n        &x\n    };\n    println!("x_ref = {}", x_ref);\n    // error: `x` does not live long enough\n}\n一个变量可以不可变地引用多次:\nfn main() {\n    let x = 42;\n    let x_ref1 = &x;\n    let x_ref2 = &x;\n    let x_ref3 = &x;\n    println!("{} {} {}", x_ref1, x_ref2, x_ref3);\n}\n在借用的时候，变量不能被修改:\nfn main() {\n    let mut x = 42;\n    let x_ref = &x;\n    x = 13;\n    println!("x_ref = {}", x_ref);\n    // error: cannot assign to `x` because it is borrowed\n}\n当不可变地借用时，不能同时可变地的借用:\n\nTip：即不能对一个变量同时创建不可变和可变的引用\n\nfn main() {\n    let mut x = 42;\n    let x_ref1 = &x;\n    let x_ref2 = &mut x;\n    // error: cannot borrow `x` as mutable because it is also borrowed as immutable\n    println!("x_ref1 = {}", x_ref1);\n}\n函数参数中的引用同样存在生命周期：\nfn print(x: &i32) {\n    // `x` is borrowed (from the outside) for the\n    // entire time this function is called.\n}\nFootnotes\n\n\nA half-hour to learn Rust ↩\n\n\nRust半小时教程 ↩\n\n\n深入探索 Rust 中的 Panic 机制 ↩', 'author': {'login': 'jygzyc'}, 'category': {'name': '0102-编程'}, 'labels': {'nodes': [{'name': '010204-Rust'}]}, 'comments': {'nodes': []}}, {'title': 'JavaScript基础', 'number': 7, 'url': 'https://github.com/jygzyc/notes/discussions/7', 'createdAt': '2024-04-19T02:47:05Z', 'lastEditedAt': '2024-05-11T03:44:53Z', 'updatedAt': '2024-05-11T03:44:53Z', 'body': "<!-- javascript_base -->\r\n## Promise\r\n\r\n> 转发自[Promise - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544)，学习自用\r\n\r\n在JavaScript的世界中，所有代码都是单线程执行的。\r\n\r\n由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：\r\n\r\n```js\r\nfunction callback() {\r\n    console.log('Done');\r\n}\r\nconsole.log('before setTimeout()');\r\nsetTimeout(callback, 1000); // 1秒钟后调用callback函数\r\nconsole.log('after setTimeout()');\r\n```\r\n\r\n上述代码输出为\r\n\r\n```bash\r\nbefore setTimeout()\r\nafter setTimeout()\r\n(等待1秒后)\r\nDone\r\n```\r\n\r\n可见，异步操作会在将来的某个时间点触发一个函数调用。\r\n\r\n我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：\r\n\r\n```js\r\nfunction test(resolve, reject) {\r\n    var timeOut = Math.random() * 2;\r\n    log('set timeout to: ' + timeOut + ' seconds.');\r\n    setTimeout(function () {\r\n        if (timeOut < 1) {\r\n            log('call resolve()...');\r\n            resolve('200 OK');\r\n        }\r\n        else {\r\n            log('call reject()...');\r\n            reject('timeout in ' + timeOut + ' seconds.');\r\n        }\r\n    }, timeOut * 1000);\r\n}\r\n```\r\n\r\n这个`test()`函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用`resolve('200 OK')`，如果执行失败，我们将调用`reject('timeout in ' + timeOut + ' seconds.')`。可以看出，`test()`函数只关心自身的逻辑，并不关心具体的`resolve`和`reject`将如何处理结果。\r\n\r\n有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：\r\n\r\n```js\r\nvar p1 = new Promise(test);\r\nvar p2 = p1.then(function (result) {\r\n    console.log('成功：' + result);\r\n});\r\nvar p3 = p2.catch(function (reason) {\r\n    console.log('失败：' + reason);\r\n});\r\n```\r\n\r\n变量`p1`是一个Promise对象，它负责执行`test`函数。由于`test`函数在内部是异步执行的，当`test`函数执行成功时，我们告诉Promise对象：\r\n\r\n```js\r\n// 如果成功，执行这个函数：\r\np1.then(function (result) {\r\n    console.log('成功：' + result);\r\n});\r\n```\r\n\r\n当`test`函数执行失败时，我们告诉Promise对象\r\n\r\n```js\r\np2.catch(function (reason) {\r\n    console.log('失败：' + reason);\r\n});\r\n```\r\n\r\nPromise对象可以串联起来，所以上述代码可以简化为：\r\n\r\n```js\r\nnew Promise(test).then(function (result) {\r\n    console.log('成功：' + result);\r\n}).catch(function (reason) {\r\n    console.log('失败：' + reason);\r\n});\r\n```\r\n\r\n实际测试一下，看看Promise是如何异步执行的：\r\n\r\n```js\r\nnew Promise(function (resolve, reject) {\r\n    log('start new Promise...');\r\n    var timeOut = Math.random() * 2;\r\n    log('set timeout to: ' + timeOut + ' seconds.');\r\n    setTimeout(function () {\r\n        if (timeOut < 1) {\r\n            log('call resolve()...');\r\n            resolve('200 OK');\r\n        }\r\n        else {\r\n            log('call reject()...');\r\n            reject('timeout in ' + timeOut + ' seconds.');\r\n        }\r\n    }, timeOut * 1000);\r\n}).then(function (r) {\r\n    log('Done: ' + r);\r\n}).catch(function (reason) {\r\n    log('Failed: ' + reason);\r\n});\r\n```\r\n\r\n执行结果为\r\n\r\n```bash\r\nLog:\r\nstart new Promise...\r\nset timeout to: 0.9886794993641219 seconds.\r\ncall resolve()...\r\nDone: 200 OK\r\n```\r\n\r\n可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了\r\n\r\nPromise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。\r\n\r\n要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：\r\n\r\n```js\r\njob1.then(job2).then(job3).catch(handleError);\r\n```\r\n\r\n其中，`job1`、`job2`和`job3`都是Promise对象。\r\n\r\n除了串行执行若干异步任务外，Promise还可以并行执行异步任务。\r\n\r\n试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用`Promise.all()`实现如下\r\n\r\n```js\r\nvar p1 = new Promise(function (resolve, reject) {\r\n    setTimeout(resolve, 500, 'P1');\r\n});\r\nvar p2 = new Promise(function (resolve, reject) {\r\n    setTimeout(resolve, 600, 'P2');\r\n});\r\n// 同时执行p1和p2，并在它们都完成后执行then:\r\nPromise.all([p1, p2]).then(function (results) {\r\n    console.log(results); // 获得一个Array: ['P1', 'P2']\r\n});\r\n```\r\n\r\n有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用`Promise.race()`实现：\r\n\r\n```js\r\nvar p1 = new Promise(function (resolve, reject) {\r\n    setTimeout(resolve, 500, 'P1');\r\n});\r\nvar p2 = new Promise(function (resolve, reject) {\r\n    setTimeout(resolve, 600, 'P2');\r\n});\r\nPromise.race([p1, p2]).then(function (result) {\r\n    console.log(result); // 'P1'\r\n});\r\n```\r\n\r\n由于`p1`执行较快，Promise的`then()`将获得结果'P1'。`p2`仍在继续执行，但执行结果将被丢弃。\r\n\r\n如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。\r\n\r\n## async函数\r\n\r\n> 转发自[async函数 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1022910821149312/1536754328797217)，学习自用\r\n\r\n我们说JavaScript异步操作需要通过Promise实现，一个Promise对象在操作网络时是异步的，等到返回后再调用回调函数，执行正确就调用`then()`，执行错误就调用`catch()`，虽然异步实现了，不会让用户感觉到页面“卡住”了，但是一堆`then()`、`catch()`写起来麻烦看起来也乱。\r\n\r\n可以用关键字async配合await调用Promise，实现异步操作，但代码却和同步写法类似：\r\n\r\n```js\r\nasync function get(url) {\r\n    let resp = await fetch(url);\r\n    return resp.json();\r\n}\r\n```\r\n\r\n使用`async function`可以定义一个异步函数，异步函数和Promise可以看作是等价的，在`async function`内部，用`await`调用另一个异步函数，写起来和同步代码没啥区别，但执行起来是异步的。\r\n\r\n也就是说：\r\n\r\n```js\r\nlet resp = await fetch(url);\r\n```\r\n\r\n自动实现了异步调用，它和下面的Promise代码等价：\r\n\r\n```js\r\nlet promise = fetch(url);\r\npromise.then((resp) => {\r\n    // 拿到resp\r\n})\r\n```\r\n\r\n如果我们要实现`catch()`怎么办？用Promise的写法如下：\r\n\r\n```js\r\nlet promise = fetch(url);\r\npromise.then((resp) => {\r\n    // 拿到resp\r\n}).catch(e => {\r\n    // 出错了\r\n});\r\n```\r\n\r\n用await调用时，直接用传统的`try{ ... } catch`\r\n\r\n```js\r\nasync function get(url) {\r\n    try {\r\n        let resp = await fetch(url);\r\n        return resp.json();\r\n    } catch (e) {\r\n        // 出错了\r\n    }\r\n}\r\n```\r\n\r\n用async定义异步函数，用await调用异步函数，写起来和同步代码差不多，但可读性大大提高。\r\n\r\n需要特别注意的是，`await`调用必须在`async function`中，不能在传统的同步代码中调用。那么问题来了，一个同步function怎么调用async function呢？\r\n\r\n首先，普通function直接用await调用异步函数将报错：\r\n\r\n```js\r\nasync function get(url) {\r\n    let resp = await fetch(url);\r\n    return resp.json();\r\n}\r\n\r\nfunction doGet() {\r\n    let data = await get('/api/categories');\r\n    console.log(data);\r\n}\r\n\r\ndoGet();\r\n```\r\n\r\n执行结果为`SyntaxError: await is only valid in async functions and the top level bodies of modules`\r\n\r\n如果把`await`去掉，调用实际上发生了，但我们拿不到结果，因为我们拿到的并不是异步结果，而是一个Promise对象：\r\n\r\n```js\r\nasync function get(url) {\r\n    let resp = await fetch(url);\r\n    return resp.json();\r\n}\r\n\r\nfunction doGet() {\r\n    let promise = get('/api/categories');\r\n    console.log(promise);\r\n}\r\n\r\ndoGet();\r\n```\r\n\r\n执行结果为`[object Promise]`\r\n\r\n因此，在普通function中调用async function，不能使用await，但可以直接调用async function拿到Promise对象，后面加上`then()`和`catch()`就可以拿到结果或错误了：\r\n\r\n```js\r\nasync function get(url) {\r\n    let resp = await fetch(url);\r\n    return resp.json();\r\n}\r\n\r\nfunction doGet() {\r\n    let promise = get('/api/categories');\r\n    promise.then(data => {\r\n        // 拿到data\r\n        document.getElementById('test-response-text').value = JSON.stringify(data);\r\n    });\r\n}\r\n\r\ndoGet();\r\n```\r\n\r\n因此，定义异步任务时，使用async function比Promise简单，调用异步任务时，使用await比Promise简单，捕获错误时，按传统的`try...catch`写法，也比Promise简单。只要浏览器支持，完全可以用`async`简洁地实现异步操作。", 'bodyText': "Promise\n\n转发自Promise - 廖雪峰的官方网站，学习自用\n\n在JavaScript的世界中，所有代码都是单线程执行的。\n由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：\nfunction callback() {\n    console.log('Done');\n}\nconsole.log('before setTimeout()');\nsetTimeout(callback, 1000); // 1秒钟后调用callback函数\nconsole.log('after setTimeout()');\n上述代码输出为\nbefore setTimeout()\nafter setTimeout()\n(等待1秒后)\nDone\n可见，异步操作会在将来的某个时间点触发一个函数调用。\n我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：\nfunction test(resolve, reject) {\n    var timeOut = Math.random() * 2;\n    log('set timeout to: ' + timeOut + ' seconds.');\n    setTimeout(function () {\n        if (timeOut < 1) {\n            log('call resolve()...');\n            resolve('200 OK');\n        }\n        else {\n            log('call reject()...');\n            reject('timeout in ' + timeOut + ' seconds.');\n        }\n    }, timeOut * 1000);\n}\n这个test()函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用resolve('200 OK')，如果执行失败，我们将调用reject('timeout in ' + timeOut + ' seconds.')。可以看出，test()函数只关心自身的逻辑，并不关心具体的resolve和reject将如何处理结果。\n有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：\nvar p1 = new Promise(test);\nvar p2 = p1.then(function (result) {\n    console.log('成功：' + result);\n});\nvar p3 = p2.catch(function (reason) {\n    console.log('失败：' + reason);\n});\n变量p1是一个Promise对象，它负责执行test函数。由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象：\n// 如果成功，执行这个函数：\np1.then(function (result) {\n    console.log('成功：' + result);\n});\n当test函数执行失败时，我们告诉Promise对象\np2.catch(function (reason) {\n    console.log('失败：' + reason);\n});\nPromise对象可以串联起来，所以上述代码可以简化为：\nnew Promise(test).then(function (result) {\n    console.log('成功：' + result);\n}).catch(function (reason) {\n    console.log('失败：' + reason);\n});\n实际测试一下，看看Promise是如何异步执行的：\nnew Promise(function (resolve, reject) {\n    log('start new Promise...');\n    var timeOut = Math.random() * 2;\n    log('set timeout to: ' + timeOut + ' seconds.');\n    setTimeout(function () {\n        if (timeOut < 1) {\n            log('call resolve()...');\n            resolve('200 OK');\n        }\n        else {\n            log('call reject()...');\n            reject('timeout in ' + timeOut + ' seconds.');\n        }\n    }, timeOut * 1000);\n}).then(function (r) {\n    log('Done: ' + r);\n}).catch(function (reason) {\n    log('Failed: ' + reason);\n});\n执行结果为\nLog:\nstart new Promise...\nset timeout to: 0.9886794993641219 seconds.\ncall resolve()...\nDone: 200 OK\n可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了\nPromise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。\n要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：\njob1.then(job2).then(job3).catch(handleError);\n其中，job1、job2和job3都是Promise对象。\n除了串行执行若干异步任务外，Promise还可以并行执行异步任务。\n试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下\nvar p1 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 500, 'P1');\n});\nvar p2 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 600, 'P2');\n});\n// 同时执行p1和p2，并在它们都完成后执行then:\nPromise.all([p1, p2]).then(function (results) {\n    console.log(results); // 获得一个Array: ['P1', 'P2']\n});\n有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：\nvar p1 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 500, 'P1');\n});\nvar p2 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 600, 'P2');\n});\nPromise.race([p1, p2]).then(function (result) {\n    console.log(result); // 'P1'\n});\n由于p1执行较快，Promise的then()将获得结果'P1'。p2仍在继续执行，但执行结果将被丢弃。\n如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。\nasync函数\n\n转发自async函数 - 廖雪峰的官方网站，学习自用\n\n我们说JavaScript异步操作需要通过Promise实现，一个Promise对象在操作网络时是异步的，等到返回后再调用回调函数，执行正确就调用then()，执行错误就调用catch()，虽然异步实现了，不会让用户感觉到页面“卡住”了，但是一堆then()、catch()写起来麻烦看起来也乱。\n可以用关键字async配合await调用Promise，实现异步操作，但代码却和同步写法类似：\nasync function get(url) {\n    let resp = await fetch(url);\n    return resp.json();\n}\n使用async function可以定义一个异步函数，异步函数和Promise可以看作是等价的，在async function内部，用await调用另一个异步函数，写起来和同步代码没啥区别，但执行起来是异步的。\n也就是说：\nlet resp = await fetch(url);\n自动实现了异步调用，它和下面的Promise代码等价：\nlet promise = fetch(url);\npromise.then((resp) => {\n    // 拿到resp\n})\n如果我们要实现catch()怎么办？用Promise的写法如下：\nlet promise = fetch(url);\npromise.then((resp) => {\n    // 拿到resp\n}).catch(e => {\n    // 出错了\n});\n用await调用时，直接用传统的try{ ... } catch\nasync function get(url) {\n    try {\n        let resp = await fetch(url);\n        return resp.json();\n    } catch (e) {\n        // 出错了\n    }\n}\n用async定义异步函数，用await调用异步函数，写起来和同步代码差不多，但可读性大大提高。\n需要特别注意的是，await调用必须在async function中，不能在传统的同步代码中调用。那么问题来了，一个同步function怎么调用async function呢？\n首先，普通function直接用await调用异步函数将报错：\nasync function get(url) {\n    let resp = await fetch(url);\n    return resp.json();\n}\n\nfunction doGet() {\n    let data = await get('/api/categories');\n    console.log(data);\n}\n\ndoGet();\n执行结果为SyntaxError: await is only valid in async functions and the top level bodies of modules\n如果把await去掉，调用实际上发生了，但我们拿不到结果，因为我们拿到的并不是异步结果，而是一个Promise对象：\nasync function get(url) {\n    let resp = await fetch(url);\n    return resp.json();\n}\n\nfunction doGet() {\n    let promise = get('/api/categories');\n    console.log(promise);\n}\n\ndoGet();\n执行结果为[object Promise]\n因此，在普通function中调用async function，不能使用await，但可以直接调用async function拿到Promise对象，后面加上then()和catch()就可以拿到结果或错误了：\nasync function get(url) {\n    let resp = await fetch(url);\n    return resp.json();\n}\n\nfunction doGet() {\n    let promise = get('/api/categories');\n    promise.then(data => {\n        // 拿到data\n        document.getElementById('test-response-text').value = JSON.stringify(data);\n    });\n}\n\ndoGet();\n因此，定义异步任务时，使用async function比Promise简单，调用异步任务时，使用await比Promise简单，捕获错误时，按传统的try...catch写法，也比Promise简单。只要浏览器支持，完全可以用async简洁地实现异步操作。", 'author': {'login': 'jygzyc'}, 'category': {'name': '0102-编程'}, 'labels': {'nodes': [{'name': '010201-JavaScript'}]}, 'comments': {'nodes': []}}, {'title': '家常菜菜谱', 'number': 6, 'url': 'https://github.com/jygzyc/notes/discussions/6', 'createdAt': '2024-04-19T02:35:45Z', 'lastEditedAt': None, 'updatedAt': '2024-04-19T02:35:47Z', 'body': '## 荤菜\r\n\r\n### 羊肉汤\r\n\r\n1. 羊肉漂洗（可加面粉）\r\n2. 羊肉冷水下锅飞水，捞出冲洗干净\r\n3. 砂锅一次性水加够，拍破的生姜，大葱，适量花椒，冷水浸泡后的当归（胡须形状为宜），白胡椒粉，料酒；烧开关小火\r\n4. 90分钟后捞出大葱，下白萝卜，大枣，开大火，炖15分钟\r\n5. 加盐，加枸杞，再炖5分钟\r\n6. 下葱花，香菜，出锅\r\n\r\n### 大虾炒白菜\r\n\r\n食材：大虾、500g白菜、30g葱姜、3g盐、2g糖、1g味精、3g淀粉\r\n\r\n1. 大虾须子剪掉，前面的虾腔剪掉，虾头内沙包剪掉，虾头剪掉（稍后熬虾汤用）虾背剪开，去掉虾线（去腥，便于入味）处理好的虾洗净\r\n2. 锅中放油，放入虾头，慢慢煎出香味。放入30g葱姜（去腥）放入热水。熬至虾汤浓稠。捞出虾皮，虾汤放一旁备用\r\n3. 重新倒油，放入白菜煸炒（锅中干的话烹水）\r\n4. 锅中放入干净油，放入大虾煎炒，大虾煎透后加入虾汤，白菜。放3g盐、2g糖、1g味精，定味。白菜软烂入味时，收汁勾芡。出锅\r\n\r\n### 番茄炖牛腩\r\n\r\n食材：牛肋腩1000g，西红柿700g，葱100g，姜30g，大料4个，油50g，番茄酱50g，盐6g，味精1g，糖15g\r\n\r\n1. 牛肋腩切成肉块，去皮西红柿切块备用\r\n2. 牛腩块冷水下锅，另备高压锅烧水并加入葱，姜，大料；牛腩块撇出血沫，捞入高压锅中上汽煮30分钟\r\n3. 起锅烧油（干净油），加入葱和少量蒜，葱煸黄后倒入西红柿、适量番茄酱，炒香后倒入煮好的牛腩和适量煮牛腩的汤，加入适量盐、糖、味精（个人口味，偏酸可加糖）调味，小火煮2-3分钟直至味道融合\r\n4. 加香菜，出锅\r\n\r\n### 红汁牛肉\r\n\r\n食材：牛上脑，口蘑，洋葱，红酒，番茄酱\r\n\r\n1. 牛上脑肉切大丁，加白胡椒粉，半勺盐，红酒，揉匀腌制（10分钟即可）\r\n2. 口蘑改刀，分离伞柄和伞盖，切片；洋葱切末\r\n3. 起锅烧油（干净油），煎一下刚刚切好的口蘑（增加风味），微微带色后盛出；烧油（干净油）煎牛肉，煎至上色且基本成熟后出锅；\r\n4. 锅中下黄油，色拉油两种油，化开黄油，下洋葱炒出香味，加适量番茄酱翻炒，倒入少许红酒，转大火加水，下牛肉\r\n5. 锅中加入适量盐（1g左右）、糖（2g左右），烧制10分钟，加入口蘑（连汤），再烧制3-5分钟直至收汁粘稠，出锅\r\n6. 可另摆酸黄瓜配菜\r\n\r\n## 素菜\r\n\r\n> TODO', 'bodyText': '荤菜\n羊肉汤\n\n羊肉漂洗（可加面粉）\n羊肉冷水下锅飞水，捞出冲洗干净\n砂锅一次性水加够，拍破的生姜，大葱，适量花椒，冷水浸泡后的当归（胡须形状为宜），白胡椒粉，料酒；烧开关小火\n90分钟后捞出大葱，下白萝卜，大枣，开大火，炖15分钟\n加盐，加枸杞，再炖5分钟\n下葱花，香菜，出锅\n\n大虾炒白菜\n食材：大虾、500g白菜、30g葱姜、3g盐、2g糖、1g味精、3g淀粉\n\n大虾须子剪掉，前面的虾腔剪掉，虾头内沙包剪掉，虾头剪掉（稍后熬虾汤用）虾背剪开，去掉虾线（去腥，便于入味）处理好的虾洗净\n锅中放油，放入虾头，慢慢煎出香味。放入30g葱姜（去腥）放入热水。熬至虾汤浓稠。捞出虾皮，虾汤放一旁备用\n重新倒油，放入白菜煸炒（锅中干的话烹水）\n锅中放入干净油，放入大虾煎炒，大虾煎透后加入虾汤，白菜。放3g盐、2g糖、1g味精，定味。白菜软烂入味时，收汁勾芡。出锅\n\n番茄炖牛腩\n食材：牛肋腩1000g，西红柿700g，葱100g，姜30g，大料4个，油50g，番茄酱50g，盐6g，味精1g，糖15g\n\n牛肋腩切成肉块，去皮西红柿切块备用\n牛腩块冷水下锅，另备高压锅烧水并加入葱，姜，大料；牛腩块撇出血沫，捞入高压锅中上汽煮30分钟\n起锅烧油（干净油），加入葱和少量蒜，葱煸黄后倒入西红柿、适量番茄酱，炒香后倒入煮好的牛腩和适量煮牛腩的汤，加入适量盐、糖、味精（个人口味，偏酸可加糖）调味，小火煮2-3分钟直至味道融合\n加香菜，出锅\n\n红汁牛肉\n食材：牛上脑，口蘑，洋葱，红酒，番茄酱\n\n牛上脑肉切大丁，加白胡椒粉，半勺盐，红酒，揉匀腌制（10分钟即可）\n口蘑改刀，分离伞柄和伞盖，切片；洋葱切末\n起锅烧油（干净油），煎一下刚刚切好的口蘑（增加风味），微微带色后盛出；烧油（干净油）煎牛肉，煎至上色且基本成熟后出锅；\n锅中下黄油，色拉油两种油，化开黄油，下洋葱炒出香味，加适量番茄酱翻炒，倒入少许红酒，转大火加水，下牛肉\n锅中加入适量盐（1g左右）、糖（2g左右），烧制10分钟，加入口蘑（连汤），再烧制3-5分钟直至收汁粘稠，出锅\n可另摆酸黄瓜配菜\n\n素菜\n\nTODO', 'author': {'login': 'jygzyc'}, 'category': {'name': '0201-饮食'}, 'labels': {'nodes': []}, 'comments': {'nodes': []}}, {'title': '沉潜于水下的人', 'number': 5, 'url': 'https://github.com/jygzyc/notes/discussions/5', 'createdAt': '2024-04-19T02:33:34Z', 'lastEditedAt': None, 'updatedAt': '2024-04-19T02:33:35Z', 'body': '> 谨以此文献给我三年的战友，我信赖的朋友，我热爱的亲人，以及这片我生活了十八年的土地和在这座小城中努力生存的人们。今当远离，以后的日子，愿我们在深邃的星空中，留下自己灿烂的光辉。\r\n\r\n很久以前，我的祖先就被迫迁徙到这片荒芜的土地上，在这里养育后代，至少在我太奶奶的讲述下，祖祖辈辈开始了在这儿的生活。最初，祖先们是不愿意来到这里的，不仅因为原来的日子安逸祥和，更是因为这儿除了骆驼草和石头之外别无他物，但是，头头们觉得戈壁滩不远处的荒山里的矿石有开发的价值，就把祖先们抓到这儿做劳工，这地儿才有了灵气儿。后来，娃娃们从女人的肚子里钻出来，轻轻落到土里，伴着嗷嗷的哭声，戈壁滩也成了座小城。\r\n\r\n---\r\n\r\n对于我的家族而言，我们是自豪的，因为至少我们曾分布在小城的各个角落，拥有大大小小的“领土”。在很长一段时间里，家族的成年人，作为小城的劳工，担负着水，电，食物等的供应和清洁任务。对于身材并不颀长的祖辈来说，这些任务并不简单。但是，家族的鼎盛时期，却也是这会儿，这一切，还得归功于我的祖父。\r\n\r\n---\r\n\r\n我家族里的人都姓“罗恩”，至于为什么会有这样一个奇怪的姓，我曾经为此向我的叔叔打探过，叔叔也只是摇了摇头，转而去问了祖父。出乎意料的是，祖父竟然也不大清楚，只说这名字是祖辈们生下来就有的。既然连家族中最智慧的祖父都不知道的话，问其他人也只是徒劳而已，我也只能就此作罢。祖父的全名叫“罗恩·利尼斯”，其实，我的内心很疑惑——在那么落后和闭塞的时代，太爷爷是如何想出来这样一个洋气的名字。等到成年了，我也觉得这事儿无关紧要，渐渐就淡忘了。\r\n\r\n我的祖父，是罗恩家族公认的最伟大的人之一。在祖父还小的时候，小城里只有一点点面粉，对此，作为负责饮食的劳工，我的太爷爷很是发愁，“怎样才能弥补食物的空缺呢？”\r\n就在这节骨眼上，我的祖父奇思妙想，把骆驼草割下来，暴晒成干之后再磨成粉，作为面粉的代替品，和着面粉揉成骆驼草饼。尽管这饼口感苦涩，还不能多吃（吃多了会有生命危险），但是仍然救活了不老少人，很多人也因此认识了祖父。\r\n\r\n一转眼，十年晃了过去，祖父已经从10岁的小孩，长成了20岁的青年，有了自理生活的能力，这对于晚年得子的太爷爷，莫不过是一个极大的欣慰。不仅仅是祖父，小镇也成了小城——一抛以往的落后，从地上爬了起来，耸立着稀疏的高楼。这下太爷爷吃了大半生苦，终于有机会安享晚年了，只可惜冬季一天夜里，还在睡梦中的太爷爷不知为何，身子一直，双腿一蹬便归西了。等到第二天清晨，医生们接到电话，匆忙赶往太爷爷家时，太爷爷已经死去多时，后来查清楚死因是心脏病突发，这可叫人疑惑——家族里可从来没有得心脏病的啊！\r\n\r\n太爷爷下葬的那天，听说身子直挺挺的，像根柱子一样被扔进了家族的葬井里。祖父就站在井口边上，一动不动地向下看着太爷爷一点一点沉下去，脸上没有挂着任何悲伤的信号，但是凛冽的寒风却带走了祖父眼眶中残余的泪水。这是祖父第一次流泪，也是最后一次。\r\n\r\n太爷爷死后，祖父就接替太爷爷担负起了现在的老城区的规划和建设的任务——绿色逐渐在这片戈壁滩上蔓延开来。整齐的钢铁怪兽拔地而起，这使祖父更加声名远扬。家族里的人，也都以“罗恩·利尼斯”为榜样，在各行各业大显身手，这是家族的全盛时期。但是，这短暂的辉煌，只能截止到我的父亲出生。\r\n\r\n---\r\n\r\n我的父亲是祖母第四个儿子，也是最小的那一个，据说他在娘胎里时就身材颀长，对于身材矮小的长辈们来说，这简直是一个异类，一个屈辱。自然而然地，家族逐渐开始将父亲排除在外——起初在祖父决策时，父亲的建议不被理睬；在分配生活物资时，父亲得不到公正的待遇；而在祖父最后的分家中，父亲彻底丧失了作为一个儿子应得的财产，一个人默默行走在小城里，作为新的人种独自生活。为了能够顺利找到工作，他只好避开家族所涉及的行业，不想有所牵连。长时间在小城的地基徘徊，父亲终于在小城南边的正在开发的新城区，找到了属于他自己的职业，也就是作为一盏“路灯”——父亲颀长的身体，使他可以头顶着灯，照亮周身的一小片区域。在这片土地上，父亲也找到了许许多多像他一样，被家族抑或朋友所抛弃的，直立于大地上的“路灯”。每当夜幕降临，这些“路灯”就接连闪烁起光芒，但是尽管孩子们在灯下嬉戏，小狗在灯下侧卧休憩，工作了一天而疲惫的人们借助着灯光回到家中，却没有一个人对“路灯”表现出关心或同情，甚至没有一句简单的问候；而“路灯”似乎也不以为然，凭着逐渐硬化而变灰的身子，瞒过了几乎所有人，就连父亲的问好也异常冷漠。不过很可惜，父亲是一个人，这冷淡丝毫不会影响到父亲的心情。看起来，生活似乎步入了正轨，但在这幸福的时刻，父亲却听说了一个令人吃惊的消息——祖父去世了。\r\n\r\n下葬的那天，殡仪馆原本空旷的大厅里，摆满了五颜六色花圈和脸上挂着悲伤的人们，一下子显得金碧辉煌起来。大厅的正中央，不大的水晶棺里躺着矮小的祖父的遗体，家族的人们站在祖父两侧，议论着祖父的功绩。祖母站在棺材头，双手扶着棺材两侧，望着里面躺着的小小的人儿，泪水扑簌簌地往下掉；太奶奶则坐在一旁，一边安抚着祖母，一边叹息着聆听人们的言语。\r\n\r\n“可怜我的老父亲啊，声名远播也没能留住他自己……”大女儿罗恩·哈皮哀婉地用手遮住了脸。“如果父亲再多活一会儿，他就能得到更多的名誉了啊，只可惜……”长子罗恩·普莱森特向周身的人遗憾地摆了摆手，以表示自己内心的伤痛。葬礼的一切，都按照程序机械地推进着。\r\n\r\n---\r\n\r\n三挂鞭炮“噼里啪啦”胡乱一通地炸掉，空气中四处弥漫着蓝色而呛人的火药烟，家族的葬井也在烟灰中渐变模糊——祖父就要下井了。祖父众多的子女也如当年的祖父一般，注视而等待着僵直的祖父缓缓落入井中，这短短两分钟也仿佛凝固了，一秒，两秒……突然，人群中传来了莫名其妙的骚动，一个身材颀长，通体灰色的人气势汹汹闯入了墓地，原本拥挤的人们因为恐惧，纷纷向两边让道。就连井前的子女也瞪圆了眼睛，令他们没想到的是，父亲竟然来送葬了。\r\n\r\n高大的人影在移动到井前的一刻戛然而止，坚硬的双膝“扑通”一声重重地撞击在灰色的水泥地上，甚至敲出了微弱的火花，泪水不自觉的从父亲坚毅的脸颊流淌下来。这一切发生的如此突然，甚至连掌家的大儿子都不由得惊愕了一下，但作为家族的掌门人，他又很快清醒过来，对着跪在井前的父亲大声斥责：\r\n\r\n“滚！你这个不孝子，还有脸来见父亲，父亲之前有病的时候，你在哪？！赶紧给我滚，别再让我看见你！”\r\n\r\n两名看上去孔武有力的保安闻讯从门口赶来，见此情景，一边粗鲁地架起父亲的双臂，把他向外拖；一边连连给罗恩·普莱森特赔礼，说大少爷您受惊了。父亲看着罗恩·普莱森特蔑视般的撇嘴越来越远，自己的意识也随之越来越远。在父亲即将被拖出墓区的一刹那，他突然感觉手心被塞入了什么东西，侧头一看，只有太奶奶欲言又止的悲伤。飘回新城区，父亲借助着自己头顶微弱的灯光，手指一颤一颤地张开，手心里，是太奶奶给父亲留下的东西——一张皱巴巴纸条，上面歪歪曲曲地写着：\r\n\r\n“我们都是沉潜于水下的人。\r\n\r\n罗恩·利尼斯”\r\n\r\n这是祖父真正的，也是唯一的遗书。\r\n\r\n---\r\n\r\n从此以后，父亲就像变了一个人——不，准确来说不是一个人，而是更加专职——身体仿佛被浇灌了水泥，变得又灰又硬，表情也冷漠的一如旁边的“路灯”，不再乐观开朗——他成为了一盏真正的路灯。这样麻木的时间在灯光中蒸腾，在空气中摇曳，无声无息地窜上穹顶，却在我的母亲到来之时戛然而止。\r\n\r\n我的母亲是原来地主家的大小姐，但是却没有公主一般挑剔的毛病。那天夜里，她检查完外祖父在新城区的投资工作之后，沿着父亲所在的道路骑车回家。自行车飞速压过水泥地面，却在父亲的前面缓缓停了下来。\r\n\r\n“这是一个人。”深夜的街道上，这句话格外清晰。\r\n\r\n父亲的喉咙眼艰难地吐出低沉的吼声，似乎是想回应这个女人的话——我相信，当时除了母亲，再没有任何人感受到父亲的存在，这是第一个，也是唯一一个认出他的人。尽管身体变硬，五官已经半陷到身体里，父亲还是稍稍睁开了一只眼睛，观察这个身材高挑，秀色可餐的大小姐，而女人只是抬头，静静观察着这盏“路灯”。\r\n\r\n大小姐留了下来，不是因为爱上了他，或许只是想拯救这个人。\r\n\r\n---\r\n\r\n父亲开始抖落身体沾上的尘埃，努力想撑开浇筑在一起四肢，头顶的灯光也随着身体的晃动开始闪烁，这使得睡在一旁的大小姐也被惊醒，惊喜地望着父亲的变化——至少他作为一个人开始行动了。与之同时，新闻报道也铺天盖地而来，唤醒了人们对“路灯”们过去的回忆，三五成群的人们从远方赶来，只为在“路灯”下坐一坐，“路灯”的五官也从厚厚的尘埃中浮出来，显出从未有过的表情。\r\n\r\n每天晚上，大小姐结束了一天繁忙的工作之后，总会来到父亲身边安心地休息。一天，两天，一月，两月，日久生情，父亲爱上了大小姐，清晨因她去工作而失落，傍晚因她骑车归来而欣喜。父亲的身体也逐渐变矮，褪去了身上的灰色，露出了黄色的皮肤，虽然这些变化一一映在大小姐眼里，但是父亲并没有察觉，只是一心想着她。终于，在父亲的指尖露出黄色，外祖父工程竣工的那一天，他们俩结婚了。起初，在父亲向大小姐求婚的时候，外祖父是不同意的，因为他认为父亲什么也不会做，挣不到钱也养活不了自己，然而在见过父亲之后，外祖父却把最重要的女儿放心地交给了父亲，理由我也不太清楚，似乎是因为父亲看上去很坚硬。\r\n\r\n---\r\n\r\n父母结婚后一年，我就出生了。和父亲一样，我幼年就身材颀长，听父亲说出生前我还在母亲的肚子里大闹过一通，半夜里让母亲难受地翻来覆去，最后还是在父亲的安抚下，我才安静下来。出生之后，我不得不躺在娃娃车里，胳膊被架在车体外面，双脚则被固定在一个大概的范围。在我出生两天后，父母就轮换着开始了长远的教育大计——白天父亲负责哄我入睡，当朦胧的山脊线融入苍蓝的夜色时，母亲就结束工作回到父亲和我的身边，给我喂奶，唱歌：“遥远的夜空/有一个弯弯的月亮/弯弯的月亮下面/是那弯弯的小桥……”这样的轮班持续了一个星期，我就长的和父亲一样高，说话也俨然一副大人的模样——我的幼年时代就这样结束了。\r\n\r\n尽管如此，我的思维依然很幼稚，父母仍然每天教导我。但是，两个月后，一家三口的幸福生活被一场突如其来的车祸扯的支离破碎——母亲的自行车弯曲变形，浸没在母亲的鲜血中，不，不仅是自行车，整条大街都流淌着鲜红色的河流。这血液漫无目的地流淌，渗入了每一辆汽车的轮胎，渗入了每一座大楼的地基，也渗入了每一盏“路灯”脚底长年累月形成的伤口，这自然也包括父亲的。\r\n\r\n父亲干巴巴的眼睛，竟然湿润起来，喉咙眼里再一次挤出低沉的吼声，与上次不一样的是，略带血腥的风中夹杂的不仅仅是无尽的悲伤，还有对命运不公的控诉和愤慨。从这之后，父亲彻底沉默了，身体再一次硬化，身高却没有变化，一如祖父的矮小，这盏“路灯”，不再派上用场，仅仅只是作为一个摆设——父亲的冬天来了，他终究，还是没能躲过家族的命运。\r\n\r\n---\r\n\r\n为了找到工作，我开始像父亲曾经做过的那样，在小城的地基周围徘徊，狼一样寻找猎物。之所以不选择成为一盏“路灯”，是因为我一反父亲的踏实，天生就喜欢四处游荡，这不仅决定了我最终从事经商，而且也不可避免地决定了我与家族的会面，在我十岁那天，我决定踏入祖宅的大门，迎接长辈们的挑战。出人意料的是，长辈们已经不那么在意身材的颀长了（因为宅子里的孩子们长的越来越高，长辈们习以为常，反而将矮个的孩子认为是异类）。我很是失望，身体就像被掏空了，无头苍蝇一般失去了长期以来生存的意义和方向，既然一切都被妥协，那我鼓起这莫大的勇气又是为了什么呢？仿佛在迷雾中航行，我悻悻离开了祖宅。\r\n\r\n怀着怨恨，我一人走在深夜的大街上，一抬头，街角站着的，是打扮的异常妖娆的“接客的”。我二话不说，急行到那女的面前，那女的也只说了一句“这边走”，就缓缓把我带进了一个三回九转的小巷子里。来到巷子的最深处，柔和的红色的灯光从模糊的白色窗帘里溢出来，不时还能听到淫荡的声音从破旧的房子里传出来。那女的带我来到其中一间房，随意把门掩上就问我“你要啥样的服务？”\r\n\r\n突然，我开始害怕起来——在这红色灯光下，我惊奇地发现这女的竟然长的和母亲如此之像。此刻仿佛母亲浸在血里，却赤裸裸站在反光的地面上，面无表情地注视着我。我害怕极了，额头上渗出大滴大滴的汗珠，硬生生顺着耳边流下来，身子也不听使唤没命地颤抖。最后一瞬间，我的大脑脱离了对自己身体仅剩的控制，还没听清这女的又说了什么，就撇下三百元抱着头夺门而出，在漆黑的巷子里摸爬滚打，一味地逃离，逃离，直到精疲力竭，意识于小巷出口的青灰色地面上消失。\r\n\r\n---\r\n\r\n之后的三年，我开始在生意场上打拼，结识了不少朋友，可是再也没有回到小城——我担心在这里会再次遇到母亲，遇到祖祖辈辈们，再一次不得不忍受无尽的空虚和抱怨。这样的境况一直持续着，直到某一天，当我还在谈生意的时候，突然传来了噩耗——父亲去世了。听到这个，我才急忙赶回小城，布置父亲的葬礼。这是也是三年内，我第一次回到这里。\r\n\r\n看着陌生的徘徊在小城地基的年轻人，望着熟悉而老旧的街道，我的心脏竟然莫名其妙地抽搐了一下——是因为怀念起过去了吗？我无从知道，只是不知不觉地，就走进了殡仪馆。令我没想到的是，家族的人，童年时期认识的朋友，三年间一起在商场中战斗过的“战友”，竟然都聚集到了殡仪馆大厅，父亲在正中的水晶棺里静静地躺着，比起一位老人，他更像一个婴儿，一个乖巧的婴儿。\r\n\r\n五挂鞭炮“噼里啪啦”齐鸣，迷蒙的雨雾和蓝色的烟灰和在一起，模糊了人脸。父亲就和祖父与太爷爷一样，身体直挺挺的，即将落入井中。但本应无比悲伤的我，却突然想起了我这三年间认识的已经分了手的女友。在分手时，她接连问了我三个问题，而我却未能立即给出答案。\r\n\r\n“这地方比起你的故乡哪个更好一点？”\r\n\r\n“我和你的母亲相比，谁更贤惠一点？”\r\n\r\n“你能学学人家，活在现实之中吗？”\r\n\r\n清脆的唢呐声将我的意识拽了回来——父亲即将入水了。这是我第一次，看清井水的颜色，是血一样的红色。我恍然大悟，仿佛看见——不，不是仿佛，是真真切切看见在小城的地基之下，大陆之下，在深邃的血海里，身体坚硬的祖父，太爷爷，以及祖先们沉潜于水中，柱子一般用头支撑着一整座大陆，亘古不变。\r\n\r\n此时此刻，我才明白祖父的遗书——“我们都是沉潜于水下的人”。原来，我一直以为我已经摆脱了家族，但我错了，而且大错特错——我一直都与父亲同在，与家族同在，我的灵魂，一直都在水下长眠。这样想着，我凝视着鲜红色的井水缓慢地没过了父亲的头颅。\r\n\r\n我一直，都是沉潜于水下的人。\r\n\r\n于2016年8月29日', 'bodyText': '谨以此文献给我三年的战友，我信赖的朋友，我热爱的亲人，以及这片我生活了十八年的土地和在这座小城中努力生存的人们。今当远离，以后的日子，愿我们在深邃的星空中，留下自己灿烂的光辉。\n\n很久以前，我的祖先就被迫迁徙到这片荒芜的土地上，在这里养育后代，至少在我太奶奶的讲述下，祖祖辈辈开始了在这儿的生活。最初，祖先们是不愿意来到这里的，不仅因为原来的日子安逸祥和，更是因为这儿除了骆驼草和石头之外别无他物，但是，头头们觉得戈壁滩不远处的荒山里的矿石有开发的价值，就把祖先们抓到这儿做劳工，这地儿才有了灵气儿。后来，娃娃们从女人的肚子里钻出来，轻轻落到土里，伴着嗷嗷的哭声，戈壁滩也成了座小城。\n\n对于我的家族而言，我们是自豪的，因为至少我们曾分布在小城的各个角落，拥有大大小小的“领土”。在很长一段时间里，家族的成年人，作为小城的劳工，担负着水，电，食物等的供应和清洁任务。对于身材并不颀长的祖辈来说，这些任务并不简单。但是，家族的鼎盛时期，却也是这会儿，这一切，还得归功于我的祖父。\n\n我家族里的人都姓“罗恩”，至于为什么会有这样一个奇怪的姓，我曾经为此向我的叔叔打探过，叔叔也只是摇了摇头，转而去问了祖父。出乎意料的是，祖父竟然也不大清楚，只说这名字是祖辈们生下来就有的。既然连家族中最智慧的祖父都不知道的话，问其他人也只是徒劳而已，我也只能就此作罢。祖父的全名叫“罗恩·利尼斯”，其实，我的内心很疑惑——在那么落后和闭塞的时代，太爷爷是如何想出来这样一个洋气的名字。等到成年了，我也觉得这事儿无关紧要，渐渐就淡忘了。\n我的祖父，是罗恩家族公认的最伟大的人之一。在祖父还小的时候，小城里只有一点点面粉，对此，作为负责饮食的劳工，我的太爷爷很是发愁，“怎样才能弥补食物的空缺呢？”\n就在这节骨眼上，我的祖父奇思妙想，把骆驼草割下来，暴晒成干之后再磨成粉，作为面粉的代替品，和着面粉揉成骆驼草饼。尽管这饼口感苦涩，还不能多吃（吃多了会有生命危险），但是仍然救活了不老少人，很多人也因此认识了祖父。\n一转眼，十年晃了过去，祖父已经从10岁的小孩，长成了20岁的青年，有了自理生活的能力，这对于晚年得子的太爷爷，莫不过是一个极大的欣慰。不仅仅是祖父，小镇也成了小城——一抛以往的落后，从地上爬了起来，耸立着稀疏的高楼。这下太爷爷吃了大半生苦，终于有机会安享晚年了，只可惜冬季一天夜里，还在睡梦中的太爷爷不知为何，身子一直，双腿一蹬便归西了。等到第二天清晨，医生们接到电话，匆忙赶往太爷爷家时，太爷爷已经死去多时，后来查清楚死因是心脏病突发，这可叫人疑惑——家族里可从来没有得心脏病的啊！\n太爷爷下葬的那天，听说身子直挺挺的，像根柱子一样被扔进了家族的葬井里。祖父就站在井口边上，一动不动地向下看着太爷爷一点一点沉下去，脸上没有挂着任何悲伤的信号，但是凛冽的寒风却带走了祖父眼眶中残余的泪水。这是祖父第一次流泪，也是最后一次。\n太爷爷死后，祖父就接替太爷爷担负起了现在的老城区的规划和建设的任务——绿色逐渐在这片戈壁滩上蔓延开来。整齐的钢铁怪兽拔地而起，这使祖父更加声名远扬。家族里的人，也都以“罗恩·利尼斯”为榜样，在各行各业大显身手，这是家族的全盛时期。但是，这短暂的辉煌，只能截止到我的父亲出生。\n\n我的父亲是祖母第四个儿子，也是最小的那一个，据说他在娘胎里时就身材颀长，对于身材矮小的长辈们来说，这简直是一个异类，一个屈辱。自然而然地，家族逐渐开始将父亲排除在外——起初在祖父决策时，父亲的建议不被理睬；在分配生活物资时，父亲得不到公正的待遇；而在祖父最后的分家中，父亲彻底丧失了作为一个儿子应得的财产，一个人默默行走在小城里，作为新的人种独自生活。为了能够顺利找到工作，他只好避开家族所涉及的行业，不想有所牵连。长时间在小城的地基徘徊，父亲终于在小城南边的正在开发的新城区，找到了属于他自己的职业，也就是作为一盏“路灯”——父亲颀长的身体，使他可以头顶着灯，照亮周身的一小片区域。在这片土地上，父亲也找到了许许多多像他一样，被家族抑或朋友所抛弃的，直立于大地上的“路灯”。每当夜幕降临，这些“路灯”就接连闪烁起光芒，但是尽管孩子们在灯下嬉戏，小狗在灯下侧卧休憩，工作了一天而疲惫的人们借助着灯光回到家中，却没有一个人对“路灯”表现出关心或同情，甚至没有一句简单的问候；而“路灯”似乎也不以为然，凭着逐渐硬化而变灰的身子，瞒过了几乎所有人，就连父亲的问好也异常冷漠。不过很可惜，父亲是一个人，这冷淡丝毫不会影响到父亲的心情。看起来，生活似乎步入了正轨，但在这幸福的时刻，父亲却听说了一个令人吃惊的消息——祖父去世了。\n下葬的那天，殡仪馆原本空旷的大厅里，摆满了五颜六色花圈和脸上挂着悲伤的人们，一下子显得金碧辉煌起来。大厅的正中央，不大的水晶棺里躺着矮小的祖父的遗体，家族的人们站在祖父两侧，议论着祖父的功绩。祖母站在棺材头，双手扶着棺材两侧，望着里面躺着的小小的人儿，泪水扑簌簌地往下掉；太奶奶则坐在一旁，一边安抚着祖母，一边叹息着聆听人们的言语。\n“可怜我的老父亲啊，声名远播也没能留住他自己……”大女儿罗恩·哈皮哀婉地用手遮住了脸。“如果父亲再多活一会儿，他就能得到更多的名誉了啊，只可惜……”长子罗恩·普莱森特向周身的人遗憾地摆了摆手，以表示自己内心的伤痛。葬礼的一切，都按照程序机械地推进着。\n\n三挂鞭炮“噼里啪啦”胡乱一通地炸掉，空气中四处弥漫着蓝色而呛人的火药烟，家族的葬井也在烟灰中渐变模糊——祖父就要下井了。祖父众多的子女也如当年的祖父一般，注视而等待着僵直的祖父缓缓落入井中，这短短两分钟也仿佛凝固了，一秒，两秒……突然，人群中传来了莫名其妙的骚动，一个身材颀长，通体灰色的人气势汹汹闯入了墓地，原本拥挤的人们因为恐惧，纷纷向两边让道。就连井前的子女也瞪圆了眼睛，令他们没想到的是，父亲竟然来送葬了。\n高大的人影在移动到井前的一刻戛然而止，坚硬的双膝“扑通”一声重重地撞击在灰色的水泥地上，甚至敲出了微弱的火花，泪水不自觉的从父亲坚毅的脸颊流淌下来。这一切发生的如此突然，甚至连掌家的大儿子都不由得惊愕了一下，但作为家族的掌门人，他又很快清醒过来，对着跪在井前的父亲大声斥责：\n“滚！你这个不孝子，还有脸来见父亲，父亲之前有病的时候，你在哪？！赶紧给我滚，别再让我看见你！”\n两名看上去孔武有力的保安闻讯从门口赶来，见此情景，一边粗鲁地架起父亲的双臂，把他向外拖；一边连连给罗恩·普莱森特赔礼，说大少爷您受惊了。父亲看着罗恩·普莱森特蔑视般的撇嘴越来越远，自己的意识也随之越来越远。在父亲即将被拖出墓区的一刹那，他突然感觉手心被塞入了什么东西，侧头一看，只有太奶奶欲言又止的悲伤。飘回新城区，父亲借助着自己头顶微弱的灯光，手指一颤一颤地张开，手心里，是太奶奶给父亲留下的东西——一张皱巴巴纸条，上面歪歪曲曲地写着：\n“我们都是沉潜于水下的人。\n罗恩·利尼斯”\n这是祖父真正的，也是唯一的遗书。\n\n从此以后，父亲就像变了一个人——不，准确来说不是一个人，而是更加专职——身体仿佛被浇灌了水泥，变得又灰又硬，表情也冷漠的一如旁边的“路灯”，不再乐观开朗——他成为了一盏真正的路灯。这样麻木的时间在灯光中蒸腾，在空气中摇曳，无声无息地窜上穹顶，却在我的母亲到来之时戛然而止。\n我的母亲是原来地主家的大小姐，但是却没有公主一般挑剔的毛病。那天夜里，她检查完外祖父在新城区的投资工作之后，沿着父亲所在的道路骑车回家。自行车飞速压过水泥地面，却在父亲的前面缓缓停了下来。\n“这是一个人。”深夜的街道上，这句话格外清晰。\n父亲的喉咙眼艰难地吐出低沉的吼声，似乎是想回应这个女人的话——我相信，当时除了母亲，再没有任何人感受到父亲的存在，这是第一个，也是唯一一个认出他的人。尽管身体变硬，五官已经半陷到身体里，父亲还是稍稍睁开了一只眼睛，观察这个身材高挑，秀色可餐的大小姐，而女人只是抬头，静静观察着这盏“路灯”。\n大小姐留了下来，不是因为爱上了他，或许只是想拯救这个人。\n\n父亲开始抖落身体沾上的尘埃，努力想撑开浇筑在一起四肢，头顶的灯光也随着身体的晃动开始闪烁，这使得睡在一旁的大小姐也被惊醒，惊喜地望着父亲的变化——至少他作为一个人开始行动了。与之同时，新闻报道也铺天盖地而来，唤醒了人们对“路灯”们过去的回忆，三五成群的人们从远方赶来，只为在“路灯”下坐一坐，“路灯”的五官也从厚厚的尘埃中浮出来，显出从未有过的表情。\n每天晚上，大小姐结束了一天繁忙的工作之后，总会来到父亲身边安心地休息。一天，两天，一月，两月，日久生情，父亲爱上了大小姐，清晨因她去工作而失落，傍晚因她骑车归来而欣喜。父亲的身体也逐渐变矮，褪去了身上的灰色，露出了黄色的皮肤，虽然这些变化一一映在大小姐眼里，但是父亲并没有察觉，只是一心想着她。终于，在父亲的指尖露出黄色，外祖父工程竣工的那一天，他们俩结婚了。起初，在父亲向大小姐求婚的时候，外祖父是不同意的，因为他认为父亲什么也不会做，挣不到钱也养活不了自己，然而在见过父亲之后，外祖父却把最重要的女儿放心地交给了父亲，理由我也不太清楚，似乎是因为父亲看上去很坚硬。\n\n父母结婚后一年，我就出生了。和父亲一样，我幼年就身材颀长，听父亲说出生前我还在母亲的肚子里大闹过一通，半夜里让母亲难受地翻来覆去，最后还是在父亲的安抚下，我才安静下来。出生之后，我不得不躺在娃娃车里，胳膊被架在车体外面，双脚则被固定在一个大概的范围。在我出生两天后，父母就轮换着开始了长远的教育大计——白天父亲负责哄我入睡，当朦胧的山脊线融入苍蓝的夜色时，母亲就结束工作回到父亲和我的身边，给我喂奶，唱歌：“遥远的夜空/有一个弯弯的月亮/弯弯的月亮下面/是那弯弯的小桥……”这样的轮班持续了一个星期，我就长的和父亲一样高，说话也俨然一副大人的模样——我的幼年时代就这样结束了。\n尽管如此，我的思维依然很幼稚，父母仍然每天教导我。但是，两个月后，一家三口的幸福生活被一场突如其来的车祸扯的支离破碎——母亲的自行车弯曲变形，浸没在母亲的鲜血中，不，不仅是自行车，整条大街都流淌着鲜红色的河流。这血液漫无目的地流淌，渗入了每一辆汽车的轮胎，渗入了每一座大楼的地基，也渗入了每一盏“路灯”脚底长年累月形成的伤口，这自然也包括父亲的。\n父亲干巴巴的眼睛，竟然湿润起来，喉咙眼里再一次挤出低沉的吼声，与上次不一样的是，略带血腥的风中夹杂的不仅仅是无尽的悲伤，还有对命运不公的控诉和愤慨。从这之后，父亲彻底沉默了，身体再一次硬化，身高却没有变化，一如祖父的矮小，这盏“路灯”，不再派上用场，仅仅只是作为一个摆设——父亲的冬天来了，他终究，还是没能躲过家族的命运。\n\n为了找到工作，我开始像父亲曾经做过的那样，在小城的地基周围徘徊，狼一样寻找猎物。之所以不选择成为一盏“路灯”，是因为我一反父亲的踏实，天生就喜欢四处游荡，这不仅决定了我最终从事经商，而且也不可避免地决定了我与家族的会面，在我十岁那天，我决定踏入祖宅的大门，迎接长辈们的挑战。出人意料的是，长辈们已经不那么在意身材的颀长了（因为宅子里的孩子们长的越来越高，长辈们习以为常，反而将矮个的孩子认为是异类）。我很是失望，身体就像被掏空了，无头苍蝇一般失去了长期以来生存的意义和方向，既然一切都被妥协，那我鼓起这莫大的勇气又是为了什么呢？仿佛在迷雾中航行，我悻悻离开了祖宅。\n怀着怨恨，我一人走在深夜的大街上，一抬头，街角站着的，是打扮的异常妖娆的“接客的”。我二话不说，急行到那女的面前，那女的也只说了一句“这边走”，就缓缓把我带进了一个三回九转的小巷子里。来到巷子的最深处，柔和的红色的灯光从模糊的白色窗帘里溢出来，不时还能听到淫荡的声音从破旧的房子里传出来。那女的带我来到其中一间房，随意把门掩上就问我“你要啥样的服务？”\n突然，我开始害怕起来——在这红色灯光下，我惊奇地发现这女的竟然长的和母亲如此之像。此刻仿佛母亲浸在血里，却赤裸裸站在反光的地面上，面无表情地注视着我。我害怕极了，额头上渗出大滴大滴的汗珠，硬生生顺着耳边流下来，身子也不听使唤没命地颤抖。最后一瞬间，我的大脑脱离了对自己身体仅剩的控制，还没听清这女的又说了什么，就撇下三百元抱着头夺门而出，在漆黑的巷子里摸爬滚打，一味地逃离，逃离，直到精疲力竭，意识于小巷出口的青灰色地面上消失。\n\n之后的三年，我开始在生意场上打拼，结识了不少朋友，可是再也没有回到小城——我担心在这里会再次遇到母亲，遇到祖祖辈辈们，再一次不得不忍受无尽的空虚和抱怨。这样的境况一直持续着，直到某一天，当我还在谈生意的时候，突然传来了噩耗——父亲去世了。听到这个，我才急忙赶回小城，布置父亲的葬礼。这是也是三年内，我第一次回到这里。\n看着陌生的徘徊在小城地基的年轻人，望着熟悉而老旧的街道，我的心脏竟然莫名其妙地抽搐了一下——是因为怀念起过去了吗？我无从知道，只是不知不觉地，就走进了殡仪馆。令我没想到的是，家族的人，童年时期认识的朋友，三年间一起在商场中战斗过的“战友”，竟然都聚集到了殡仪馆大厅，父亲在正中的水晶棺里静静地躺着，比起一位老人，他更像一个婴儿，一个乖巧的婴儿。\n五挂鞭炮“噼里啪啦”齐鸣，迷蒙的雨雾和蓝色的烟灰和在一起，模糊了人脸。父亲就和祖父与太爷爷一样，身体直挺挺的，即将落入井中。但本应无比悲伤的我，却突然想起了我这三年间认识的已经分了手的女友。在分手时，她接连问了我三个问题，而我却未能立即给出答案。\n“这地方比起你的故乡哪个更好一点？”\n“我和你的母亲相比，谁更贤惠一点？”\n“你能学学人家，活在现实之中吗？”\n清脆的唢呐声将我的意识拽了回来——父亲即将入水了。这是我第一次，看清井水的颜色，是血一样的红色。我恍然大悟，仿佛看见——不，不是仿佛，是真真切切看见在小城的地基之下，大陆之下，在深邃的血海里，身体坚硬的祖父，太爷爷，以及祖先们沉潜于水中，柱子一般用头支撑着一整座大陆，亘古不变。\n此时此刻，我才明白祖父的遗书——“我们都是沉潜于水下的人”。原来，我一直以为我已经摆脱了家族，但我错了，而且大错特错——我一直都与父亲同在，与家族同在，我的灵魂，一直都在水下长眠。这样想着，我凝视着鲜红色的井水缓慢地没过了父亲的头颅。\n我一直，都是沉潜于水下的人。\n于2016年8月29日', 'author': {'login': 'jygzyc'}, 'category': {'name': '0301-文章'}, 'labels': {'nodes': []}, 'comments': {'nodes': []}}, {'title': 'Android源码编译', 'number': 4, 'url': 'https://github.com/jygzyc/notes/discussions/4', 'createdAt': '2024-04-19T02:15:04Z', 'lastEditedAt': '2024-05-15T06:45:11Z', 'updatedAt': '2024-05-15T06:45:11Z', 'body': '<!-- android_source_compile -->\r\n编译Android系统的时候遇到了环境不同，稳定性不同的问题，选择docker解决问题\r\n\r\n> 以编译Google Pixel 3，lineageOS 21.0为例\r\n\r\n## 下载源码\r\n\r\n第一步，安装repo\r\n\r\n```bash\r\nmkdir ~/bin\r\nPATH=~/bin:$PATH\r\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\r\nchmod a+x ~/bin/repo\r\n```\r\n\r\n第二步，配置git\r\n\r\n```bash\r\ngit config --global user.email "you@example.com"\r\ngit config --global user.name "Your Name"\r\n```\r\n\r\n由于其大小，一些存储库配置为 lfs 或大文件存储，需要安装git-lfs：\r\n\r\n```bash\r\ngit lfs install # apt install git-lfs\r\n```\r\n\r\n第三步，初始化LineageOS存储库\r\n\r\n```bash\r\nrepo init -u https://github.com/LineageOS/android.git -b lineage-21.0 --git-lfs\r\n```\r\n\r\n第四步，同步源码并准备，这里可以先参考[清华lineageOS 源代码镜像使用帮助](https://mirrors.tuna.tsinghua.edu.cn/help/lineageOS/)，先使用清华源同步，但是最后还是需要切回github同步一下，不然指定机型编译后会报错\r\n\r\n```bash\r\nrepo sync\r\n\r\n# after finished\r\nsource build/envsetup.sh\r\nbreakfast blueline\r\n```\r\n\r\n第五步，同步设备特定固件代码\r\n\r\n方法一，先刷机再执行`device/google/blueline`目录下的`./extract-files.sh`\r\n\r\n方法二，从OTA包中获取固件，此处可以参考 [Extracting proprietary blobs from LineageOS zip files](https://wiki.lineageos.org/extracting_blobs_from_zips)\r\n\r\n## docker安装\r\n\r\n由于我需要对制作好的image进行上传，所以这里就采用官方源进行安装了\r\n\r\n```bash\r\n$ curl -fsSL get.docker.com -o get-docker.sh\r\n```\r\n\r\n执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。\r\n\r\n之后我们启动docker\r\n\r\n```bash\r\n$ sudo systemctl enable docker\r\n$ sudo systemctl start docker\r\n```\r\n\r\n默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组，或者安装rootless的docker\r\n\r\n```bash\r\n$ sudo groupadd docker\r\n$ sudo usermod -aG docker $USER\r\n# 或者使用脚本变为rootless模式\r\n$ dockerd-rootless.sh\r\n```\r\n\r\n新建终端测试\r\n\r\n```bash\r\n$ docker run --rm hello-world\r\nUnable to find image \'hello-world:latest\' locally\r\nlatest: Pulling from library/hello-world\r\n719385e32844: Pull complete \r\nDigest: sha256:dcba6daec718f547568c562956fa47e1b03673dd010fe6ee58ca806767031d1c\r\nStatus: Downloaded newer image for hello-world:latest\r\n\r\nHello from Docker!\r\nThis message shows that your installation appears to be working correctly.\r\n\r\nTo generate this message, Docker took the following steps:\r\n 1. The Docker client contacted the Docker daemon.\r\n 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.\r\n    (amd64)\r\n 3. The Docker daemon created a new container from that image which runs the\r\n    executable that produces the output you are currently reading.\r\n 4. The Docker daemon streamed that output to the Docker client, which sent it\r\n    to your terminal.\r\n\r\nTo try something more ambitious, you can run an Ubuntu container with:\r\n $ docker run -it ubuntu bash\r\n\r\nShare images, automate workflows, and more with a free Docker ID:\r\n https://hub.docker.com/\r\n\r\nFor more examples and ideas, visit:\r\n https://docs.docker.com/get-started/\r\n```\r\n\r\n## 定制镜像\r\n\r\n`Dockerfile`文件如下\r\n\r\n```dockerfile\r\nFROM ubuntu:22.04\r\n\r\n# Modify the sources.list for improving download speed \r\nRUN sed -i \'s@//.*archive.ubuntu.com@//mirrors.ustc.edu.cn@g\' /etc/apt/sources.list\r\n\r\n# Create environment\r\nENV DEBIAN_FRONTEND noninteractive\r\nRUN apt-get -qq update\r\nRUN apt-get -y install bc bison build-essential ccache cpio curl flex g++-multilib gcc-multilib \r\nRUN apt-get -y install git git-lfs gnupg gperf imagemagick libc6-dev libelf-dev libgl1-mesa-dev liblz4-tool\r\nRUN apt-get -y install libncurses5 libncurses5-dev libsdl1.2-dev libssl-dev libx11-dev libxml2 libxml2-utils \r\nRUN apt-get -y install lzop lzip m4 make ncurses-dev patch pngcrush python3 python3-pip rsync schedtool \r\nRUN apt-get -y install squashfs-tools unzip x11proto-core-dev xsltproc zip zlib1g-dev openjdk-11-jdk\r\nRUN ln -s /usr/bin/python3 /usr/bin/python\r\n\r\n# Install repo\r\nRUN curl https://storage.googleapis.com/git-repo-downloads/repo > /usr/bin/repo\r\n\r\n# Turn on caching\r\nENV USE_CCACHE 1\r\nENV CCACHE_EXEC /usr/bin/ccache\r\nENV CCACHE_DIR=/ccache\r\nRUN ccache -M 50G\r\n\r\n# Mount source code directory\r\nVOLUME /source\r\nENV WORKDIR /source\r\nWORKDIR $WORKDIR\r\n```\r\n\r\n`docker-compose.yml`配置如下\r\n\r\n```yml\r\nversion: "3"\r\nservices:\r\n  android_builder:\r\n    build: .\r\n    command: /bin/bash\r\n    tty: true\r\n    stdin_open: true\r\n    volumes:\r\n      - /home/${USER}/android/lineage/:/source # SourceCode Directory\r\n      - /home/${USER}/.ccache:/ccache # ccache directory\r\n```\r\n\r\n在执行前先配置好`ccache`的目录和源码目录，再使用``docker compose run --rm android_builder bash`启动\r\n\r\n> 整理了一个项目 [PersonalDocker](https://github.com/jygzyc/PersonalDocker/)\r\n\r\n## 执行编译\r\n\r\n```bash\r\nsource build/envsetup.sh\r\nbreakfast blueline # 若编译user系统，则执行 breakfast blueline user，下同\r\n\r\nbrunch blueline\r\n```\r\n\r\n## 参考文献\r\n\r\n- [Docker - 从入门到实践](https://yeasy.gitbook.io/docker_practice)\r\n- [Build LineageOS for Google Pixel 3](https://wiki.lineageos.org/devices/blueline/build)\r\n', 'bodyText': '编译Android系统的时候遇到了环境不同，稳定性不同的问题，选择docker解决问题\n\n以编译Google Pixel 3，lineageOS 21.0为例\n\n下载源码\n第一步，安装repo\nmkdir ~/bin\nPATH=~/bin:$PATH\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\nchmod a+x ~/bin/repo\n第二步，配置git\ngit config --global user.email "you@example.com"\ngit config --global user.name "Your Name"\n由于其大小，一些存储库配置为 lfs 或大文件存储，需要安装git-lfs：\ngit lfs install # apt install git-lfs\n第三步，初始化LineageOS存储库\nrepo init -u https://github.com/LineageOS/android.git -b lineage-21.0 --git-lfs\n第四步，同步源码并准备，这里可以先参考清华lineageOS 源代码镜像使用帮助，先使用清华源同步，但是最后还是需要切回github同步一下，不然指定机型编译后会报错\nrepo sync\n\n# after finished\nsource build/envsetup.sh\nbreakfast blueline\n第五步，同步设备特定固件代码\n方法一，先刷机再执行device/google/blueline目录下的./extract-files.sh\n方法二，从OTA包中获取固件，此处可以参考 Extracting proprietary blobs from LineageOS zip files\ndocker安装\n由于我需要对制作好的image进行上传，所以这里就采用官方源进行安装了\n$ curl -fsSL get.docker.com -o get-docker.sh\n执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。\n之后我们启动docker\n$ sudo systemctl enable docker\n$ sudo systemctl start docker\n默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组，或者安装rootless的docker\n$ sudo groupadd docker\n$ sudo usermod -aG docker $USER\n# 或者使用脚本变为rootless模式\n$ dockerd-rootless.sh\n新建终端测试\n$ docker run --rm hello-world\nUnable to find image \'hello-world:latest\' locally\nlatest: Pulling from library/hello-world\n719385e32844: Pull complete \nDigest: sha256:dcba6daec718f547568c562956fa47e1b03673dd010fe6ee58ca806767031d1c\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n定制镜像\nDockerfile文件如下\nFROM ubuntu:22.04\n\n# Modify the sources.list for improving download speed \nRUN sed -i \'s@//.*archive.ubuntu.com@//mirrors.ustc.edu.cn@g\' /etc/apt/sources.list\n\n# Create environment\nENV DEBIAN_FRONTEND noninteractive\nRUN apt-get -qq update\nRUN apt-get -y install bc bison build-essential ccache cpio curl flex g++-multilib gcc-multilib \nRUN apt-get -y install git git-lfs gnupg gperf imagemagick libc6-dev libelf-dev libgl1-mesa-dev liblz4-tool\nRUN apt-get -y install libncurses5 libncurses5-dev libsdl1.2-dev libssl-dev libx11-dev libxml2 libxml2-utils \nRUN apt-get -y install lzop lzip m4 make ncurses-dev patch pngcrush python3 python3-pip rsync schedtool \nRUN apt-get -y install squashfs-tools unzip x11proto-core-dev xsltproc zip zlib1g-dev openjdk-11-jdk\nRUN ln -s /usr/bin/python3 /usr/bin/python\n\n# Install repo\nRUN curl https://storage.googleapis.com/git-repo-downloads/repo > /usr/bin/repo\n\n# Turn on caching\nENV USE_CCACHE 1\nENV CCACHE_EXEC /usr/bin/ccache\nENV CCACHE_DIR=/ccache\nRUN ccache -M 50G\n\n# Mount source code directory\nVOLUME /source\nENV WORKDIR /source\nWORKDIR $WORKDIR\ndocker-compose.yml配置如下\nversion: "3"\nservices:\n  android_builder:\n    build: .\n    command: /bin/bash\n    tty: true\n    stdin_open: true\n    volumes:\n      - /home/${USER}/android/lineage/:/source # SourceCode Directory\n      - /home/${USER}/.ccache:/ccache # ccache directory\n在执行前先配置好ccache的目录和源码目录，再使用``docker compose run --rm android_builder bash`启动\n\n整理了一个项目 PersonalDocker\n\n执行编译\nsource build/envsetup.sh\nbreakfast blueline # 若编译user系统，则执行 breakfast blueline user，下同\n\nbrunch blueline\n参考文献\n\nDocker - 从入门到实践\nBuild LineageOS for Google Pixel 3', 'author': {'login': 'jygzyc'}, 'category': {'name': '0101-Android'}, 'labels': {'nodes': [{'name': '010101-ROM定制'}]}, 'comments': {'nodes': []}}]}