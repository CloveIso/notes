{'date': '2024-05-27 16:06:45', 'nodes': [{'title': 'Android逆向中的字符串加密和反混淆', 'number': 12, 'url': 'https://github.com/jygzyc/notes/discussions/12', 'createdAt': '2024-05-27T03:58:04Z', 'lastEditedAt': '2024-05-27T06:43:57Z', 'updatedAt': '2024-05-27T06:43:57Z', 'body': '<!-- string_decryption_in_android_reverse_engineering -->\r\n\r\n## 字符串加密概述\r\n\r\n目前，主流的App上都有了字符串的加密和混淆，这对于逆向和安全检测来说，无疑是加大了难度；同时，对于恶意应用来说，也方便了他们隐藏真实的意图。针对这种情况，写了一个小工具抛砖引玉解决这类问题\r\n\r\n<!-- more -->\r\n\r\n以某网站上的著名项目`StringFog`为例，这是一款自动对dex/aar/jar文件中的字符串进行加密Android插件工具，其工作如下所示\r\n\r\n![img](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/string_decryption_in_android_reverse_engineering-2024-05-27-14-38-00.png)\r\n\r\n`StringFog`实现的原理实际上非常简单，就是在字节码层面进行替换，但是却能给逆向分析增加较大的时间成本，并且，除了`StringFog`，市面上也存在很多自定义加密字符串的方案，这类方案往往和混淆结合在一起，就如同逆向时的鸡肋一般，让安全研究人员食之无味，弃之可惜。\r\n\r\n## 案例一：某dex\r\n\r\n通过`jadx`加载某dex文件时，会发现文件中存在很多的加密字符串，这样的加密很影响分析的效率，那么我们怎么去除它呢？在最新版本的`jadx`中，开发者引入了一个全新的功能——`jadx-script`。通过`jadx-script`，我们能够在`jadx`中执行kotlin script，而相关的例子，也放在`jadx-plugins/jadx-script/examples/scripts`中，下面会介绍到。\r\n\r\n![string_decryption_in_android_reverse_engineering-2024-05-27-14-38-01](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/string_decryption_in_android_reverse_engineering-2024-05-27-14-38-01.png)\r\n\r\n跟踪这个解密的函数，能看到解密的逻辑并不复杂，完全能够直接复现，那么我们期望的效果，肯定是在静态分析时直接看到解密后的结果，下面我们就来看看怎么达到这个效果。事实上，我们可以编写一个算法还原的脚本并交给最新的`jadx`去执行\r\n\r\n![](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/string_decryption_in_android_reverse_engineering-2024-05-27-14-38-02.png)\r\n\r\n```kotlin\r\n/**\r\n * Replace method call with calculated result.\r\n * Useful for custom string deobfuscation.\r\n *\r\n * Example for sample from issue https://github.com/skylot/jadx/issues/1251\r\n */\r\n\r\nimport jadx.core.dex.instructions.ConstStringNode\r\nimport jadx.core.dex.instructions.InvokeNode\r\nimport jadx.core.dex.instructions.args.InsnArg\r\nimport jadx.core.dex.instructions.args.InsnWrapArg\r\nimport jadx.core.dex.instructions.args.RegisterArg\r\n\r\n\r\nval jadx = getJadxInstance()\r\n\r\nval mthSignature = "com.xshield.aa.iIiIiiiiII(Ljava/lang/String;)Ljava/lang/String;"\r\n\r\njadx.replace.insns { mth, insn ->\r\n\tif (insn is InvokeNode && insn.callMth.rawFullId == mthSignature) {\r\n\t\tval str = getConstStr(insn.getArg(0))\r\n\t\tif (str != null) {\r\n\t\t\tval resultStr = decode(str)\r\n\t\t\tlog.info { "Decode \'$str\' to \'$resultStr\' in $mth" }\r\n\t\t\treturn@insns ConstStringNode(resultStr)\r\n\t\t}\r\n\t}\r\n\tnull\r\n}\r\n\r\nfun getConstStr(arg: InsnArg): String? {\r\n\tval insn = when (arg) {\r\n\t\tis InsnWrapArg -> arg.wrapInsn\r\n\t\tis RegisterArg -> arg.assignInsn\r\n\t\telse -> null\r\n\t}\r\n\tif (insn is ConstStringNode) {\r\n\t\treturn insn.string\r\n\t}\r\n\treturn null\r\n}\r\n\r\n/**\r\n * Decompiled method, automatically converted to Kotlin by IntelliJ Idea\r\n */\r\nfun decode(str: String): String {\r\n\tval length = str.length\r\n\tval cArr = CharArray(length)\r\n\tvar i = length - 1\r\n\twhile (i >= 0) {\r\n\t\tval i2 = i - 1\r\n\t\tcArr[i] = (str[i].code xor \'z\'.code).toChar()\r\n\t\tif (i2 < 0) {\r\n\t\t\tbreak\r\n\t\t}\r\n\t\ti = i2 - 1\r\n\t\tcArr[i2] = (str[i2].code xor \'\\u000c\'.code).toChar()\r\n\t}\r\n\treturn String(cArr)\r\n}\r\n```\r\n\r\n上面的代码中，已经复现了解密的算法，接下来就是加载脚本了，在GUI中选择`replace_method_call.jadx.kts`，打开\r\n\r\n![](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/string_decryption_in_android_reverse_engineering-2024-05-27-14-38-03.png)\r\n\r\n执行脚本，会遍历每一个方法节点，当签名相符时，会替换为解密后的结果\r\n\r\n![](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/string_decryption_in_android_reverse_engineering-2024-05-27-14-38-04.png)\r\n\r\n这样的话，我们就可以继续正常逆向分析了\r\n\r\n## 案例二：某Demo APK\r\n\r\n通过上面的案例，我们发现可以通过逆向的手段还原算法，但是如果碰到不能够还原的加密方法，是不是就无法解密了呢？其实不然，因为我们还有`Frida`或者`unidbg`，这两者在函数的主动调用上都是一把好手，具体的对比如下表所示\r\n\r\n|        | Java层函数调用 | Native层函数调用 | 稳定性 |\r\n| ------ | -------------- | ---------------- | ------ |\r\n| Frida  | 可以           | 可以             | 不稳定 |\r\n| unidbg | 不可以         | 可以             | 稳定   |\r\n\r\n我们可以根据各自的特性选择主动调用的工具，这里先看一个`Demo`案例，以`androidx.core.utils.CommenUtils$Companion.a`函数为例\r\n\r\n![](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/string_decryption_in_android_reverse_engineering-2024-05-27-14-38-05.png)\r\n\r\n通过上图，我们能明显看到关键字符串均采用了加密，那么看一下加密函数`C3632qz.b`的实现\r\n\r\n![](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/string_decryption_in_android_reverse_engineering-2024-05-27-14-38-06.png)\r\n\r\n发现这里实际上是Base64的解密，当然，我们可以在脚本中实现Base64的解密算法，不过这里也可以采用另一种方式解决，那就是直接hook `C3632qz.b`函数，进而主动调用返回结果，具体怎么操作呢？上代码\r\n\r\n```kotlin\r\n// That is the path relative to the jadx/bin execution directory, or it can be changed to an absolute path.\r\n@file:DependsOn("../external_library/okhttp-4.11.0.jar")\r\n@file:DependsOn("../external_library/okio-jvm-3.2.0.jar")\r\n@file:DependsOn("../external_library/okio-3.2.0.jar")\r\n\r\nimport okhttp3.MediaType.Companion.toMediaType\r\nimport okhttp3.OkHttpClient\r\nimport okhttp3.Request\r\nimport okhttp3.RequestBody.Companion.toRequestBody\r\nimport okhttp3.Response\r\n\r\nimport jadx.core.dex.instructions.ConstStringNode\r\nimport jadx.core.dex.instructions.InvokeNode\r\nimport jadx.core.dex.instructions.args.InsnArg\r\nimport jadx.core.dex.instructions.args.InsnWrapArg\r\nimport jadx.core.dex.instructions.args.RegisterArg\r\n\r\nval jadx = getJadxInstance()\r\n\r\nval mthSignature_qzb = "kotlinx.android.extensionss.qz.b(Ljava/lang/String;)Ljava/lang/String;"\r\n\r\njadx.replace.insns { mth, insn ->\r\n\tif (insn is InvokeNode && insn.callMth.rawFullId == mthSignature_qzb) {\r\n\t\tval str = getConstStr(insn.getArg(0))\r\n\t\tif (str != null) {\r\n\t\t\tval resultStr = decrypt(mthSignature_qzb, str)\r\n\t\t\tlog.info { "Decrypt \'$str\' to \'$resultStr\' in $mth" }\r\n\t\t\treturn@insns ConstStringNode(resultStr)\r\n\t\t}\r\n\t}\r\n\tnull\r\n}\r\nfun getConstStr(arg: InsnArg): String? {\r\n\tval insn = when (arg) {\r\n\t\tis InsnWrapArg -> arg.wrapInsn\r\n\t\tis RegisterArg -> arg.assignInsn\r\n\t\telse -> null\r\n\t}\r\n\tif (insn is ConstStringNode) {\r\n\t\treturn insn.string\r\n\t}\r\n\treturn null\r\n}\r\n// rpc 解密函数\r\nfun decrypt(mthSignature: String, param: String): String?{\r\n\tval client = OkHttpClient()\r\n    val json = """\r\n        {\r\n            "method": "${mthSignature}",\r\n\t\t\t"param": "${param}"\r\n        }\r\n    """.trimIndent()\r\n\r\n\tval requestBody = json.toRequestBody("application/json; charset=utf-8".toMediaType())\r\n\r\n\tval request = Request.Builder()\r\n        .url("http://127.0.0.1:5000/decrypt")\r\n        .post(requestBody)\r\n        .build()\r\n\r\n    val response = client.newCall(request).execute()\r\n\treturn response.body?.string().toString()\r\n}\r\n```\r\n\r\n能够发现，其实脚本的主体结构并没有太大的变化，但是在核心的`decrypt`函数上，使用了`OkHttp`发送请求，并接受返回的数据，即是将`jadx`作为了客户端。既然有客户端，那么也得有服务端，如下所示\r\n\r\n```python\r\n# ...\r\napp = Flask(__name__)\r\nlogger = Logger(log_level="INFO")\r\n\r\ndef message(message, data):\r\n    if message[\'type\'] == \'send\':\r\n        logger.debug(f"[*] {message[\'payload\']}")\r\n    else:\r\n        logger.debug(message)\r\n\r\n@app.route(\'/decrypt\', methods=[\'POST\'])#data解密\r\ndef decrypt_class():\r\n    data = request.get_data()\r\n    json_data = json.loads(data.decode("utf-8"))\r\n    logger.info(json_data)\r\n    method_sig = json_data.get("method")\r\n    method_param = handle_params(json_data.get("param"))\r\n    logger.debug(f"method: ${method_sig}; params: ${method_param}") \r\n    handle_method = globals()[methods[method_sig]]\r\n    res = _process_string(handle_method(method_sig, method_param))\r\n    response = make_response(res, 200)\r\n    response.headers[\'Content-Type\'] = \'application/json\'\r\n    return response\r\n\r\ndef _process_string(s: str) -> str:\r\n    s = \' \'.join(s.split())\r\n    s = re.sub(r\'\\s+\', \' \', s)\r\n    if len(s) > 0 and s[0] == \' \':\r\n        s = \' \' + s.lstrip()\r\n    if len(s) > 0 and s[-1] == \' \':\r\n        s = s.rstrip() + \' \'\r\n    return s\r\n\r\ndef handle_params(params):\r\n    return params\r\n\r\n#################### Method Handler ####################\r\n\r\ndef _handle_qz_b(method_name, method_param):\r\n    res = _process_string(script.exports_sync.invokemethod01(method_param))\r\n    logger.info(f"{method_param} => {res}")\r\n    return res\r\n\r\ndef _handle_cg_b(method_name, method_param):\r\n    res = _process_string(script.exports_sync.invokemethod02(method_param))\r\n    logger.info(f"{method_param} => {res}")\r\n    return res\r\n\r\n#################### Flask Server ####################\r\n\r\nconfig = Config.builder()\r\nmethods = config.methods_map\r\n\r\ndevice = frida.get_device_manager().add_remote_device(config.remote_device)\r\nif(config.spawn):\r\n    session = device.spawn(config.package_name)\r\nelse:\r\n    session = device.attach(config.app_name)\r\n\r\nwith open(os.path.join(os.path.dirname(os.path.abspath(__file__)), "scripts", config.frida_script_name)) as f:\r\n    jsCode = f.read()\r\n\r\nscript = session.create_script(jsCode)\r\nscript.on("message",message)\r\nscript.load()\r\n\r\nif __name__ == "__main__":\r\n    app.run(host="0.0.0.0", port=5000, debug=False)\r\n```\r\n\r\n由于我们的目标是如何完成RPC函数，故不会对上面的代码进行更深入的说明，但是有几个点需要注意，这也是本人踩过的坑\r\n\r\n- 服务端处理完字符串数据后，一定要对字符串内的空格和回车做处理，否则会导致替换回去的数据出现显示问题\r\n- 在`Frida` 15及以上的版本，attach操作需要应用的名称，由于笔者本人使用的是**Frida 16.0.19**，所以在这里也做了特殊的处理\r\n- 我们可以在`Config`中提前设置好方法签名和函数的对应，例如`"kotlinx.android.extensionss.qz.b(Ljava/lang/String;)Ljava/lang/String;": "_handle_qz_b"`，这样就能根据不同的签名走不同的主动调用\r\n\r\n开启Frida，启动PC端server，执行脚本，能够看到大部分内容已经被解密了\r\n\r\n![](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/string_decryption_in_android_reverse_engineering-2024-05-27-14-38-07.png)\r\n\r\n但是此时还需要注意一下`CornerTreatment.b("237A88EB")`，这看上去也是一个解密，跟进去看看\r\n\r\n![](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/string_decryption_in_android_reverse_engineering-2024-05-27-14-38-08.png)\r\n\r\n果不其然，这里也是一层加密，事实上，这个Demo中也存在着很多这种嵌套解密\r\n\r\n![](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/string_decryption_in_android_reverse_engineering-2024-05-27-14-38-09.png)\r\n\r\n虽然多了一层解密，但是我们依然可以如法炮制，再上一个解密的插件，这样问题就解决了，双层嵌套解密也能被干掉\r\n\r\n![](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/string_decryption_in_android_reverse_engineering-2024-05-27-14-38-10.png)\r\n\r\n![](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/string_decryption_in_android_reverse_engineering-2024-05-27-14-38-11.png)\r\n\r\n当字符串的混淆消失之后，我们也能够更好地分析应用的行为，也可以将patch后的项目导出用于静态检测。\r\n\r\n## 总结\r\n\r\n上面的案例中我们只使用了Frida进行了字符串的还原，实际上，也存在App将字符串解密的函数放在Native中，这时候就需要更加稳定的unidbg去解了，笔者在这里只是引出一个思路，关于unidbg的使用就不再赘述了。总而言之，只要能通过这种`jadx`脚本的方式继续patch，那么字符串加密的问题就不再会成为逆向分析的时间成本，笔者也将相关的代码和最新版编译的`jadx`一并放出，可供参考。\r\n\r\n[jygzyc/apkDeobfuscation (github.com)](https://github.com/jygzyc/apkDeobfuscation)\r\n\r\n## 参考资料\r\n\r\n- [MegatronKing/StringFog: 一款自动对字节码中的字符串进行加密Android插件工具 (github.com)](https://github.com/MegatronKing/StringFog)\r\n- [frida/frida: Clone this repo to build Frida (github.com)](https://github.com/frida/frida)\r\n- [skylot/jadx: Dex to Java decompiler (github.com)](https://github.com/skylot/jadx)', 'bodyText': '字符串加密概述\n目前，主流的App上都有了字符串的加密和混淆，这对于逆向和安全检测来说，无疑是加大了难度；同时，对于恶意应用来说，也方便了他们隐藏真实的意图。针对这种情况，写了一个小工具抛砖引玉解决这类问题\n\n以某网站上的著名项目StringFog为例，这是一款自动对dex/aar/jar文件中的字符串进行加密Android插件工具，其工作如下所示\n\nStringFog实现的原理实际上非常简单，就是在字节码层面进行替换，但是却能给逆向分析增加较大的时间成本，并且，除了StringFog，市面上也存在很多自定义加密字符串的方案，这类方案往往和混淆结合在一起，就如同逆向时的鸡肋一般，让安全研究人员食之无味，弃之可惜。\n案例一：某dex\n通过jadx加载某dex文件时，会发现文件中存在很多的加密字符串，这样的加密很影响分析的效率，那么我们怎么去除它呢？在最新版本的jadx中，开发者引入了一个全新的功能——jadx-script。通过jadx-script，我们能够在jadx中执行kotlin script，而相关的例子，也放在jadx-plugins/jadx-script/examples/scripts中，下面会介绍到。\n\n跟踪这个解密的函数，能看到解密的逻辑并不复杂，完全能够直接复现，那么我们期望的效果，肯定是在静态分析时直接看到解密后的结果，下面我们就来看看怎么达到这个效果。事实上，我们可以编写一个算法还原的脚本并交给最新的jadx去执行\n\n/**\n * Replace method call with calculated result.\n * Useful for custom string deobfuscation.\n *\n * Example for sample from issue https://github.com/skylot/jadx/issues/1251\n */\n\nimport jadx.core.dex.instructions.ConstStringNode\nimport jadx.core.dex.instructions.InvokeNode\nimport jadx.core.dex.instructions.args.InsnArg\nimport jadx.core.dex.instructions.args.InsnWrapArg\nimport jadx.core.dex.instructions.args.RegisterArg\n\n\nval jadx = getJadxInstance()\n\nval mthSignature = "com.xshield.aa.iIiIiiiiII(Ljava/lang/String;)Ljava/lang/String;"\n\njadx.replace.insns { mth, insn ->\n\tif (insn is InvokeNode && insn.callMth.rawFullId == mthSignature) {\n\t\tval str = getConstStr(insn.getArg(0))\n\t\tif (str != null) {\n\t\t\tval resultStr = decode(str)\n\t\t\tlog.info { "Decode \'$str\' to \'$resultStr\' in $mth" }\n\t\t\treturn@insns ConstStringNode(resultStr)\n\t\t}\n\t}\n\tnull\n}\n\nfun getConstStr(arg: InsnArg): String? {\n\tval insn = when (arg) {\n\t\tis InsnWrapArg -> arg.wrapInsn\n\t\tis RegisterArg -> arg.assignInsn\n\t\telse -> null\n\t}\n\tif (insn is ConstStringNode) {\n\t\treturn insn.string\n\t}\n\treturn null\n}\n\n/**\n * Decompiled method, automatically converted to Kotlin by IntelliJ Idea\n */\nfun decode(str: String): String {\n\tval length = str.length\n\tval cArr = CharArray(length)\n\tvar i = length - 1\n\twhile (i >= 0) {\n\t\tval i2 = i - 1\n\t\tcArr[i] = (str[i].code xor \'z\'.code).toChar()\n\t\tif (i2 < 0) {\n\t\t\tbreak\n\t\t}\n\t\ti = i2 - 1\n\t\tcArr[i2] = (str[i2].code xor \'\\u000c\'.code).toChar()\n\t}\n\treturn String(cArr)\n}\n上面的代码中，已经复现了解密的算法，接下来就是加载脚本了，在GUI中选择replace_method_call.jadx.kts，打开\n\n执行脚本，会遍历每一个方法节点，当签名相符时，会替换为解密后的结果\n\n这样的话，我们就可以继续正常逆向分析了\n案例二：某Demo APK\n通过上面的案例，我们发现可以通过逆向的手段还原算法，但是如果碰到不能够还原的加密方法，是不是就无法解密了呢？其实不然，因为我们还有Frida或者unidbg，这两者在函数的主动调用上都是一把好手，具体的对比如下表所示\n\n\n\n\nJava层函数调用\nNative层函数调用\n稳定性\n\n\n\n\nFrida\n可以\n可以\n不稳定\n\n\nunidbg\n不可以\n可以\n稳定\n\n\n\n我们可以根据各自的特性选择主动调用的工具，这里先看一个Demo案例，以androidx.core.utils.CommenUtils$Companion.a函数为例\n\n通过上图，我们能明显看到关键字符串均采用了加密，那么看一下加密函数C3632qz.b的实现\n\n发现这里实际上是Base64的解密，当然，我们可以在脚本中实现Base64的解密算法，不过这里也可以采用另一种方式解决，那就是直接hook C3632qz.b函数，进而主动调用返回结果，具体怎么操作呢？上代码\n// That is the path relative to the jadx/bin execution directory, or it can be changed to an absolute path.\n@file:DependsOn("../external_library/okhttp-4.11.0.jar")\n@file:DependsOn("../external_library/okio-jvm-3.2.0.jar")\n@file:DependsOn("../external_library/okio-3.2.0.jar")\n\nimport okhttp3.MediaType.Companion.toMediaType\nimport okhttp3.OkHttpClient\nimport okhttp3.Request\nimport okhttp3.RequestBody.Companion.toRequestBody\nimport okhttp3.Response\n\nimport jadx.core.dex.instructions.ConstStringNode\nimport jadx.core.dex.instructions.InvokeNode\nimport jadx.core.dex.instructions.args.InsnArg\nimport jadx.core.dex.instructions.args.InsnWrapArg\nimport jadx.core.dex.instructions.args.RegisterArg\n\nval jadx = getJadxInstance()\n\nval mthSignature_qzb = "kotlinx.android.extensionss.qz.b(Ljava/lang/String;)Ljava/lang/String;"\n\njadx.replace.insns { mth, insn ->\n\tif (insn is InvokeNode && insn.callMth.rawFullId == mthSignature_qzb) {\n\t\tval str = getConstStr(insn.getArg(0))\n\t\tif (str != null) {\n\t\t\tval resultStr = decrypt(mthSignature_qzb, str)\n\t\t\tlog.info { "Decrypt \'$str\' to \'$resultStr\' in $mth" }\n\t\t\treturn@insns ConstStringNode(resultStr)\n\t\t}\n\t}\n\tnull\n}\nfun getConstStr(arg: InsnArg): String? {\n\tval insn = when (arg) {\n\t\tis InsnWrapArg -> arg.wrapInsn\n\t\tis RegisterArg -> arg.assignInsn\n\t\telse -> null\n\t}\n\tif (insn is ConstStringNode) {\n\t\treturn insn.string\n\t}\n\treturn null\n}\n// rpc 解密函数\nfun decrypt(mthSignature: String, param: String): String?{\n\tval client = OkHttpClient()\n    val json = """\n        {\n            "method": "${mthSignature}",\n\t\t\t"param": "${param}"\n        }\n    """.trimIndent()\n\n\tval requestBody = json.toRequestBody("application/json; charset=utf-8".toMediaType())\n\n\tval request = Request.Builder()\n        .url("http://127.0.0.1:5000/decrypt")\n        .post(requestBody)\n        .build()\n\n    val response = client.newCall(request).execute()\n\treturn response.body?.string().toString()\n}\n能够发现，其实脚本的主体结构并没有太大的变化，但是在核心的decrypt函数上，使用了OkHttp发送请求，并接受返回的数据，即是将jadx作为了客户端。既然有客户端，那么也得有服务端，如下所示\n# ...\napp = Flask(__name__)\nlogger = Logger(log_level="INFO")\n\ndef message(message, data):\n    if message[\'type\'] == \'send\':\n        logger.debug(f"[*] {message[\'payload\']}")\n    else:\n        logger.debug(message)\n\n@app.route(\'/decrypt\', methods=[\'POST\'])#data解密\ndef decrypt_class():\n    data = request.get_data()\n    json_data = json.loads(data.decode("utf-8"))\n    logger.info(json_data)\n    method_sig = json_data.get("method")\n    method_param = handle_params(json_data.get("param"))\n    logger.debug(f"method: ${method_sig}; params: ${method_param}") \n    handle_method = globals()[methods[method_sig]]\n    res = _process_string(handle_method(method_sig, method_param))\n    response = make_response(res, 200)\n    response.headers[\'Content-Type\'] = \'application/json\'\n    return response\n\ndef _process_string(s: str) -> str:\n    s = \' \'.join(s.split())\n    s = re.sub(r\'\\s+\', \' \', s)\n    if len(s) > 0 and s[0] == \' \':\n        s = \' \' + s.lstrip()\n    if len(s) > 0 and s[-1] == \' \':\n        s = s.rstrip() + \' \'\n    return s\n\ndef handle_params(params):\n    return params\n\n#################### Method Handler ####################\n\ndef _handle_qz_b(method_name, method_param):\n    res = _process_string(script.exports_sync.invokemethod01(method_param))\n    logger.info(f"{method_param} => {res}")\n    return res\n\ndef _handle_cg_b(method_name, method_param):\n    res = _process_string(script.exports_sync.invokemethod02(method_param))\n    logger.info(f"{method_param} => {res}")\n    return res\n\n#################### Flask Server ####################\n\nconfig = Config.builder()\nmethods = config.methods_map\n\ndevice = frida.get_device_manager().add_remote_device(config.remote_device)\nif(config.spawn):\n    session = device.spawn(config.package_name)\nelse:\n    session = device.attach(config.app_name)\n\nwith open(os.path.join(os.path.dirname(os.path.abspath(__file__)), "scripts", config.frida_script_name)) as f:\n    jsCode = f.read()\n\nscript = session.create_script(jsCode)\nscript.on("message",message)\nscript.load()\n\nif __name__ == "__main__":\n    app.run(host="0.0.0.0", port=5000, debug=False)\n由于我们的目标是如何完成RPC函数，故不会对上面的代码进行更深入的说明，但是有几个点需要注意，这也是本人踩过的坑\n\n服务端处理完字符串数据后，一定要对字符串内的空格和回车做处理，否则会导致替换回去的数据出现显示问题\n在Frida 15及以上的版本，attach操作需要应用的名称，由于笔者本人使用的是Frida 16.0.19，所以在这里也做了特殊的处理\n我们可以在Config中提前设置好方法签名和函数的对应，例如"kotlinx.android.extensionss.qz.b(Ljava/lang/String;)Ljava/lang/String;": "_handle_qz_b"，这样就能根据不同的签名走不同的主动调用\n\n开启Frida，启动PC端server，执行脚本，能够看到大部分内容已经被解密了\n\n但是此时还需要注意一下CornerTreatment.b("237A88EB")，这看上去也是一个解密，跟进去看看\n\n果不其然，这里也是一层加密，事实上，这个Demo中也存在着很多这种嵌套解密\n\n虽然多了一层解密，但是我们依然可以如法炮制，再上一个解密的插件，这样问题就解决了，双层嵌套解密也能被干掉\n\n\n当字符串的混淆消失之后，我们也能够更好地分析应用的行为，也可以将patch后的项目导出用于静态检测。\n总结\n上面的案例中我们只使用了Frida进行了字符串的还原，实际上，也存在App将字符串解密的函数放在Native中，这时候就需要更加稳定的unidbg去解了，笔者在这里只是引出一个思路，关于unidbg的使用就不再赘述了。总而言之，只要能通过这种jadx脚本的方式继续patch，那么字符串加密的问题就不再会成为逆向分析的时间成本，笔者也将相关的代码和最新版编译的jadx一并放出，可供参考。\njygzyc/apkDeobfuscation (github.com)\n参考资料\n\nMegatronKing/StringFog: 一款自动对字节码中的字符串进行加密Android插件工具 (github.com)\nfrida/frida: Clone this repo to build Frida (github.com)\nskylot/jadx: Dex to Java decompiler (github.com)', 'author': {'login': 'jygzyc'}, 'category': {'name': '0101-Android'}, 'labels': {'nodes': [{'name': '010103-逆向分析'}]}, 'comments': {'nodes': []}}, {'title': '双系统配置合集', 'number': 11, 'url': 'https://github.com/jygzyc/notes/discussions/11', 'createdAt': '2024-05-27T03:43:17Z', 'lastEditedAt': '2024-05-27T03:50:33Z', 'updatedAt': '2024-05-27T03:50:33Z', 'body': '<!-- dual_system -->\r\n\r\n## Windows关闭快速启动\r\n\r\n控制面板 -> 电源选项 -> 选择电源按钮的功能 -> 更改当前不可用的设置 -> 取消启用快速启动\r\n\r\n## 双系统下 Ubuntu 读写/挂载 Windows 中的硬盘文件 + 解决文件系统突然变成只读[^1]\r\n\r\n查看所有盘符\r\n\r\n```bash\r\n$ sudo fdisk -l\r\n...\r\n设备                  起点       末尾       扇区   大小 类型\r\n/dev/nvme0n1p1        2048     206847     204800   100M EFI 系统\r\n/dev/nvme0n1p2      206848     239615      32768    16M Microsoft 保留\r\n/dev/nvme0n1p3      239616  564531199  564291584 269.1G Microsoft 基本数据\r\n/dev/nvme0n1p4   564531200  566231039    1699840   830M Windows 恢复环境\r\n/dev/nvme0n1p5   566231040 2453667839 1887436800   900G Microsoft 基本数据\r\n/dev/nvme0n1p6  2453667840 2663397375  209729536   100G Microsoft 基本数据\r\n/dev/nvme0n1p7  2663397376 2665398271    2000896   977M Linux 文件系统\r\n/dev/nvme0n1p8  2665398272 2785398783  120000512  57.2G Linux 文件系统\r\n/dev/nvme0n1p9  3875028992 3907028991   32000000  15.3G Linux swap\r\n/dev/nvme0n1p10 2785398784 3875028991 1089630208 519.6G Linux 文件系统\r\n```\r\n\r\n我们的目标是挂载 `/dev/nvme0n1p6`，先创建目录\r\n\r\n`sudo mkdir /mnt/sync`\r\n\r\n **必须要先关闭Windows的快速启动**\r\n\r\n- 临时挂载\r\n\r\n```bash\r\nsudo mount /dev/nvme0n1p6 /mnt/sync\r\n```\r\n\r\n- 永久挂载（推荐）\r\n\r\n首先获取 `/dev/nvme0n1p6` 的 UUID\r\n\r\n```bash\r\nsudo blkid /dev/nvme0n1p6\r\n/dev/nvme0n1p6: LABEL="sync" BLOCK_SIZE="512" UUID="72523FXXXXXXXXXX" TYPE="ntfs" PARTLABEL="Basic data partition" PARTUUID="290ebe9b-XXXX-XXXX-XXXX-6ab7efXXXXXX"\r\n```\r\n\r\n可以发现在输出结果中可以发现一段 `UUID="XXXXXXXXXXX"` 的内容，右键选中复制下来\r\n\r\n接着就来修改系统文件 `/etc/fstab`（`sudo vim /etc/fstab`），把如下内容添加进去，照着上面添加就好\r\n\r\n```txt\r\nUUID=XXXXXXXXXX   /mnt/sync   ntfs  defaults   0   2\r\n```\r\n\r\n保存之后执行 `mount -a`\r\n\r\n如果文件系统显示read-only，那么以下处理方式通用\r\n\r\n```bash\r\napt-get install ntfs-3g # 先安装 ntfs-3g\r\nntfsfix /dev/nvme0n1p6 # 再修复即可\r\n```\r\n\r\n如果显示 `target is busy`，就先杀掉占用\r\n\r\n```bash\r\nfuser -m -u /dev/nvme0n1p6 # 获取占用\r\nkill xxx # 干掉\r\numount /dev/nvme0n1p6\r\nmount /dev/nvme0n1p6 /mnt/sync # 重新挂载\r\n```\r\n\r\n如果不行就`ntfsfix /dev/nvme0n1p6`修复一下再挂载\r\n\r\n## Ubuntu下输入法安装\r\n\r\n搜索了一下，最后决定使用中州韵输入法，安装起来也比较简单，[官网链接](https://rime.im)\r\n\r\n直接使用 `apt-get install ibus-rime` 即可安装\r\n\r\n## mihomo clash 服务创建[^2]\r\n\r\n- 下载二进制可执行文件 [releases](https://github.com/MetaCubeX/mihomo/releases)\r\n- 将下载的二进制可执行文件重名名为 `mihomo` 并移动到 `/usr/local/bin/`\r\n- 以守护进程的方式，运行 `mihomo`。\r\n\r\n使用以下命令将 Clash 二进制文件复制到 /usr/local/bin, 配置文件复制到 /etc/mihomo:\r\n\r\n```bash\r\ncp mihomo /usr/local/bin\r\ncp config.yaml /etc/mihomo\r\n```\r\n\r\n创建 systemd 配置文件 `/etc/systemd/system/mihomo.service`:\r\n\r\n```\r\n[Unit]\r\nDescription=mihomo Daemon, Another Clash Kernel.\r\nAfter=network.target NetworkManager.service systemd-networkd.service iwd.service\r\n\r\n[Service]\r\nType=simple\r\nLimitNPROC=500\r\nLimitNOFILE=1000000\r\nCapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCH CAP_DAC_OVERRIDE\r\nAmbientCapabilities=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCH CAP_DAC_OVERRIDE\r\nRestart=always\r\nExecStartPre=/usr/bin/sleep 1s\r\nExecStart=/usr/local/bin/mihomo -d /etc/mihomo\r\nExecReload=/bin/kill -HUP $MAINPID\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n\r\n使用以下命令重新加载 systemd:\r\n\r\n```bash\r\nsystemctl daemon-reload\r\n```\r\n\r\n启用 mihomo 服务：\r\n\r\n```bash\r\nsystemctl enable mihomo\r\n```\r\n\r\n[^1]: [虤虤豆的博客](https://tiger.fail/archives/ubuntu-rw-windows-files.html)\r\n[^2]: [虚空终端 Docs](https://wiki.metacubex.one/)', 'bodyText': 'Windows关闭快速启动\n控制面板 -> 电源选项 -> 选择电源按钮的功能 -> 更改当前不可用的设置 -> 取消启用快速启动\n双系统下 Ubuntu 读写/挂载 Windows 中的硬盘文件 + 解决文件系统突然变成只读1\n查看所有盘符\n$ sudo fdisk -l\n...\n设备                  起点       末尾       扇区   大小 类型\n/dev/nvme0n1p1        2048     206847     204800   100M EFI 系统\n/dev/nvme0n1p2      206848     239615      32768    16M Microsoft 保留\n/dev/nvme0n1p3      239616  564531199  564291584 269.1G Microsoft 基本数据\n/dev/nvme0n1p4   564531200  566231039    1699840   830M Windows 恢复环境\n/dev/nvme0n1p5   566231040 2453667839 1887436800   900G Microsoft 基本数据\n/dev/nvme0n1p6  2453667840 2663397375  209729536   100G Microsoft 基本数据\n/dev/nvme0n1p7  2663397376 2665398271    2000896   977M Linux 文件系统\n/dev/nvme0n1p8  2665398272 2785398783  120000512  57.2G Linux 文件系统\n/dev/nvme0n1p9  3875028992 3907028991   32000000  15.3G Linux swap\n/dev/nvme0n1p10 2785398784 3875028991 1089630208 519.6G Linux 文件系统\n我们的目标是挂载 /dev/nvme0n1p6，先创建目录\nsudo mkdir /mnt/sync\n必须要先关闭Windows的快速启动\n\n临时挂载\n\nsudo mount /dev/nvme0n1p6 /mnt/sync\n\n永久挂载（推荐）\n\n首先获取 /dev/nvme0n1p6 的 UUID\nsudo blkid /dev/nvme0n1p6\n/dev/nvme0n1p6: LABEL="sync" BLOCK_SIZE="512" UUID="72523FXXXXXXXXXX" TYPE="ntfs" PARTLABEL="Basic data partition" PARTUUID="290ebe9b-XXXX-XXXX-XXXX-6ab7efXXXXXX"\n可以发现在输出结果中可以发现一段 UUID="XXXXXXXXXXX" 的内容，右键选中复制下来\n接着就来修改系统文件 /etc/fstab（sudo vim /etc/fstab），把如下内容添加进去，照着上面添加就好\nUUID=XXXXXXXXXX   /mnt/sync   ntfs  defaults   0   2\n保存之后执行 mount -a\n如果文件系统显示read-only，那么以下处理方式通用\napt-get install ntfs-3g # 先安装 ntfs-3g\nntfsfix /dev/nvme0n1p6 # 再修复即可\n如果显示 target is busy，就先杀掉占用\nfuser -m -u /dev/nvme0n1p6 # 获取占用\nkill xxx # 干掉\numount /dev/nvme0n1p6\nmount /dev/nvme0n1p6 /mnt/sync # 重新挂载\n如果不行就ntfsfix /dev/nvme0n1p6修复一下再挂载\nUbuntu下输入法安装\n搜索了一下，最后决定使用中州韵输入法，安装起来也比较简单，官网链接\n直接使用 apt-get install ibus-rime 即可安装\nmihomo clash 服务创建2\n\n下载二进制可执行文件 releases\n将下载的二进制可执行文件重名名为 mihomo 并移动到 /usr/local/bin/\n以守护进程的方式，运行 mihomo。\n\n使用以下命令将 Clash 二进制文件复制到 /usr/local/bin, 配置文件复制到 /etc/mihomo:\ncp mihomo /usr/local/bin\ncp config.yaml /etc/mihomo\n创建 systemd 配置文件 /etc/systemd/system/mihomo.service:\n[Unit]\nDescription=mihomo Daemon, Another Clash Kernel.\nAfter=network.target NetworkManager.service systemd-networkd.service iwd.service\n\n[Service]\nType=simple\nLimitNPROC=500\nLimitNOFILE=1000000\nCapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCH CAP_DAC_OVERRIDE\nAmbientCapabilities=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCH CAP_DAC_OVERRIDE\nRestart=always\nExecStartPre=/usr/bin/sleep 1s\nExecStart=/usr/local/bin/mihomo -d /etc/mihomo\nExecReload=/bin/kill -HUP $MAINPID\n\n[Install]\nWantedBy=multi-user.target\n\n使用以下命令重新加载 systemd:\nsystemctl daemon-reload\n启用 mihomo 服务：\nsystemctl enable mihomo\nFootnotes\n\n\n虤虤豆的博客 ↩\n\n\n虚空终端 Docs ↩', 'author': {'login': 'jygzyc'}, 'category': {'name': '0199-折腾'}, 'labels': {'nodes': []}, 'comments': {'nodes': []}}, {'title': 'Bringing Balance to the Force Dynamic Analysis of the Android Application Framework 笔记', 'number': 10, 'url': 'https://github.com/jygzyc/notes/discussions/10', 'createdAt': '2024-05-21T03:29:58Z', 'lastEditedAt': '2024-05-27T03:23:25Z', 'updatedAt': '2024-05-27T03:23:25Z', 'body': '<!-- note_bringing_balance_to_the_force_dynamic_analysis_of_the_android_application_framework -->\r\n《Bringing Balance to the Force Dynamic Analysis of the Android Application Framework》讨论了静态代码分析在解决 Android 应用框架安全问题上的局限，并说明了动态分析对于 Android 应用框架问题检测的可行性，提出了 DYNAMO 的解决方案。[^1] [^2]\r\n\r\n<!-- more -->\r\n\r\n## 概述\r\n\r\n讨论了静态代码分析在解决 Android 应用框架安全问题上的局限性。它强调了动态分析在补充静态分析以提高安全评估的准确性和完整性方面的重要性。文章介绍了名为 DYNAMO 的解决方案，该方案对四个具有代表性的文献中的使用案例进行了动态分析。通过这样做，它验证、反驳并扩展了先前的静态分析解决方案的结果。此外，通过对结果的手动调查，提供了新的见解和专家知识，这些知识对于改进应用框架的静态和动态测试具有价值。\r\n动态分析与静态分析相结合的重要性在于：  \r\n\r\n- 动态分析可以弥补静态分析在处理庞大且复杂代码库时的局限性。\r\n- 动态分析有助于提高依赖静态分析结果的不同安全应用（如恶意软件分类和最小权限应用）的性能。\r\n- 通过动态分析，可以获得关于代码行为和潜在安全问题的更深入的了解。\r\n- 动态分析有助于发现并解决静态分析中可能遗漏的安全问题。\r\n- 将动态分析与静态分析相结合，可以更全面地评估应用框架的安全性，从而为用户提供更安全的体验。\r\n\r\n因此，在安全研究领域，动态分析与静态分析的结合被认为是至关重要的，这种方法可以帮助提高 Android 应用框架的安全性，保护用户的隐私数据和系统完整性。\r\n\r\n## 背景\r\n\r\n**Android Framework API**\r\n\r\n所有已注册的系统服务都能够在ServiceManager类中被找到，作者基于这一事实来提取系统API的入口点。\r\n\r\n**Binder IPC**\r\n\r\nBinder是安卓系统特有的进程间通信机制，底层原理是使用内核内存贡献来在进程间通信。对于一些比较敏感的底层系统API，安卓系统通过Binder封装后对外提供一些High-Level的API用于调用，在调用时则会进行权限检查。\r\n\r\n**Permission**\r\n  \r\n安卓的权限管理可以分为3类：\r\n\r\n- UID/PID检查: 只有指定UID的进程才能调用特定的API。例如，可以用于仅允许系统（getCallingUid() == 1000）或同一进程（getCallingPid() == currentPid）执行特定 API\r\n- 跨用户检查：对于使用手机分身的情况，不同分身代表不同用户，不同用户之前权限有差异\r\n- AppOps：权限申请(如相机权限)首先需要在Manifest中静态申请，而申请完成后的权限是否能够动态的调用则由AppOps进行管理\r\n    \r\n高级访问控制由低级的自主访问控制（DAC）和强制访问控制（MAC）补充。DAC 使用传统的 Unix 权限（基于组和 UID）来限制应用程序沙箱和进程，例如，防止绕过服务 API 直接访问系统服务和应用程序封装的资源，如私有用户数据或设备驱动程序。从 Android 5.0 开始，完全实施的 SELinux 被用于 MAC，以加强进程的隔离性和加强系统对特权提升的防御\r\n\r\n## 简介\r\n\r\n### 相关工作\r\n\r\n**Permission Mapping**\r\n\r\nPermission Mapping即权限映射，在本文中是指将Android Framework层提供的系统API以及调用该API时所需要申请的权限建立映射。\r\nPermission Mapping的意义有：\r\n\r\n1. 帮助开发者编写符合最小特权原则的app\r\n2. 可以用于恶意软件检测或者识别过量申请权限的app\r\n3. 可以识别安卓系统中自带的权限漏洞\r\n\r\n**Vulnerability Detection in the Security Policy**\r\n\r\n发现系统服务内访问控制执行的差异，例如，两个具有不同安全条件的 API 导致相同的功能或数据 sink。要进行此类分析，首先需要对系统 API 的安全策略进行建模。\r\n\r\n1. 使用预定义的授权检查列表，例如 checkPermission 和 hasUserRestriction，但需要手动增量补充此列表以定义各个 API 的安全策略。\r\n2. 为了消除对用户定义的授权检查列表的依赖，ACMiner引入了半自动和启发式驱动的方法来构建此列表。Centaur提出了与静态分析相结合的符号执行，以发现和验证不一致性。然而，Centaur 需要访问源代码，因此不能用于封闭源代码的 OEM 镜像。 \r\n3. 其他研究分析了保护不当的参数敏感 API。利用这些 API 会干扰系统的状态或提高调用者的权限。与不一致性检测密切相关，ARF采用了静态分析和手动代码审查技术，发现了 Android 系统服务中权限重新分配的情况，例如，一种 API 调用另一种受保护的 API，并实施比直接调用目标 API 时更宽松的权限。\r\n\r\n**Fuzzing for Vulnerability Detection**\r\n\r\n可以使用有故障的载荷对系统 API 进行模糊测试，可能导致权限泄漏或拒绝服务；针对系统服务中处理不当的异常进行攻击，可能导致系统崩溃；FANS针对源码中的native服务进行Fuzz\r\n\r\n### 动机\r\n\r\n现有的工作基本上都是基于静态分析的，而静态分析尤其固有的缺陷，比如很难处理动态变量的值、IPC等。而目前的Permission Mapping结果几乎完全基于静态分析，这导致结果的不准确性，而对其他依赖于该结果的工作造成影响。因此作者认为有必要用动态测试的方法来重新审视这个结果。\r\n\r\n## 设计与实现\r\n\r\n### 设计\r\n\r\n本文想要设计一个动态测试工具来为Android Framework层API建立权限映射，主要有以下几个Research Questions:\r\n\r\nRQ1: 如何识别这些API的入口并触发它们。难点在于这些API分散在不同的Service之中，并且可能分别由Java或者Native代码实现。  \r\nRQ2: 如何为这些API构建输入。  \r\nRQ3: 如何衡量动态测试的覆盖率。  \r\nRQ4: 如何检测出不同类型的权限管理。有些是集中管理的很好识别，有些代码甚至是inline的，不容易发现。  \r\nRQ5: 如何构建反馈通道。即怎样将某个API的测试结果反馈给Fuzzer  \r\nRQ6: 如何保留不同权限检查之间的关系和顺序。  \r\n\r\n### 实现\r\n\r\nDYNAMO 是一种灰盒测试解决方案，分为两个阶段来构建 API 的安全策略。第一阶段专注于通过运行不同输入集来测试 API，以提高代码覆盖率。在第二阶段，根据预定义的关联规则分析第一阶段的结果，以建模目标 API 的安全策略。下图展示了 DYNAMO 主要组件的概述以及针对单个 API 执行一次测试迭代的后序执行步骤。\r\n\r\n*Testing Service*（TS）作为一个应用程序组件分发，安装在要测试的设备上。它负责生成输入，调用目标 API，并报告调用结果。\r\n\r\n*Instrumentation Server*（IS）是一个后台进程，当前版本本质是 Frida-server，负责构建反馈通道，报告hook信息和调用栈。\r\n\r\n*Testing Manager*（TM）的请求下还负责在运行时修改方法的行为。当前版本本质是 Frida Client，发送给TS进行API调用，并接收由IS中收集到的调用结果反馈，通过Analyser Module来分析覆盖率情况，控制当前的测试状态。\r\n\r\n![Fig.0](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/note_bringing_balance_to_the_force_dynamic_analysis_of_the_android_application_framework-2024-05-27-11-27-00.png)\r\n\r\n**Collecting Public APIs（RQ1）**\r\n\r\n利用ServiceManager会维护所有注册的系统Service的这一事实，利用Java反射来从ServiceManager中获取所有能够找到的Service的Handle，并将其强转为对应Service的Proxy对象，在这些对象中就能找到这个Service的所有API的方法签名了\r\n\r\n在测试这些API时，作者采用多台设备并行的方式进行，每台设备一次只测试一个API。\r\n\r\n**Generating Input（RQ2）**\r\n\r\n从API中提取签名后，会分配一个简短的预定义种子值列表，对于参数，分为两种类型处理，基本 Android 类型（如 Intent 和 URI）和复杂类型（如事件监听器和位图），基本类型可以由预定义的种子生成。而对于复杂类型，在 TS 端使用递归的方式构造，通过为其传入基本类型来调用其构造函数从而生成输入。\r\n\r\n**Measuring Coverage（RQ3）**\r\n\r\n作者使用了一个叫WALA的工具，来对每个API进行可达性分析，对于每个API可以得到一个有限的方法集合，调用API可以最终到达这些方法。通过Hook这些方法，当其被调用时打印调用栈，如果确实是由该API所触发并且调用者为TS时(用于排除噪声)，统计该Trace。最后覆盖率的计算公式为Unique Trace的数量比上集合中的方法数量。\r\n\r\n**DYNAMO’s Testing Strategies (RQ4)**\r\n\r\n对于如何检测不同类型的权限检测的问题(RQ4)，作者预定义了多种测试策略，每种策略旨在发现不同类型的安全检测。工作流程大致如下：\r\n\r\n![Fig.1](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/note_bringing_balance_to_the_force_dynamic_analysis_of_the_android_application_framework-2024-05-27-11-18-00.png)\r\n\r\n> 例如，一种策略可以专注于发现权限，而另一种策略则检测对调用方UID和PID的检查。每个策略都从一个由预定义种子生成的输入集列表开始，所有策略都采用相同的列表。对于每种策略，DYNAMO都会执行每一个输入集，并在安全检查失败时进行检测。当报告安全检查时，它们会在同一输入集的下一次迭代中反馈，DYNAMO指示IS绕过失败的检查，以检测同一执行路径上的其他检查。重复此过程，直到没有进一步的安全检查报告为止。所有策略结束后，TM将当前API标记为完成，并继续下一个待测试的API。通过这种反馈驱动的测试，DYNAMO探索了几个调用方上下文（即第三方应用程序、特权应用程序等），以触发和检测安全检查\r\n\r\n作者举了一个例子来帮助理解，以AccessibilityManagerService的addClient API的简化版本为例\r\n\r\n![Fig.2](https://raw.githubusercontent.com/jygzyc/notes-images/main/blog/note_bringing_balance_to_the_force_dynamic_analysis_of_the_android_application_framework-2024-05-27-11-18-30.png)\r\n\r\n\r\n若要执行此API，调用方必须符合以下条件之一：  \r\n1）调用方必须在等于0或1000的UID下运行（第9行）。  \r\n2） 调用程序必须在userId等于API第二个输入参数的上下文中运行（第13行）。  \r\n3） 呼叫者必须被授予`INTERACT_ACROSS_USERS`（ACU）权限（第16行）。  \r\n如果这些条件都不满足，就会引发`SecurityException`（第25行）。为了简化这个例子，我们只定义了一组由null和10组成的输入，分别作为第一和第二参数。在这个例子中选择10不是任意的，因为它对应于次要配置文件的userId（而0是主要配置文件的用户Id）。使用来自主配置文件和非特权上下文的这组输入调用API将导致调用方收到`SecurityException`，因为以上条件都不符合。\r\n\r\n对于特定权限检查的情况(图中INTERACT_ACROSS_USERS)会有统一的函数完成(checkPermission函数)，通过hook就能知道是否触发了这种检查以及具体的参数类型。\r\n\r\n对于inline检查UID的情况，作者通过Hook Binder.getCallingUid函数来不断变更自己的UID，如果发现某一次变更后通过了权限检查，则说明存在inline UID检查\r\n\r\n**Instrumenting Targets（RQ5）**\r\n\r\n作者使用了Frida动态Hook框架优点是能够兼容不同的系统，而无需修改安卓源码，能够满足对一些闭源的OEM厂商的测试需求。\r\n\r\n**Modeling of Permission Mapping（RQ6）**\r\n\r\n作者想要得到上图中List2中的结果作为输出，这可以使用RQ4中的方法来得到具体UID值的检查以及具体权限检查的两种情况，但是对于UID是否等于入参的情况，作者通过不断变更入参的方式来检查。\r\n\r\n## 代码分析\r\n\r\n从Github项目可以看到DYNAMO的源码[^3]\r\n\r\n[^1]: [*Bringing Balance to the Force Dynamic Analysis of the Android Application Framework*](https://www.ndss-symposium.org/wp-content/uploads/ndss2021_2B-1_23106_paper.pdf)\r\n\r\n[^2]: [论文笔记:《Bringing Balance to the Force Dynamic Analysis of the Android Application Framework》](https://ashenone66.cn/2022/03/03/lun-wen-bi-ji-bringing-balance-to-the-force-dynamic-analysis-of-the-android-application-framework/)\r\n\r\n[^3]: [Github - abdawoud/Dynamo](https://github.com/abdawoud/Dynamo)', 'bodyText': '《Bringing Balance to the Force Dynamic Analysis of the Android Application Framework》讨论了静态代码分析在解决 Android 应用框架安全问题上的局限，并说明了动态分析对于 Android 应用框架问题检测的可行性，提出了 DYNAMO 的解决方案。1 2\n\n概述\n讨论了静态代码分析在解决 Android 应用框架安全问题上的局限性。它强调了动态分析在补充静态分析以提高安全评估的准确性和完整性方面的重要性。文章介绍了名为 DYNAMO 的解决方案，该方案对四个具有代表性的文献中的使用案例进行了动态分析。通过这样做，它验证、反驳并扩展了先前的静态分析解决方案的结果。此外，通过对结果的手动调查，提供了新的见解和专家知识，这些知识对于改进应用框架的静态和动态测试具有价值。\n动态分析与静态分析相结合的重要性在于：\n\n动态分析可以弥补静态分析在处理庞大且复杂代码库时的局限性。\n动态分析有助于提高依赖静态分析结果的不同安全应用（如恶意软件分类和最小权限应用）的性能。\n通过动态分析，可以获得关于代码行为和潜在安全问题的更深入的了解。\n动态分析有助于发现并解决静态分析中可能遗漏的安全问题。\n将动态分析与静态分析相结合，可以更全面地评估应用框架的安全性，从而为用户提供更安全的体验。\n\n因此，在安全研究领域，动态分析与静态分析的结合被认为是至关重要的，这种方法可以帮助提高 Android 应用框架的安全性，保护用户的隐私数据和系统完整性。\n背景\nAndroid Framework API\n所有已注册的系统服务都能够在ServiceManager类中被找到，作者基于这一事实来提取系统API的入口点。\nBinder IPC\nBinder是安卓系统特有的进程间通信机制，底层原理是使用内核内存贡献来在进程间通信。对于一些比较敏感的底层系统API，安卓系统通过Binder封装后对外提供一些High-Level的API用于调用，在调用时则会进行权限检查。\nPermission\n安卓的权限管理可以分为3类：\n\nUID/PID检查: 只有指定UID的进程才能调用特定的API。例如，可以用于仅允许系统（getCallingUid() == 1000）或同一进程（getCallingPid() == currentPid）执行特定 API\n跨用户检查：对于使用手机分身的情况，不同分身代表不同用户，不同用户之前权限有差异\nAppOps：权限申请(如相机权限)首先需要在Manifest中静态申请，而申请完成后的权限是否能够动态的调用则由AppOps进行管理\n\n高级访问控制由低级的自主访问控制（DAC）和强制访问控制（MAC）补充。DAC 使用传统的 Unix 权限（基于组和 UID）来限制应用程序沙箱和进程，例如，防止绕过服务 API 直接访问系统服务和应用程序封装的资源，如私有用户数据或设备驱动程序。从 Android 5.0 开始，完全实施的 SELinux 被用于 MAC，以加强进程的隔离性和加强系统对特权提升的防御\n简介\n相关工作\nPermission Mapping\nPermission Mapping即权限映射，在本文中是指将Android Framework层提供的系统API以及调用该API时所需要申请的权限建立映射。\nPermission Mapping的意义有：\n\n帮助开发者编写符合最小特权原则的app\n可以用于恶意软件检测或者识别过量申请权限的app\n可以识别安卓系统中自带的权限漏洞\n\nVulnerability Detection in the Security Policy\n发现系统服务内访问控制执行的差异，例如，两个具有不同安全条件的 API 导致相同的功能或数据 sink。要进行此类分析，首先需要对系统 API 的安全策略进行建模。\n\n使用预定义的授权检查列表，例如 checkPermission 和 hasUserRestriction，但需要手动增量补充此列表以定义各个 API 的安全策略。\n为了消除对用户定义的授权检查列表的依赖，ACMiner引入了半自动和启发式驱动的方法来构建此列表。Centaur提出了与静态分析相结合的符号执行，以发现和验证不一致性。然而，Centaur 需要访问源代码，因此不能用于封闭源代码的 OEM 镜像。\n其他研究分析了保护不当的参数敏感 API。利用这些 API 会干扰系统的状态或提高调用者的权限。与不一致性检测密切相关，ARF采用了静态分析和手动代码审查技术，发现了 Android 系统服务中权限重新分配的情况，例如，一种 API 调用另一种受保护的 API，并实施比直接调用目标 API 时更宽松的权限。\n\nFuzzing for Vulnerability Detection\n可以使用有故障的载荷对系统 API 进行模糊测试，可能导致权限泄漏或拒绝服务；针对系统服务中处理不当的异常进行攻击，可能导致系统崩溃；FANS针对源码中的native服务进行Fuzz\n动机\n现有的工作基本上都是基于静态分析的，而静态分析尤其固有的缺陷，比如很难处理动态变量的值、IPC等。而目前的Permission Mapping结果几乎完全基于静态分析，这导致结果的不准确性，而对其他依赖于该结果的工作造成影响。因此作者认为有必要用动态测试的方法来重新审视这个结果。\n设计与实现\n设计\n本文想要设计一个动态测试工具来为Android Framework层API建立权限映射，主要有以下几个Research Questions:\nRQ1: 如何识别这些API的入口并触发它们。难点在于这些API分散在不同的Service之中，并且可能分别由Java或者Native代码实现。\nRQ2: 如何为这些API构建输入。\nRQ3: 如何衡量动态测试的覆盖率。\nRQ4: 如何检测出不同类型的权限管理。有些是集中管理的很好识别，有些代码甚至是inline的，不容易发现。\nRQ5: 如何构建反馈通道。即怎样将某个API的测试结果反馈给Fuzzer\nRQ6: 如何保留不同权限检查之间的关系和顺序。\n实现\nDYNAMO 是一种灰盒测试解决方案，分为两个阶段来构建 API 的安全策略。第一阶段专注于通过运行不同输入集来测试 API，以提高代码覆盖率。在第二阶段，根据预定义的关联规则分析第一阶段的结果，以建模目标 API 的安全策略。下图展示了 DYNAMO 主要组件的概述以及针对单个 API 执行一次测试迭代的后序执行步骤。\nTesting Service（TS）作为一个应用程序组件分发，安装在要测试的设备上。它负责生成输入，调用目标 API，并报告调用结果。\nInstrumentation Server（IS）是一个后台进程，当前版本本质是 Frida-server，负责构建反馈通道，报告hook信息和调用栈。\nTesting Manager（TM）的请求下还负责在运行时修改方法的行为。当前版本本质是 Frida Client，发送给TS进行API调用，并接收由IS中收集到的调用结果反馈，通过Analyser Module来分析覆盖率情况，控制当前的测试状态。\n\nCollecting Public APIs（RQ1）\n利用ServiceManager会维护所有注册的系统Service的这一事实，利用Java反射来从ServiceManager中获取所有能够找到的Service的Handle，并将其强转为对应Service的Proxy对象，在这些对象中就能找到这个Service的所有API的方法签名了\n在测试这些API时，作者采用多台设备并行的方式进行，每台设备一次只测试一个API。\nGenerating Input（RQ2）\n从API中提取签名后，会分配一个简短的预定义种子值列表，对于参数，分为两种类型处理，基本 Android 类型（如 Intent 和 URI）和复杂类型（如事件监听器和位图），基本类型可以由预定义的种子生成。而对于复杂类型，在 TS 端使用递归的方式构造，通过为其传入基本类型来调用其构造函数从而生成输入。\nMeasuring Coverage（RQ3）\n作者使用了一个叫WALA的工具，来对每个API进行可达性分析，对于每个API可以得到一个有限的方法集合，调用API可以最终到达这些方法。通过Hook这些方法，当其被调用时打印调用栈，如果确实是由该API所触发并且调用者为TS时(用于排除噪声)，统计该Trace。最后覆盖率的计算公式为Unique Trace的数量比上集合中的方法数量。\nDYNAMO’s Testing Strategies (RQ4)\n对于如何检测不同类型的权限检测的问题(RQ4)，作者预定义了多种测试策略，每种策略旨在发现不同类型的安全检测。工作流程大致如下：\n\n\n例如，一种策略可以专注于发现权限，而另一种策略则检测对调用方UID和PID的检查。每个策略都从一个由预定义种子生成的输入集列表开始，所有策略都采用相同的列表。对于每种策略，DYNAMO都会执行每一个输入集，并在安全检查失败时进行检测。当报告安全检查时，它们会在同一输入集的下一次迭代中反馈，DYNAMO指示IS绕过失败的检查，以检测同一执行路径上的其他检查。重复此过程，直到没有进一步的安全检查报告为止。所有策略结束后，TM将当前API标记为完成，并继续下一个待测试的API。通过这种反馈驱动的测试，DYNAMO探索了几个调用方上下文（即第三方应用程序、特权应用程序等），以触发和检测安全检查\n\n作者举了一个例子来帮助理解，以AccessibilityManagerService的addClient API的简化版本为例\n\n若要执行此API，调用方必须符合以下条件之一：\n1）调用方必须在等于0或1000的UID下运行（第9行）。\n2） 调用程序必须在userId等于API第二个输入参数的上下文中运行（第13行）。\n3） 呼叫者必须被授予INTERACT_ACROSS_USERS（ACU）权限（第16行）。\n如果这些条件都不满足，就会引发SecurityException（第25行）。为了简化这个例子，我们只定义了一组由null和10组成的输入，分别作为第一和第二参数。在这个例子中选择10不是任意的，因为它对应于次要配置文件的userId（而0是主要配置文件的用户Id）。使用来自主配置文件和非特权上下文的这组输入调用API将导致调用方收到SecurityException，因为以上条件都不符合。\n对于特定权限检查的情况(图中INTERACT_ACROSS_USERS)会有统一的函数完成(checkPermission函数)，通过hook就能知道是否触发了这种检查以及具体的参数类型。\n对于inline检查UID的情况，作者通过Hook Binder.getCallingUid函数来不断变更自己的UID，如果发现某一次变更后通过了权限检查，则说明存在inline UID检查\nInstrumenting Targets（RQ5）\n作者使用了Frida动态Hook框架优点是能够兼容不同的系统，而无需修改安卓源码，能够满足对一些闭源的OEM厂商的测试需求。\nModeling of Permission Mapping（RQ6）\n作者想要得到上图中List2中的结果作为输出，这可以使用RQ4中的方法来得到具体UID值的检查以及具体权限检查的两种情况，但是对于UID是否等于入参的情况，作者通过不断变更入参的方式来检查。\n代码分析\n从Github项目可以看到DYNAMO的源码3\nFootnotes\n\n\nBringing Balance to the Force Dynamic Analysis of the Android Application Framework ↩\n\n\n论文笔记:《Bringing Balance to the Force Dynamic Analysis of the Android Application Framework》 ↩\n\n\nGithub - abdawoud/Dynamo ↩', 'author': {'login': 'jygzyc'}, 'category': {'name': '0101-Android'}, 'labels': {'nodes': [{'name': '010102-Framework安全'}]}, 'comments': {'nodes': []}}, {'title': '留言板', 'number': 9, 'url': 'https://github.com/jygzyc/notes/discussions/9', 'createdAt': '2024-04-21T13:08:27Z', 'lastEditedAt': '2024-04-22T16:15:27Z', 'updatedAt': '2024-05-15T06:39:49Z', 'body': '<!-- message -->\r\n搞一个留言板方便交流\r\n', 'bodyText': '搞一个留言板方便交流', 'author': {'login': 'jygzyc'}, 'category': {'name': '0002-留言'}, 'labels': {'nodes': [{'name': 'site_message'}]}, 'comments': {'nodes': [{'body': '这里是一条测试评论', 'author': {'login': 'jygzyc'}}]}}, {'title': '半小时学习Rust', 'number': 8, 'url': 'https://github.com/jygzyc/notes/discussions/8', 'createdAt': '2024-04-19T03:02:41Z', 'lastEditedAt': '2024-05-24T08:31:28Z', 'updatedAt': '2024-05-24T08:31:28Z', 'body': '\r\n> 个人笔记：为了理解rust，添加了一些tip\r\n\r\n为了提高编程语言的流畅性，人们必须阅读大量编程语言的相关知识。但如果你不知道它的含义，你怎么能读这么多呢？\r\n在本文中，我不会专注于一两个概念，而是尝试尽可能多地浏览 Rust 片段，并解释它们包含的关键字和符号的含义。\r\n准备好了吗？冲！[^1] [^2] （根据情况更新笔记）\r\n\r\n`let`引入了一个变量绑定：\r\n\r\n```rust\r\nlet x; // 声明 "x"\r\nx = 42; // 将 42 分配给“x”\r\n```\r\n\r\n也可以写成一行：\r\n\r\n```rust\r\nlet x = 42;\r\n```\r\n\r\n您可以使用`:`显式地指定变量的类型，这是类型注解：\r\n\r\n```rust\r\nlet x: i32; // `i32` 是一个有符号的 32 位整数\r\nx = 42;\r\n// 有 i8、i16、i32、i64、i128 表示其他位数的有符号整数\r\n// 还有 u8、u16、u32、u64、u128 表示无符号整数\r\n```\r\n\r\n这也可以写成一行：\r\n\r\n```rust\r\nlet x: i32 = 42;\r\n```\r\n\r\n如果您声明一个变量并稍后对其进行初始化，在初始化之前编译器将阻止您使用它。\r\n\r\n```rust\r\nlet x;\r\nfoobar(x); // error: borrow of possibly-uninitialized variable: `x`\r\nx = 42;\r\n```\r\n\r\n下面这样做是完全没问题的：\r\n\r\n```rust\r\nlet x;\r\nx = 42;\r\nfoobar(x); // `x` 的类型可以推断出来\r\n```\r\n\r\n下划线`_`是一个特殊名称——或者更确切地说，是“缺乏名称”。`_`基本上意味着扔掉一些东西：\r\n\r\n```rust\r\n// *什么也没做*，因为 42 是一个常数\r\nlet _ = 42;\r\n\r\n// 这调用了 `get_thing` 但丢弃了它的结果\r\nlet _ = get_thing();\r\n```\r\n\r\n以下划线“开头”的名称是常规名称，有一点特殊的是，编译器不会警告它们未被使用\r\n\r\n```rust\r\n// 我们最终可能会使用 `_x`，但我们的代码仍在编写中\r\n// 我们现在只想摆脱编译器的警告。\r\nlet _x = 42；\r\n```\r\n\r\n可以引入具有相同名称的单独绑定，它会“隐藏”前一个变量绑定：\r\n\r\n```rust\r\nlet x = 13;\r\nlet x = x + 3;\r\n// 该行之后使用“x”仅引用第二个“x”，\r\n// 第一个“x”不再存在。\r\n```\r\n\r\nRust 有`tuple`——元组类型，您可以将其视为“固定长度的不同类型的集合”。\r\n\r\n```rust\r\nlet pair = (\'a\', 17);\r\npair.0; // this is \'a\'\r\npair.1; // this is 17\r\n```\r\n\r\n如果我们真的想给元组中变量增加类型注解，可以用`pair`：\r\n\r\n```rust\r\nlet pair: (char, i32) = (\'a\', 17);\r\n```\r\n\r\n元组可以通过赋值的方式被“解构”(destructured)，这意味着它们被分解为各自的字段：\r\n\r\n```rust\r\nlet (some_char, some_int) = (\'a\', 17);\r\n// 现在，`some_char` 是 \'a\'，`some_int` 是 17\r\n```\r\n\r\n当函数返回元组类型时特别管用：\r\n\r\n```rust\r\nlet (left, right) = slice.split_at(middle);\r\n```\r\n\r\n当然，在解构一个元组时，可以用 `_` 舍弃掉一部分字段：\r\n\r\n```rust\r\nlet (_, right) = slice.split_at(middle);\r\n```\r\n\r\n分号表示语句的结尾：\r\n\r\n```rust\r\nlet x = 3;\r\nlet y = 5;\r\nlet z = y + x;\r\n```\r\n\r\n这意味着语句可以写成多行：\r\n\r\n```rust\r\nlet x = vec![1, 2, 3, 4, 5, 6, 7, 8]\r\n    .iter()\r\n    .map(|x| x + 3)\r\n    .fold(0, |x, y| x + y);\r\n```\r\n\r\n（我们稍后会讨论这些代码的实际含义）。\r\n\r\n`fn`用来声明一个函数。\r\n\r\n下面是一个 void 函数：\r\n\r\n```rust\r\nfn greet() {\r\n    println!("Hi there!");\r\n}\r\n```\r\n\r\n下面是一个返回 32 位有符号整数的函数。使用箭头指示其返回类型：\r\n\r\n```rust\r\nfn fair_dice_roll() -> i32 {\r\n    4\r\n}\r\n```\r\n\r\n一对大括号声明一个块，它有自己的作用域：\r\n\r\n```rust\r\n// 这首先会打印“in”，然后是“out”\r\nfn main() {\r\n    let x = "out";\r\n    {\r\n        // 这是一个不同的“x”\r\n        let x = "in";\r\n        println!("{}", x);\r\n    }\r\n    println!("{}", x);\r\n}\r\n```\r\n\r\n“块”也是表达式，意味着它们的计算结果为一个值。\r\n\r\n```rust\r\n// 这条语句\r\nlet x = 42;\r\n\r\n// 和这条语句等价\r\nlet x = { 42 };\r\n```\r\n\r\n在一个块中，可以有多条语句：\r\n\r\n```rust\r\nlet x = {\r\n    let y = 1; // 第一个声明\r\n    let z = 2; // 第二个声明\r\n    y + z // 这是 *结尾*，即整个块的计算结果\r\n};\r\n```\r\n\r\n这就是为什么“省略函数末尾的分号”与“返回这个值”相同，即，下面的两个函数是等效的：\r\n\r\n```rust\r\nfn fair_dice_roll() -> i32 {\r\n    return 4;\r\n}\r\n\r\nfn fair_dice_roll() -> i32 {\r\n    4\r\n}\r\n```\r\n\r\n`if` 条件也可以是表达式：\r\n\r\n```rust\r\nfn fair_dice_roll() -> i32 {\r\n    if feeling_lucky {\r\n        6\r\n    } else {\r\n        4\r\n    }\r\n}\r\n```\r\n\r\n`match` 也是一个表达式：\r\n\r\n```rust\r\nfn fair_dice_roll() -> i32 {\r\n    match feeling_lucky {\r\n        true => 6,\r\n        false => 4,\r\n    }\r\n}\r\n```\r\n\r\n“点”`.`通常用于访问值的字段：\r\n\r\n```rust\r\nlet a = (10, 20);\r\na.0; // this is 10\r\n\r\nlet amos = get_some_struct();\r\namos.nickname; // this is "fasterthanlime"\r\n```\r\n\r\n或者调用方法：\r\n\r\n```rust\r\nlet nick = "fasterthanlime";\r\nnick.len(); // this is 14\r\n```\r\n\r\n“双冒号”`::`与此类似，但它的操作对象是命名空间。\r\n在此示例中，`std`是一个 crate（相当于一个库），`cmp`是一个模块（相当于一个源文件），`min`是一个函数：  \r\n\r\n```rust\r\nlet least = std::cmp::min(3, 8); // this is 3\r\n```\r\n\r\n`use`指令可用于将其他命名空间名称引入到当前：\r\n\r\n```rust\r\nuse std::cmp::min;\r\n\r\nlet least = min(7, 1); // this is 1\r\n```\r\n\r\n在`use`指令中，大括号还有另一个含义：它们是一组名称（`glob`）。如果我们想用`use`同时导入`min`和`max`，那么可以： \r\n\r\n```rust\r\n// this works:\r\nuse std::cmp::min;\r\nuse std::cmp::max;\r\n\r\n// this also works:\r\nuse std::cmp::{min, max};\r\n\r\n// this also works!\r\nuse std::{cmp::min, cmp::max};\r\n```\r\n\r\n通配符 `*` 允许您导入命名空间下所有名称：\r\n\r\n```rust\r\n// 这不仅将“min”和“max”引入代码中，而且并包括模块中的其他名称\r\nuse std::cmp::*;\r\n```\r\n\r\n类型也是命名空间，方法可以作为常规函数调用：\r\n\r\n```rust\r\nlet x = "amos".len(); // this is 4\r\nlet x = str::len("amos"); // this is also 4\r\n```\r\n\r\n`str`是基本类型(primitive type)，但默认命名空间下也有许多非基本类型。\r\n\r\n```rust\r\n// `Vec` 是一个常规结构，而不是原始类型\r\nlet v = Vec::new();\r\n\r\n// 这是和上述完全等价的代码，但具有访问到“Vec”的*完整*路径\r\nlet v = std::vec::Vec::new();\r\n```\r\n\r\n这是因为 Rust 会在每个模块的开头插入它：\r\n\r\n```rust\r\nuse std::prelude::v1::*;\r\n```\r\n\r\n（这反过来又会导入其他许多符号，如`Vec`、`String`、`Option`和`Result`）。\r\n\r\n结构体使用`struct`关键字声明：\r\n\r\n```rust\r\nstruct Vec2 {\r\n    x: f64, // 64 位浮点，又名“双精度”\r\n    y: f64,\r\n}\r\n```\r\n\r\n它们可以使用“结构体文字”进行初始化：\r\n\r\n```rust\r\nlet v1 = Vec2 { x: 1.0, y: 3.0 };\r\nlet v2 = Vec2 { y: 2.0, x: 4.0 };\r\n// the order does not matter, only the names do\r\n```\r\n\r\n有一个快捷方式可以从另一个结构体初始化剩余字段：\r\n\r\n```rust\r\nlet v3 = Vec2 {\r\n    x: 14.0,\r\n    ..v2\r\n};\r\n```\r\n\r\n这被称为“结构更新语法”（struct update syntax），只能发生在最后一个位置，并且不能后跟逗号。\r\n请注意，“剩余字段”可以是“所有字段”：\r\n\r\n```rust\r\nlet v4 = Vec2 { ..v3 };\r\n```\r\n\r\n结构体和元组一样，可以被解构。\r\n下面是一个有效的`let`模式：\r\n\r\n```rust\r\nlet (left, right) = slice.split_at(middle);\r\n```\r\n\r\n也可以这样：\r\n\r\n```rust\r\nlet v = Vec2 { x: 3.0, y: 6.0 };\r\nlet Vec2 { x, y } = v;\r\n// `x` is now 3.0, `y` is now `6.0`\r\n```\r\n\r\n还有这个：\r\n\r\n```rust\r\nlet Vec2 { x, .. } = v;\r\n// this throws away `v.y`\r\n```\r\n\r\n`let`模式可以用作`if`中的条件：\r\n\r\n```rust\r\nstruct Number {\r\n    odd: bool,\r\n    value: i32,\r\n}\r\n\r\nfn main() {\r\n    let one = Number { odd: true, value: 1 };\r\n    let two = Number { odd: false, value: 2 };\r\n    print_number(one);\r\n    print_number(two);\r\n}\r\n\r\nfn print_number(n: Number) {\r\n    if let Number { odd: true, value } = n {\r\n        println!("Odd number: {}", value);\r\n    } else if let Number { odd: false, value } = n {\r\n        println!("Even number: {}", value);\r\n    }\r\n}\r\n\r\n// this prints:\r\n// Odd number: 1\r\n// Even number: 2\r\n```\r\n\r\n`match`匹配也是一种模式，就像`if let`:\r\n\r\n```rust\r\nfn print_number(n: Number) {\r\n    match n {\r\n        Number { odd: true, value } => println!("Odd number: {}", value),\r\n        Number { odd: false, value } => println!("Even number: {}", value),\r\n    }\r\n}\r\n\r\n// this prints the same as before\r\n```\r\n\r\n`match`必须是详尽的，至少需要一个分支来进行匹配\r\n\r\n```rust\r\nfn print_number(n: Number) {\r\n    match n {\r\n        Number { value: 1, .. } => println!("One"),\r\n        Number { value: 2, .. } => println!("Two"),\r\n        Number { value, .. } => println!("{}", value),\r\n        // if that last arm didn\'t exist, we would get a compile-time error\r\n    }\r\n}\r\n```\r\n\r\n如果这很麻烦，可以用`_`来匹配所有模式：\r\n\r\n```rust\r\nfn print_number(n: Number) {\r\n    match n.value {\r\n        1 => println!("One"),\r\n        2 => println!("Two"),\r\n        _ => println!("{}", n.value),\r\n    }\r\n}\r\n```\r\n\r\n您可以在自己的类型上声明方法：\r\n\r\n```rust\r\nstruct Number {\r\n    odd: bool,\r\n    value: i32,\r\n}\r\n\r\nimpl Number {\r\n    fn is_strictly_positive(self) -> bool {\r\n        self.value > 0\r\n    }\r\n}\r\n```\r\n\r\n并像往常一样使用它们：\r\n\r\n```rust\r\nfn main() {\r\n    let minus_two = Number {\r\n        odd: false,\r\n        value: -2,\r\n    };\r\n    println!("positive? {}", minus_two.is_strictly_positive());\r\n    // this prints "positive? false"\r\n}\r\n```\r\n\r\n默认情况下，变量绑定是不可变的，这意味着它的变量值不能改变：\r\n\r\n```rust\r\nfn main() {\r\n    let n = Number {\r\n        odd: true,\r\n        value: 17,\r\n    };\r\n    n.odd = false; // error: cannot assign to `n.odd`,\r\n                   // as `n` is not declared to be mutable\r\n}\r\n```\r\n\r\n而且它们不能被赋值更改：\r\n\r\n```rust\r\nfn main() {\r\n    let n = Number {\r\n        odd: true,\r\n        value: 17,\r\n    };\r\n    n = Number {\r\n        odd: false,\r\n        value: 22,\r\n    }; // error: cannot assign twice to immutable variable `n`\r\n}\r\n```\r\n\r\n`mut`允许变量绑定可更改：\r\n\r\n```rust\r\nfn main() {\r\n    let mut n = Number {\r\n        odd: true,\r\n        value: 17,\r\n    }\r\n    n.value = 19; // all good\r\n}\r\n```\r\n\r\n`trait`是多种类型拥有的共同点：\r\n\r\n```rust\r\ntrait Signed {\r\n    fn is_strictly_negative(self) -> bool;\r\n}\r\n```\r\n\r\n您可以实现：\r\n\r\n- 为任意类型实现你自己定义的trait\r\n- 为你的类型实现任意类型的trait\r\n- 不允许为别人的类型实现别人的trait\r\n\r\n这些被称为“孤立规则”(orphan rules)。\r\n\r\n下面是自定义trait在自定义类型上的实现：\r\n\r\n```rust\r\nimpl Signed for Number {\r\n    fn is_strictly_negative(self) -> bool {\r\n        self.value < 0\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let n = Number { odd: false, value: -44 };\r\n    println!("{}", n.is_strictly_negative()); // prints "true"\r\n}\r\n```\r\n\r\n我们在外部类型（甚至是基本类型）上的实现的自定义trait：\r\n\r\n```rust\r\nimpl Signed for i32 {\r\n    fn is_strictly_negative(self) -> bool {\r\n        self < 0\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let n: i32 = -44;\r\n    println!("{}", n.is_strictly_negative()); // prints "true"\r\n}\r\n```\r\n\r\n自定义类型的外部trait：\r\n\r\n```rust\r\n// `Neg` 特性用于重载 `-`，\r\n// 一元减运算符。\r\nimpl std::ops::Neg for Number {\r\n    type Output = Number;\r\n\r\n    fn neg(self) -> Number {\r\n        Number {\r\n            value: -self.value,\r\n            odd: self.odd,\r\n        }        \r\n    }\r\n}\r\n\r\nfn main() {\r\n    let n = Number { odd: true, value: 987 };\r\n    let m = -n; // this is only possible because we implemented `Neg`\r\n    println!("{}", m.value); // prints "-987"\r\n}\r\n```\r\n\r\n`impl`块总是用来为类型实现方法，因此，在该块内，`Self`可以指代该类型:\r\n\r\n```rust\r\nimpl std::ops::Neg for Number {\r\n    type Output = Self;\r\n\r\n    fn neg(self) -> Self {\r\n        Self {\r\n            value: -self.value,\r\n            odd: self.odd,\r\n        }        \r\n    }\r\n}\r\n```\r\n\r\n有些trait是“标记”——它们并不是说类型实现了某些方法，而是说可以用类型完成某些事情。\r\n例如`i32`实现`Copy` trait(简单地讲，`i32`是可复制的)，所以下面的代码工作正常:\r\n\r\n```rust\r\nfn main() {\r\n    let a: i32 = 15;\r\n    let b = a; // `a` is copied\r\n    let c = a; // `a` is copied again\r\n}\r\n```\r\n\r\n这也是正常的：\r\n\r\n```rust\r\nfn print_i32(x: i32) {\r\n    println!("x = {}", x);\r\n}\r\n\r\nfn main() {\r\n    let a: i32 = 15;\r\n    print_i32(a); // `a` is copied\r\n    print_i32(a); // `a` is copied again\r\n}\r\n```\r\n\r\n但`Number`类型没有实现`Copy`，所以下面的代码不起作用：\r\n\r\n```rust\r\nfn main() {\r\n    let n = Number { odd: true, value: 51 };\r\n    let m = n; // `n` is moved into `m`\r\n    let o = n; // error: use of moved value: `n`\r\n}\r\n```\r\n\r\n这也不行：\r\n\r\n```rust\r\nfn print_number(n: Number) {\r\n    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);\r\n}\r\n\r\nfn main() {\r\n    let n = Number { odd: true, value: 51 };\r\n    print_number(n); // `n` is moved\r\n    print_number(n); // error: use of moved value: `n`\r\n}\r\n```\r\n\r\n但如果采用不可变的引用`print_number`，就是可行的：\r\n\r\n```rust\r\nfn print_number(n: &Number) {\r\n    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);\r\n}\r\n\r\nfn main() {\r\n    let n = Number { odd: true, value: 51 };\r\n    print_number(&n); // `n` is borrowed for the time of the call\r\n    print_number(&n); // `n` is borrowed again\r\n}\r\n```\r\n\r\n如果变量被声明为可变的，则函数参数使用可变引用也可以工作:\r\n\r\n```rust\r\nfn invert(n: &mut Number) {\r\n    n.value = -n.value;\r\n}\r\nfn print_number(n: &Number) {\r\n    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);\r\n}\r\nfn main() {\r\n    // this time, `n` is mutable\r\n    let mut n = Number { odd: true, value: 51 };\r\n    print_number(&n);\r\n    invert(&mut n); // `n is borrowed mutably - everything is explicit\r\n    print_number(&n);\r\n}\r\n```\r\n\r\nTrait 方法中的`self`参数可以使用引用，也可以使用不可变引用\r\n\r\n```rust\r\nimpl std::clone::Clone for Number {\r\n    fn clone(&self) -> Self {\r\n        Self { ..*self }\r\n    }\r\n```\r\n\r\n当调用trait的方法时，receiver隐式地被借用\r\n\r\n```rust\r\nfn main() {\r\n    let n = Number { odd: true, value: 51 };\r\n    let mut m = n.clone();\r\n    m.value += 100;\r\n    \r\n    print_number(&n);\r\n    print_number(&m);\r\n}\r\n```\r\n\r\n强调一点，下面的代码是等价的:\r\n\r\n```rust\r\nlet m = n.clone();\r\n\r\nlet m = std::clone::Clone::clone(&n);\r\n```\r\n\r\n像 `Copy` 这样的 Marker traits 是没有实现原对象trait方法的\r\n\r\n```rust\r\n// note: `Copy` requires that `Clone` is implemented too\r\nimpl std::clone::Clone for Number {\r\n    fn clone(&self) -> Self {\r\n        Self { ..*self }\r\n    }\r\n}\r\n\r\nimpl std::marker::Copy for Number {}\r\n```\r\n\r\n现在`Clone`仍然可以使用:\r\n\r\n```rust\r\nfn main() {\r\n    let n = Number { odd: true, value: 51 };\r\n    let m = n.clone();\r\n    let o = n.clone();\r\n}\r\n```\r\n\r\n但是`Number`的值不会被转移了\r\n\r\n```rust\r\nfn main() {\r\n    let n = Number { odd: true, value: 51 };\r\n    let m = n; // `m` is a copy of `n`\r\n    let o = n; // same. `n` is neither moved nor borrowed.\r\n}\r\n```\r\n\r\n一些`trait`太通用了，我们可以通过derive属性自动实现它们:\r\n\r\n```rust\r\n#[derive(Clone, Copy)]\r\nstruct Number {\r\n    odd: bool,\r\n    value: i32,\r\n}\r\n\r\n// this expands to `impl Clone for Number` and `impl Copy for Number` blocks.\r\n```\r\n\r\n函数可以是泛型的:\r\n\r\n```rust\r\nfn foobar<T>(arg: T) {\r\n    // do something with `arg`\r\n}\r\n```\r\n\r\n它们可以有多个“类型参数”，类型参数用在函数声明和函数体中，用来替代具体的类型:\r\n\r\n```rust\r\nfn foobar<L, R>(left: L, right: R) {\r\n    // do something with `left` and `right`\r\n}\r\n```\r\n\r\n类型参数通常有“约束”，所以你可以用它做一些额外的事情。\r\n\r\n最简单的约束就是trait名称:\r\n\r\n```rust\r\nfn print<T: Display>(value: T) {\r\n    println!("value = {}", value);\r\n}\r\n\r\nfn print<T: Debug>(value: T) {\r\n    println!("value = {:?}", value);\r\n}\r\n```\r\n\r\n类型参数约束可以有更长的语法：\r\n\r\n```rust\r\nfn print<T>(value: T)\r\nwhere\r\n    T: Display,\r\n{\r\n    println!("value = {}", value);\r\n}\r\n```\r\n\r\n约束还可以变得更加复杂，比如要求类型参数要实现多种trait:\r\n\r\n```rust\r\nuse std::fmt::Debug;\r\n\r\nfn compare<T>(left: T, right: T)\r\nwhere\r\n    T: Debug + PartialEq,\r\n{\r\n    println!("{:?} {} {:?}", left, if left == right { "==" } else { "!=" }, right);\r\n}\r\n\r\nfn main() {\r\n    compare("tea", "coffee");\r\n    // prints: "tea" != "coffee"\r\n}\r\n```\r\n\r\n泛型函数可以被当作一个命名空间，包含无穷多个不同具体类型的函数。\r\n\r\n类似`crate`、`module`和`type`，泛型函数可以使用`::`导航:\r\n\r\n```rust\r\nfn main() {\r\n    use std::any::type_name;\r\n    println!("{}", type_name::<i32>()); // prints "i32"\r\n    println!("{}", type_name::<(f64, char)>()); // prints "(f64, char)"\r\n}\r\n```\r\n\r\n这被亲切地称之为[turbofish 语法](https://turbo.fish/)，因为`::<>`看起来像条鱼。:)\r\n\r\n结构体也可以是泛型的:\r\n\r\n```rust\r\nstruct Pair<T> {\r\n    a: T,\r\n    b: T,\r\n}\r\n\r\nfn print_type_name<T>(_val: &T) {\r\n    println!("{}", std::any::type_name::<T>());\r\n}\r\n\r\nfn main() {\r\n    let p1 = Pair { a: 3, b: 9 };\r\n    let p2 = Pair { a: true, b: false };\r\n    print_type_name(&p1); // prints "Pair<i32>"\r\n    print_type_name(&p2); // prints "Pair<bool>"\r\n}\r\n```\r\n\r\n标准库中的类型`Vec`(即分配在堆上的数组)就是泛型实现的:\r\n\r\n```rust\r\nfn main() {\r\n    let mut v1 = Vec::new();\r\n    v1.push(1);\r\n    let mut v2 = Vec::new();\r\n    v2.push(false);\r\n    print_type_name(&v1); // prints "Vec<i32>"\r\n    print_type_name(&v2); // prints "Vec<bool>"\r\n}\r\n```\r\n\r\n谈到Vec，有个宏(macro)可以通过字面方式声明Vec变量:\r\n\r\n> Tip：Rust中可以使用`!`定义一个宏，例如`println!`这样的宏；也可以使用上文中`#[derive]`这样的方式进行自定义\r\n\r\n\r\n```rust\r\nfn main() {\r\n    let v1 = vec![1, 2, 3];\r\n    let v2 = vec![true, false, true];\r\n    print_type_name(&v1); // prints "Vec<i32>"\r\n    print_type_name(&v2); // prints "Vec<bool>"\r\n}\r\n```\r\n\r\n类似`name!()`、`name![]`、`name!{}`都是调用宏的方式，宏会被展开成正常的代码。\r\n\r\n事实上，`println`就是一个宏:\r\n\r\n```rust\r\nfn main() {\r\n    println!("{}", "Hello there!");\r\n}\r\n```\r\n\r\n其展开代码和下面的代码功能一样:\r\n\r\n```rust\r\nfn main() {\r\n    use std::io::{self, Write};\r\n    io::stdout().lock().write_all(b"Hello there!\\n").unwrap();\r\n}\r\n```\r\n\r\n`panic`也是一个宏，用来直接停止代码执行并抛出错误信息，同时附带文件名和代码行号（需启用该功能）\r\n\r\n```rust\r\nfn main() {\r\n    panic!("This panics");\r\n}\r\n// output: thread \'main\' panicked at \'This panics\', src/main.rs:3:5\r\n```\r\n\r\n有些方法也会出现`panic`。例如，`Option`类型可以包含某些内容，也可以不包含任何内容。如果对它调用`.unwrap()`，并且它不包含任何内容，则会执行`panic`宏：\r\n\r\n```rust\r\nfn main() {\r\n    let o1: Option<i32> = Some(128);\r\n    o1.unwrap(); // this is fine\r\n\r\n    let o2: Option<i32> = None;\r\n    o2.unwrap(); // this panics!\r\n}\r\n\r\n// output: thread \'main\' panicked at \'called `Option::unwrap()` on a `None` value\', src/libcore/option.rs:378:21\r\n```\r\n\r\n> Tip：Panic 是 Rust 中的一个错误处理机制，当程序遇到无法处理的错误时，它会立即终止当前线程的执行，并开始回溯(unwinding)过程。一般如下情况会出现 Panic:\r\n>\r\n> 1. 显式调用`panic!`宏。\r\n> 2. 某些运行时检查失败，例如数组越界。 [^3]\r\n\r\n`Option`并不是一个结构体，而是一个枚举类型(enum)，它包含两个值:\r\n\r\n```rust\r\nenum Option<T> {\r\n    None,\r\n    Some(T),\r\n}\r\n\r\nimpl<T> Option<T> {\r\n    fn unwrap(self) -> T {\r\n        // enums variants can be used in patterns:\r\n        match self {\r\n            Self::Some(t) => t,\r\n            Self::None => panic!(".unwrap() called on a None option"),\r\n        }\r\n    }\r\n}\r\n\r\nuse self::Option::{None, Some};\r\n\r\nfn main() {\r\n    let o1: Option<i32> = Some(128);\r\n    o1.unwrap(); // this is fine\r\n\r\n    let o2: Option<i32> = None;\r\n    o2.unwrap(); // this panics!\r\n}\r\n\r\n// output: thread \'main\' panicked at \'.unwrap() called on a None option\', src/main.rs:11:27\r\n```\r\n\r\n`Result`也是一个枚举类型。它既可以包含某些结果，也可以包含一个error:\r\n\r\n```rust\r\nenum Result<T, E> {\r\n    Ok(T),\r\n    Err(E),\r\n}\r\n```\r\n\r\n如果包含error，unwrapped时也会触发`panic`。\r\n\r\n变量绑定存在“生命周期”:\r\n\r\n```rust\r\nfn main() {\r\n    // `x` doesn\'t exist yet\r\n    {\r\n        let x = 42; // `x` starts existing\r\n        println!("x = {}", x);\r\n        // `x` stops existing\r\n    }\r\n    // `x` no longer exists\r\n}\r\n```\r\n\r\n类似地，引用同样存在生命周期:\r\n\r\n```rust\r\nfn main() {\r\n    // `x` doesn\'t exist yet\r\n    {\r\n        let x = 42; // `x` starts existing\r\n        let x_ref = &x; // `x_ref` starts existing - it borrows `x`\r\n        println!("x_ref = {}", x_ref);\r\n        // `x_ref` stops existing\r\n        // `x` stops existing\r\n    }\r\n    // `x` no longer exists\r\n}\r\n```\r\n\r\n引用的生命周期无法超过它借用的变量的生命周期:\r\n\r\n```rust\r\nfn main() {\r\n    let x_ref = {\r\n        let x = 42;\r\n        &x\r\n    };\r\n    println!("x_ref = {}", x_ref);\r\n    // error: `x` does not live long enough\r\n}\r\n```\r\n\r\n一个变量可以不可变地引用多次:\r\n\r\n```rust\r\nfn main() {\r\n    let x = 42;\r\n    let x_ref1 = &x;\r\n    let x_ref2 = &x;\r\n    let x_ref3 = &x;\r\n    println!("{} {} {}", x_ref1, x_ref2, x_ref3);\r\n}\r\n```\r\n\r\n在借用的时候，变量不能被修改:\r\n\r\n```rust\r\nfn main() {\r\n    let mut x = 42;\r\n    let x_ref = &x;\r\n    x = 13;\r\n    println!("x_ref = {}", x_ref);\r\n    // error: cannot assign to `x` because it is borrowed\r\n}\r\n```\r\n\r\n当不可变地借用时，不能同时可变地的借用:\r\n\r\n> Tip：即不能对一个变量同时创建不可变和可变的引用\r\n\r\n```rust\r\nfn main() {\r\n    let mut x = 42;\r\n    let x_ref1 = &x;\r\n    let x_ref2 = &mut x;\r\n    // error: cannot borrow `x` as mutable because it is also borrowed as immutable\r\n    println!("x_ref1 = {}", x_ref1);\r\n}\r\n```\r\n\r\n函数参数中的引用同样存在生命周期：\r\n\r\n```rust\r\nfn print(x: &i32) {\r\n    // `x` is borrowed (from the outside) for the\r\n    // entire time this function is called.\r\n}\r\n```\r\n\r\n\r\n[^1]: [A half-hour to learn Rust](https://fasterthanli.me/articles/a-half-hour-to-learn-rust)\r\n[^2]: [Rust半小时教程](https://colobu.com/2020/03/05/A-half-hour-to-learn-Rust/)\r\n[^3]: [深入探索 Rust 中的 Panic 机制](https://juejin.cn/post/7314144983018782761)', 'bodyText': '个人笔记：为了理解rust，添加了一些tip\n\n为了提高编程语言的流畅性，人们必须阅读大量编程语言的相关知识。但如果你不知道它的含义，你怎么能读这么多呢？\n在本文中，我不会专注于一两个概念，而是尝试尽可能多地浏览 Rust 片段，并解释它们包含的关键字和符号的含义。\n准备好了吗？冲！1 2 （根据情况更新笔记）\nlet引入了一个变量绑定：\nlet x; // 声明 "x"\nx = 42; // 将 42 分配给“x”\n也可以写成一行：\nlet x = 42;\n您可以使用:显式地指定变量的类型，这是类型注解：\nlet x: i32; // `i32` 是一个有符号的 32 位整数\nx = 42;\n// 有 i8、i16、i32、i64、i128 表示其他位数的有符号整数\n// 还有 u8、u16、u32、u64、u128 表示无符号整数\n这也可以写成一行：\nlet x: i32 = 42;\n如果您声明一个变量并稍后对其进行初始化，在初始化之前编译器将阻止您使用它。\nlet x;\nfoobar(x); // error: borrow of possibly-uninitialized variable: `x`\nx = 42;\n下面这样做是完全没问题的：\nlet x;\nx = 42;\nfoobar(x); // `x` 的类型可以推断出来\n下划线_是一个特殊名称——或者更确切地说，是“缺乏名称”。_基本上意味着扔掉一些东西：\n// *什么也没做*，因为 42 是一个常数\nlet _ = 42;\n\n// 这调用了 `get_thing` 但丢弃了它的结果\nlet _ = get_thing();\n以下划线“开头”的名称是常规名称，有一点特殊的是，编译器不会警告它们未被使用\n// 我们最终可能会使用 `_x`，但我们的代码仍在编写中\n// 我们现在只想摆脱编译器的警告。\nlet _x = 42；\n可以引入具有相同名称的单独绑定，它会“隐藏”前一个变量绑定：\nlet x = 13;\nlet x = x + 3;\n// 该行之后使用“x”仅引用第二个“x”，\n// 第一个“x”不再存在。\nRust 有tuple——元组类型，您可以将其视为“固定长度的不同类型的集合”。\nlet pair = (\'a\', 17);\npair.0; // this is \'a\'\npair.1; // this is 17\n如果我们真的想给元组中变量增加类型注解，可以用pair：\nlet pair: (char, i32) = (\'a\', 17);\n元组可以通过赋值的方式被“解构”(destructured)，这意味着它们被分解为各自的字段：\nlet (some_char, some_int) = (\'a\', 17);\n// 现在，`some_char` 是 \'a\'，`some_int` 是 17\n当函数返回元组类型时特别管用：\nlet (left, right) = slice.split_at(middle);\n当然，在解构一个元组时，可以用 _ 舍弃掉一部分字段：\nlet (_, right) = slice.split_at(middle);\n分号表示语句的结尾：\nlet x = 3;\nlet y = 5;\nlet z = y + x;\n这意味着语句可以写成多行：\nlet x = vec![1, 2, 3, 4, 5, 6, 7, 8]\n    .iter()\n    .map(|x| x + 3)\n    .fold(0, |x, y| x + y);\n（我们稍后会讨论这些代码的实际含义）。\nfn用来声明一个函数。\n下面是一个 void 函数：\nfn greet() {\n    println!("Hi there!");\n}\n下面是一个返回 32 位有符号整数的函数。使用箭头指示其返回类型：\nfn fair_dice_roll() -> i32 {\n    4\n}\n一对大括号声明一个块，它有自己的作用域：\n// 这首先会打印“in”，然后是“out”\nfn main() {\n    let x = "out";\n    {\n        // 这是一个不同的“x”\n        let x = "in";\n        println!("{}", x);\n    }\n    println!("{}", x);\n}\n“块”也是表达式，意味着它们的计算结果为一个值。\n// 这条语句\nlet x = 42;\n\n// 和这条语句等价\nlet x = { 42 };\n在一个块中，可以有多条语句：\nlet x = {\n    let y = 1; // 第一个声明\n    let z = 2; // 第二个声明\n    y + z // 这是 *结尾*，即整个块的计算结果\n};\n这就是为什么“省略函数末尾的分号”与“返回这个值”相同，即，下面的两个函数是等效的：\nfn fair_dice_roll() -> i32 {\n    return 4;\n}\n\nfn fair_dice_roll() -> i32 {\n    4\n}\nif 条件也可以是表达式：\nfn fair_dice_roll() -> i32 {\n    if feeling_lucky {\n        6\n    } else {\n        4\n    }\n}\nmatch 也是一个表达式：\nfn fair_dice_roll() -> i32 {\n    match feeling_lucky {\n        true => 6,\n        false => 4,\n    }\n}\n“点”.通常用于访问值的字段：\nlet a = (10, 20);\na.0; // this is 10\n\nlet amos = get_some_struct();\namos.nickname; // this is "fasterthanlime"\n或者调用方法：\nlet nick = "fasterthanlime";\nnick.len(); // this is 14\n“双冒号”::与此类似，但它的操作对象是命名空间。\n在此示例中，std是一个 crate（相当于一个库），cmp是一个模块（相当于一个源文件），min是一个函数：\nlet least = std::cmp::min(3, 8); // this is 3\nuse指令可用于将其他命名空间名称引入到当前：\nuse std::cmp::min;\n\nlet least = min(7, 1); // this is 1\n在use指令中，大括号还有另一个含义：它们是一组名称（glob）。如果我们想用use同时导入min和max，那么可以：\n// this works:\nuse std::cmp::min;\nuse std::cmp::max;\n\n// this also works:\nuse std::cmp::{min, max};\n\n// this also works!\nuse std::{cmp::min, cmp::max};\n通配符 * 允许您导入命名空间下所有名称：\n// 这不仅将“min”和“max”引入代码中，而且并包括模块中的其他名称\nuse std::cmp::*;\n类型也是命名空间，方法可以作为常规函数调用：\nlet x = "amos".len(); // this is 4\nlet x = str::len("amos"); // this is also 4\nstr是基本类型(primitive type)，但默认命名空间下也有许多非基本类型。\n// `Vec` 是一个常规结构，而不是原始类型\nlet v = Vec::new();\n\n// 这是和上述完全等价的代码，但具有访问到“Vec”的*完整*路径\nlet v = std::vec::Vec::new();\n这是因为 Rust 会在每个模块的开头插入它：\nuse std::prelude::v1::*;\n（这反过来又会导入其他许多符号，如Vec、String、Option和Result）。\n结构体使用struct关键字声明：\nstruct Vec2 {\n    x: f64, // 64 位浮点，又名“双精度”\n    y: f64,\n}\n它们可以使用“结构体文字”进行初始化：\nlet v1 = Vec2 { x: 1.0, y: 3.0 };\nlet v2 = Vec2 { y: 2.0, x: 4.0 };\n// the order does not matter, only the names do\n有一个快捷方式可以从另一个结构体初始化剩余字段：\nlet v3 = Vec2 {\n    x: 14.0,\n    ..v2\n};\n这被称为“结构更新语法”（struct update syntax），只能发生在最后一个位置，并且不能后跟逗号。\n请注意，“剩余字段”可以是“所有字段”：\nlet v4 = Vec2 { ..v3 };\n结构体和元组一样，可以被解构。\n下面是一个有效的let模式：\nlet (left, right) = slice.split_at(middle);\n也可以这样：\nlet v = Vec2 { x: 3.0, y: 6.0 };\nlet Vec2 { x, y } = v;\n// `x` is now 3.0, `y` is now `6.0`\n还有这个：\nlet Vec2 { x, .. } = v;\n// this throws away `v.y`\nlet模式可以用作if中的条件：\nstruct Number {\n    odd: bool,\n    value: i32,\n}\n\nfn main() {\n    let one = Number { odd: true, value: 1 };\n    let two = Number { odd: false, value: 2 };\n    print_number(one);\n    print_number(two);\n}\n\nfn print_number(n: Number) {\n    if let Number { odd: true, value } = n {\n        println!("Odd number: {}", value);\n    } else if let Number { odd: false, value } = n {\n        println!("Even number: {}", value);\n    }\n}\n\n// this prints:\n// Odd number: 1\n// Even number: 2\nmatch匹配也是一种模式，就像if let:\nfn print_number(n: Number) {\n    match n {\n        Number { odd: true, value } => println!("Odd number: {}", value),\n        Number { odd: false, value } => println!("Even number: {}", value),\n    }\n}\n\n// this prints the same as before\nmatch必须是详尽的，至少需要一个分支来进行匹配\nfn print_number(n: Number) {\n    match n {\n        Number { value: 1, .. } => println!("One"),\n        Number { value: 2, .. } => println!("Two"),\n        Number { value, .. } => println!("{}", value),\n        // if that last arm didn\'t exist, we would get a compile-time error\n    }\n}\n如果这很麻烦，可以用_来匹配所有模式：\nfn print_number(n: Number) {\n    match n.value {\n        1 => println!("One"),\n        2 => println!("Two"),\n        _ => println!("{}", n.value),\n    }\n}\n您可以在自己的类型上声明方法：\nstruct Number {\n    odd: bool,\n    value: i32,\n}\n\nimpl Number {\n    fn is_strictly_positive(self) -> bool {\n        self.value > 0\n    }\n}\n并像往常一样使用它们：\nfn main() {\n    let minus_two = Number {\n        odd: false,\n        value: -2,\n    };\n    println!("positive? {}", minus_two.is_strictly_positive());\n    // this prints "positive? false"\n}\n默认情况下，变量绑定是不可变的，这意味着它的变量值不能改变：\nfn main() {\n    let n = Number {\n        odd: true,\n        value: 17,\n    };\n    n.odd = false; // error: cannot assign to `n.odd`,\n                   // as `n` is not declared to be mutable\n}\n而且它们不能被赋值更改：\nfn main() {\n    let n = Number {\n        odd: true,\n        value: 17,\n    };\n    n = Number {\n        odd: false,\n        value: 22,\n    }; // error: cannot assign twice to immutable variable `n`\n}\nmut允许变量绑定可更改：\nfn main() {\n    let mut n = Number {\n        odd: true,\n        value: 17,\n    }\n    n.value = 19; // all good\n}\ntrait是多种类型拥有的共同点：\ntrait Signed {\n    fn is_strictly_negative(self) -> bool;\n}\n您可以实现：\n\n为任意类型实现你自己定义的trait\n为你的类型实现任意类型的trait\n不允许为别人的类型实现别人的trait\n\n这些被称为“孤立规则”(orphan rules)。\n下面是自定义trait在自定义类型上的实现：\nimpl Signed for Number {\n    fn is_strictly_negative(self) -> bool {\n        self.value < 0\n    }\n}\n\nfn main() {\n    let n = Number { odd: false, value: -44 };\n    println!("{}", n.is_strictly_negative()); // prints "true"\n}\n我们在外部类型（甚至是基本类型）上的实现的自定义trait：\nimpl Signed for i32 {\n    fn is_strictly_negative(self) -> bool {\n        self < 0\n    }\n}\n\nfn main() {\n    let n: i32 = -44;\n    println!("{}", n.is_strictly_negative()); // prints "true"\n}\n自定义类型的外部trait：\n// `Neg` 特性用于重载 `-`，\n// 一元减运算符。\nimpl std::ops::Neg for Number {\n    type Output = Number;\n\n    fn neg(self) -> Number {\n        Number {\n            value: -self.value,\n            odd: self.odd,\n        }        \n    }\n}\n\nfn main() {\n    let n = Number { odd: true, value: 987 };\n    let m = -n; // this is only possible because we implemented `Neg`\n    println!("{}", m.value); // prints "-987"\n}\nimpl块总是用来为类型实现方法，因此，在该块内，Self可以指代该类型:\nimpl std::ops::Neg for Number {\n    type Output = Self;\n\n    fn neg(self) -> Self {\n        Self {\n            value: -self.value,\n            odd: self.odd,\n        }        \n    }\n}\n有些trait是“标记”——它们并不是说类型实现了某些方法，而是说可以用类型完成某些事情。\n例如i32实现Copy trait(简单地讲，i32是可复制的)，所以下面的代码工作正常:\nfn main() {\n    let a: i32 = 15;\n    let b = a; // `a` is copied\n    let c = a; // `a` is copied again\n}\n这也是正常的：\nfn print_i32(x: i32) {\n    println!("x = {}", x);\n}\n\nfn main() {\n    let a: i32 = 15;\n    print_i32(a); // `a` is copied\n    print_i32(a); // `a` is copied again\n}\n但Number类型没有实现Copy，所以下面的代码不起作用：\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n; // `n` is moved into `m`\n    let o = n; // error: use of moved value: `n`\n}\n这也不行：\nfn print_number(n: Number) {\n    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);\n}\n\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    print_number(n); // `n` is moved\n    print_number(n); // error: use of moved value: `n`\n}\n但如果采用不可变的引用print_number，就是可行的：\nfn print_number(n: &Number) {\n    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);\n}\n\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    print_number(&n); // `n` is borrowed for the time of the call\n    print_number(&n); // `n` is borrowed again\n}\n如果变量被声明为可变的，则函数参数使用可变引用也可以工作:\nfn invert(n: &mut Number) {\n    n.value = -n.value;\n}\nfn print_number(n: &Number) {\n    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);\n}\nfn main() {\n    // this time, `n` is mutable\n    let mut n = Number { odd: true, value: 51 };\n    print_number(&n);\n    invert(&mut n); // `n is borrowed mutably - everything is explicit\n    print_number(&n);\n}\nTrait 方法中的self参数可以使用引用，也可以使用不可变引用\nimpl std::clone::Clone for Number {\n    fn clone(&self) -> Self {\n        Self { ..*self }\n    }\n当调用trait的方法时，receiver隐式地被借用\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    let mut m = n.clone();\n    m.value += 100;\n    \n    print_number(&n);\n    print_number(&m);\n}\n强调一点，下面的代码是等价的:\nlet m = n.clone();\n\nlet m = std::clone::Clone::clone(&n);\n像 Copy 这样的 Marker traits 是没有实现原对象trait方法的\n// note: `Copy` requires that `Clone` is implemented too\nimpl std::clone::Clone for Number {\n    fn clone(&self) -> Self {\n        Self { ..*self }\n    }\n}\n\nimpl std::marker::Copy for Number {}\n现在Clone仍然可以使用:\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n.clone();\n    let o = n.clone();\n}\n但是Number的值不会被转移了\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n; // `m` is a copy of `n`\n    let o = n; // same. `n` is neither moved nor borrowed.\n}\n一些trait太通用了，我们可以通过derive属性自动实现它们:\n#[derive(Clone, Copy)]\nstruct Number {\n    odd: bool,\n    value: i32,\n}\n\n// this expands to `impl Clone for Number` and `impl Copy for Number` blocks.\n函数可以是泛型的:\nfn foobar<T>(arg: T) {\n    // do something with `arg`\n}\n它们可以有多个“类型参数”，类型参数用在函数声明和函数体中，用来替代具体的类型:\nfn foobar<L, R>(left: L, right: R) {\n    // do something with `left` and `right`\n}\n类型参数通常有“约束”，所以你可以用它做一些额外的事情。\n最简单的约束就是trait名称:\nfn print<T: Display>(value: T) {\n    println!("value = {}", value);\n}\n\nfn print<T: Debug>(value: T) {\n    println!("value = {:?}", value);\n}\n类型参数约束可以有更长的语法：\nfn print<T>(value: T)\nwhere\n    T: Display,\n{\n    println!("value = {}", value);\n}\n约束还可以变得更加复杂，比如要求类型参数要实现多种trait:\nuse std::fmt::Debug;\n\nfn compare<T>(left: T, right: T)\nwhere\n    T: Debug + PartialEq,\n{\n    println!("{:?} {} {:?}", left, if left == right { "==" } else { "!=" }, right);\n}\n\nfn main() {\n    compare("tea", "coffee");\n    // prints: "tea" != "coffee"\n}\n泛型函数可以被当作一个命名空间，包含无穷多个不同具体类型的函数。\n类似crate、module和type，泛型函数可以使用::导航:\nfn main() {\n    use std::any::type_name;\n    println!("{}", type_name::<i32>()); // prints "i32"\n    println!("{}", type_name::<(f64, char)>()); // prints "(f64, char)"\n}\n这被亲切地称之为turbofish 语法，因为::<>看起来像条鱼。:)\n结构体也可以是泛型的:\nstruct Pair<T> {\n    a: T,\n    b: T,\n}\n\nfn print_type_name<T>(_val: &T) {\n    println!("{}", std::any::type_name::<T>());\n}\n\nfn main() {\n    let p1 = Pair { a: 3, b: 9 };\n    let p2 = Pair { a: true, b: false };\n    print_type_name(&p1); // prints "Pair<i32>"\n    print_type_name(&p2); // prints "Pair<bool>"\n}\n标准库中的类型Vec(即分配在堆上的数组)就是泛型实现的:\nfn main() {\n    let mut v1 = Vec::new();\n    v1.push(1);\n    let mut v2 = Vec::new();\n    v2.push(false);\n    print_type_name(&v1); // prints "Vec<i32>"\n    print_type_name(&v2); // prints "Vec<bool>"\n}\n谈到Vec，有个宏(macro)可以通过字面方式声明Vec变量:\n\nTip：Rust中可以使用!定义一个宏，例如println!这样的宏；也可以使用上文中#[derive]这样的方式进行自定义\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n    let v2 = vec![true, false, true];\n    print_type_name(&v1); // prints "Vec<i32>"\n    print_type_name(&v2); // prints "Vec<bool>"\n}\n类似name!()、name![]、name!{}都是调用宏的方式，宏会被展开成正常的代码。\n事实上，println就是一个宏:\nfn main() {\n    println!("{}", "Hello there!");\n}\n其展开代码和下面的代码功能一样:\nfn main() {\n    use std::io::{self, Write};\n    io::stdout().lock().write_all(b"Hello there!\\n").unwrap();\n}\npanic也是一个宏，用来直接停止代码执行并抛出错误信息，同时附带文件名和代码行号（需启用该功能）\nfn main() {\n    panic!("This panics");\n}\n// output: thread \'main\' panicked at \'This panics\', src/main.rs:3:5\n有些方法也会出现panic。例如，Option类型可以包含某些内容，也可以不包含任何内容。如果对它调用.unwrap()，并且它不包含任何内容，则会执行panic宏：\nfn main() {\n    let o1: Option<i32> = Some(128);\n    o1.unwrap(); // this is fine\n\n    let o2: Option<i32> = None;\n    o2.unwrap(); // this panics!\n}\n\n// output: thread \'main\' panicked at \'called `Option::unwrap()` on a `None` value\', src/libcore/option.rs:378:21\n\nTip：Panic 是 Rust 中的一个错误处理机制，当程序遇到无法处理的错误时，它会立即终止当前线程的执行，并开始回溯(unwinding)过程。一般如下情况会出现 Panic:\n\n显式调用panic!宏。\n某些运行时检查失败，例如数组越界。 3\n\n\nOption并不是一个结构体，而是一个枚举类型(enum)，它包含两个值:\nenum Option<T> {\n    None,\n    Some(T),\n}\n\nimpl<T> Option<T> {\n    fn unwrap(self) -> T {\n        // enums variants can be used in patterns:\n        match self {\n            Self::Some(t) => t,\n            Self::None => panic!(".unwrap() called on a None option"),\n        }\n    }\n}\n\nuse self::Option::{None, Some};\n\nfn main() {\n    let o1: Option<i32> = Some(128);\n    o1.unwrap(); // this is fine\n\n    let o2: Option<i32> = None;\n    o2.unwrap(); // this panics!\n}\n\n// output: thread \'main\' panicked at \'.unwrap() called on a None option\', src/main.rs:11:27\nResult也是一个枚举类型。它既可以包含某些结果，也可以包含一个error:\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n如果包含error，unwrapped时也会触发panic。\n变量绑定存在“生命周期”:\nfn main() {\n    // `x` doesn\'t exist yet\n    {\n        let x = 42; // `x` starts existing\n        println!("x = {}", x);\n        // `x` stops existing\n    }\n    // `x` no longer exists\n}\n类似地，引用同样存在生命周期:\nfn main() {\n    // `x` doesn\'t exist yet\n    {\n        let x = 42; // `x` starts existing\n        let x_ref = &x; // `x_ref` starts existing - it borrows `x`\n        println!("x_ref = {}", x_ref);\n        // `x_ref` stops existing\n        // `x` stops existing\n    }\n    // `x` no longer exists\n}\n引用的生命周期无法超过它借用的变量的生命周期:\nfn main() {\n    let x_ref = {\n        let x = 42;\n        &x\n    };\n    println!("x_ref = {}", x_ref);\n    // error: `x` does not live long enough\n}\n一个变量可以不可变地引用多次:\nfn main() {\n    let x = 42;\n    let x_ref1 = &x;\n    let x_ref2 = &x;\n    let x_ref3 = &x;\n    println!("{} {} {}", x_ref1, x_ref2, x_ref3);\n}\n在借用的时候，变量不能被修改:\nfn main() {\n    let mut x = 42;\n    let x_ref = &x;\n    x = 13;\n    println!("x_ref = {}", x_ref);\n    // error: cannot assign to `x` because it is borrowed\n}\n当不可变地借用时，不能同时可变地的借用:\n\nTip：即不能对一个变量同时创建不可变和可变的引用\n\nfn main() {\n    let mut x = 42;\n    let x_ref1 = &x;\n    let x_ref2 = &mut x;\n    // error: cannot borrow `x` as mutable because it is also borrowed as immutable\n    println!("x_ref1 = {}", x_ref1);\n}\n函数参数中的引用同样存在生命周期：\nfn print(x: &i32) {\n    // `x` is borrowed (from the outside) for the\n    // entire time this function is called.\n}\nFootnotes\n\n\nA half-hour to learn Rust ↩\n\n\nRust半小时教程 ↩\n\n\n深入探索 Rust 中的 Panic 机制 ↩', 'author': {'login': 'jygzyc'}, 'category': {'name': '0102-编程'}, 'labels': {'nodes': [{'name': '010204-Rust'}]}, 'comments': {'nodes': []}}, {'title': 'JavaScript基础', 'number': 7, 'url': 'https://github.com/jygzyc/notes/discussions/7', 'createdAt': '2024-04-19T02:47:05Z', 'lastEditedAt': '2024-05-11T03:44:53Z', 'updatedAt': '2024-05-11T03:44:53Z', 'body': "<!-- javascript_base -->\r\n## Promise\r\n\r\n> 转发自[Promise - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544)，学习自用\r\n\r\n在JavaScript的世界中，所有代码都是单线程执行的。\r\n\r\n由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：\r\n\r\n```js\r\nfunction callback() {\r\n    console.log('Done');\r\n}\r\nconsole.log('before setTimeout()');\r\nsetTimeout(callback, 1000); // 1秒钟后调用callback函数\r\nconsole.log('after setTimeout()');\r\n```\r\n\r\n上述代码输出为\r\n\r\n```bash\r\nbefore setTimeout()\r\nafter setTimeout()\r\n(等待1秒后)\r\nDone\r\n```\r\n\r\n可见，异步操作会在将来的某个时间点触发一个函数调用。\r\n\r\n我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：\r\n\r\n```js\r\nfunction test(resolve, reject) {\r\n    var timeOut = Math.random() * 2;\r\n    log('set timeout to: ' + timeOut + ' seconds.');\r\n    setTimeout(function () {\r\n        if (timeOut < 1) {\r\n            log('call resolve()...');\r\n            resolve('200 OK');\r\n        }\r\n        else {\r\n            log('call reject()...');\r\n            reject('timeout in ' + timeOut + ' seconds.');\r\n        }\r\n    }, timeOut * 1000);\r\n}\r\n```\r\n\r\n这个`test()`函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用`resolve('200 OK')`，如果执行失败，我们将调用`reject('timeout in ' + timeOut + ' seconds.')`。可以看出，`test()`函数只关心自身的逻辑，并不关心具体的`resolve`和`reject`将如何处理结果。\r\n\r\n有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：\r\n\r\n```js\r\nvar p1 = new Promise(test);\r\nvar p2 = p1.then(function (result) {\r\n    console.log('成功：' + result);\r\n});\r\nvar p3 = p2.catch(function (reason) {\r\n    console.log('失败：' + reason);\r\n});\r\n```\r\n\r\n变量`p1`是一个Promise对象，它负责执行`test`函数。由于`test`函数在内部是异步执行的，当`test`函数执行成功时，我们告诉Promise对象：\r\n\r\n```js\r\n// 如果成功，执行这个函数：\r\np1.then(function (result) {\r\n    console.log('成功：' + result);\r\n});\r\n```\r\n\r\n当`test`函数执行失败时，我们告诉Promise对象\r\n\r\n```js\r\np2.catch(function (reason) {\r\n    console.log('失败：' + reason);\r\n});\r\n```\r\n\r\nPromise对象可以串联起来，所以上述代码可以简化为：\r\n\r\n```js\r\nnew Promise(test).then(function (result) {\r\n    console.log('成功：' + result);\r\n}).catch(function (reason) {\r\n    console.log('失败：' + reason);\r\n});\r\n```\r\n\r\n实际测试一下，看看Promise是如何异步执行的：\r\n\r\n```js\r\nnew Promise(function (resolve, reject) {\r\n    log('start new Promise...');\r\n    var timeOut = Math.random() * 2;\r\n    log('set timeout to: ' + timeOut + ' seconds.');\r\n    setTimeout(function () {\r\n        if (timeOut < 1) {\r\n            log('call resolve()...');\r\n            resolve('200 OK');\r\n        }\r\n        else {\r\n            log('call reject()...');\r\n            reject('timeout in ' + timeOut + ' seconds.');\r\n        }\r\n    }, timeOut * 1000);\r\n}).then(function (r) {\r\n    log('Done: ' + r);\r\n}).catch(function (reason) {\r\n    log('Failed: ' + reason);\r\n});\r\n```\r\n\r\n执行结果为\r\n\r\n```bash\r\nLog:\r\nstart new Promise...\r\nset timeout to: 0.9886794993641219 seconds.\r\ncall resolve()...\r\nDone: 200 OK\r\n```\r\n\r\n可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了\r\n\r\nPromise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。\r\n\r\n要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：\r\n\r\n```js\r\njob1.then(job2).then(job3).catch(handleError);\r\n```\r\n\r\n其中，`job1`、`job2`和`job3`都是Promise对象。\r\n\r\n除了串行执行若干异步任务外，Promise还可以并行执行异步任务。\r\n\r\n试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用`Promise.all()`实现如下\r\n\r\n```js\r\nvar p1 = new Promise(function (resolve, reject) {\r\n    setTimeout(resolve, 500, 'P1');\r\n});\r\nvar p2 = new Promise(function (resolve, reject) {\r\n    setTimeout(resolve, 600, 'P2');\r\n});\r\n// 同时执行p1和p2，并在它们都完成后执行then:\r\nPromise.all([p1, p2]).then(function (results) {\r\n    console.log(results); // 获得一个Array: ['P1', 'P2']\r\n});\r\n```\r\n\r\n有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用`Promise.race()`实现：\r\n\r\n```js\r\nvar p1 = new Promise(function (resolve, reject) {\r\n    setTimeout(resolve, 500, 'P1');\r\n});\r\nvar p2 = new Promise(function (resolve, reject) {\r\n    setTimeout(resolve, 600, 'P2');\r\n});\r\nPromise.race([p1, p2]).then(function (result) {\r\n    console.log(result); // 'P1'\r\n});\r\n```\r\n\r\n由于`p1`执行较快，Promise的`then()`将获得结果'P1'。`p2`仍在继续执行，但执行结果将被丢弃。\r\n\r\n如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。\r\n\r\n## async函数\r\n\r\n> 转发自[async函数 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1022910821149312/1536754328797217)，学习自用\r\n\r\n我们说JavaScript异步操作需要通过Promise实现，一个Promise对象在操作网络时是异步的，等到返回后再调用回调函数，执行正确就调用`then()`，执行错误就调用`catch()`，虽然异步实现了，不会让用户感觉到页面“卡住”了，但是一堆`then()`、`catch()`写起来麻烦看起来也乱。\r\n\r\n可以用关键字async配合await调用Promise，实现异步操作，但代码却和同步写法类似：\r\n\r\n```js\r\nasync function get(url) {\r\n    let resp = await fetch(url);\r\n    return resp.json();\r\n}\r\n```\r\n\r\n使用`async function`可以定义一个异步函数，异步函数和Promise可以看作是等价的，在`async function`内部，用`await`调用另一个异步函数，写起来和同步代码没啥区别，但执行起来是异步的。\r\n\r\n也就是说：\r\n\r\n```js\r\nlet resp = await fetch(url);\r\n```\r\n\r\n自动实现了异步调用，它和下面的Promise代码等价：\r\n\r\n```js\r\nlet promise = fetch(url);\r\npromise.then((resp) => {\r\n    // 拿到resp\r\n})\r\n```\r\n\r\n如果我们要实现`catch()`怎么办？用Promise的写法如下：\r\n\r\n```js\r\nlet promise = fetch(url);\r\npromise.then((resp) => {\r\n    // 拿到resp\r\n}).catch(e => {\r\n    // 出错了\r\n});\r\n```\r\n\r\n用await调用时，直接用传统的`try{ ... } catch`\r\n\r\n```js\r\nasync function get(url) {\r\n    try {\r\n        let resp = await fetch(url);\r\n        return resp.json();\r\n    } catch (e) {\r\n        // 出错了\r\n    }\r\n}\r\n```\r\n\r\n用async定义异步函数，用await调用异步函数，写起来和同步代码差不多，但可读性大大提高。\r\n\r\n需要特别注意的是，`await`调用必须在`async function`中，不能在传统的同步代码中调用。那么问题来了，一个同步function怎么调用async function呢？\r\n\r\n首先，普通function直接用await调用异步函数将报错：\r\n\r\n```js\r\nasync function get(url) {\r\n    let resp = await fetch(url);\r\n    return resp.json();\r\n}\r\n\r\nfunction doGet() {\r\n    let data = await get('/api/categories');\r\n    console.log(data);\r\n}\r\n\r\ndoGet();\r\n```\r\n\r\n执行结果为`SyntaxError: await is only valid in async functions and the top level bodies of modules`\r\n\r\n如果把`await`去掉，调用实际上发生了，但我们拿不到结果，因为我们拿到的并不是异步结果，而是一个Promise对象：\r\n\r\n```js\r\nasync function get(url) {\r\n    let resp = await fetch(url);\r\n    return resp.json();\r\n}\r\n\r\nfunction doGet() {\r\n    let promise = get('/api/categories');\r\n    console.log(promise);\r\n}\r\n\r\ndoGet();\r\n```\r\n\r\n执行结果为`[object Promise]`\r\n\r\n因此，在普通function中调用async function，不能使用await，但可以直接调用async function拿到Promise对象，后面加上`then()`和`catch()`就可以拿到结果或错误了：\r\n\r\n```js\r\nasync function get(url) {\r\n    let resp = await fetch(url);\r\n    return resp.json();\r\n}\r\n\r\nfunction doGet() {\r\n    let promise = get('/api/categories');\r\n    promise.then(data => {\r\n        // 拿到data\r\n        document.getElementById('test-response-text').value = JSON.stringify(data);\r\n    });\r\n}\r\n\r\ndoGet();\r\n```\r\n\r\n因此，定义异步任务时，使用async function比Promise简单，调用异步任务时，使用await比Promise简单，捕获错误时，按传统的`try...catch`写法，也比Promise简单。只要浏览器支持，完全可以用`async`简洁地实现异步操作。", 'bodyText': "Promise\n\n转发自Promise - 廖雪峰的官方网站，学习自用\n\n在JavaScript的世界中，所有代码都是单线程执行的。\n由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：\nfunction callback() {\n    console.log('Done');\n}\nconsole.log('before setTimeout()');\nsetTimeout(callback, 1000); // 1秒钟后调用callback函数\nconsole.log('after setTimeout()');\n上述代码输出为\nbefore setTimeout()\nafter setTimeout()\n(等待1秒后)\nDone\n可见，异步操作会在将来的某个时间点触发一个函数调用。\n我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：\nfunction test(resolve, reject) {\n    var timeOut = Math.random() * 2;\n    log('set timeout to: ' + timeOut + ' seconds.');\n    setTimeout(function () {\n        if (timeOut < 1) {\n            log('call resolve()...');\n            resolve('200 OK');\n        }\n        else {\n            log('call reject()...');\n            reject('timeout in ' + timeOut + ' seconds.');\n        }\n    }, timeOut * 1000);\n}\n这个test()函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用resolve('200 OK')，如果执行失败，我们将调用reject('timeout in ' + timeOut + ' seconds.')。可以看出，test()函数只关心自身的逻辑，并不关心具体的resolve和reject将如何处理结果。\n有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：\nvar p1 = new Promise(test);\nvar p2 = p1.then(function (result) {\n    console.log('成功：' + result);\n});\nvar p3 = p2.catch(function (reason) {\n    console.log('失败：' + reason);\n});\n变量p1是一个Promise对象，它负责执行test函数。由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象：\n// 如果成功，执行这个函数：\np1.then(function (result) {\n    console.log('成功：' + result);\n});\n当test函数执行失败时，我们告诉Promise对象\np2.catch(function (reason) {\n    console.log('失败：' + reason);\n});\nPromise对象可以串联起来，所以上述代码可以简化为：\nnew Promise(test).then(function (result) {\n    console.log('成功：' + result);\n}).catch(function (reason) {\n    console.log('失败：' + reason);\n});\n实际测试一下，看看Promise是如何异步执行的：\nnew Promise(function (resolve, reject) {\n    log('start new Promise...');\n    var timeOut = Math.random() * 2;\n    log('set timeout to: ' + timeOut + ' seconds.');\n    setTimeout(function () {\n        if (timeOut < 1) {\n            log('call resolve()...');\n            resolve('200 OK');\n        }\n        else {\n            log('call reject()...');\n            reject('timeout in ' + timeOut + ' seconds.');\n        }\n    }, timeOut * 1000);\n}).then(function (r) {\n    log('Done: ' + r);\n}).catch(function (reason) {\n    log('Failed: ' + reason);\n});\n执行结果为\nLog:\nstart new Promise...\nset timeout to: 0.9886794993641219 seconds.\ncall resolve()...\nDone: 200 OK\n可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了\nPromise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。\n要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：\njob1.then(job2).then(job3).catch(handleError);\n其中，job1、job2和job3都是Promise对象。\n除了串行执行若干异步任务外，Promise还可以并行执行异步任务。\n试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下\nvar p1 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 500, 'P1');\n});\nvar p2 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 600, 'P2');\n});\n// 同时执行p1和p2，并在它们都完成后执行then:\nPromise.all([p1, p2]).then(function (results) {\n    console.log(results); // 获得一个Array: ['P1', 'P2']\n});\n有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：\nvar p1 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 500, 'P1');\n});\nvar p2 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 600, 'P2');\n});\nPromise.race([p1, p2]).then(function (result) {\n    console.log(result); // 'P1'\n});\n由于p1执行较快，Promise的then()将获得结果'P1'。p2仍在继续执行，但执行结果将被丢弃。\n如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。\nasync函数\n\n转发自async函数 - 廖雪峰的官方网站，学习自用\n\n我们说JavaScript异步操作需要通过Promise实现，一个Promise对象在操作网络时是异步的，等到返回后再调用回调函数，执行正确就调用then()，执行错误就调用catch()，虽然异步实现了，不会让用户感觉到页面“卡住”了，但是一堆then()、catch()写起来麻烦看起来也乱。\n可以用关键字async配合await调用Promise，实现异步操作，但代码却和同步写法类似：\nasync function get(url) {\n    let resp = await fetch(url);\n    return resp.json();\n}\n使用async function可以定义一个异步函数，异步函数和Promise可以看作是等价的，在async function内部，用await调用另一个异步函数，写起来和同步代码没啥区别，但执行起来是异步的。\n也就是说：\nlet resp = await fetch(url);\n自动实现了异步调用，它和下面的Promise代码等价：\nlet promise = fetch(url);\npromise.then((resp) => {\n    // 拿到resp\n})\n如果我们要实现catch()怎么办？用Promise的写法如下：\nlet promise = fetch(url);\npromise.then((resp) => {\n    // 拿到resp\n}).catch(e => {\n    // 出错了\n});\n用await调用时，直接用传统的try{ ... } catch\nasync function get(url) {\n    try {\n        let resp = await fetch(url);\n        return resp.json();\n    } catch (e) {\n        // 出错了\n    }\n}\n用async定义异步函数，用await调用异步函数，写起来和同步代码差不多，但可读性大大提高。\n需要特别注意的是，await调用必须在async function中，不能在传统的同步代码中调用。那么问题来了，一个同步function怎么调用async function呢？\n首先，普通function直接用await调用异步函数将报错：\nasync function get(url) {\n    let resp = await fetch(url);\n    return resp.json();\n}\n\nfunction doGet() {\n    let data = await get('/api/categories');\n    console.log(data);\n}\n\ndoGet();\n执行结果为SyntaxError: await is only valid in async functions and the top level bodies of modules\n如果把await去掉，调用实际上发生了，但我们拿不到结果，因为我们拿到的并不是异步结果，而是一个Promise对象：\nasync function get(url) {\n    let resp = await fetch(url);\n    return resp.json();\n}\n\nfunction doGet() {\n    let promise = get('/api/categories');\n    console.log(promise);\n}\n\ndoGet();\n执行结果为[object Promise]\n因此，在普通function中调用async function，不能使用await，但可以直接调用async function拿到Promise对象，后面加上then()和catch()就可以拿到结果或错误了：\nasync function get(url) {\n    let resp = await fetch(url);\n    return resp.json();\n}\n\nfunction doGet() {\n    let promise = get('/api/categories');\n    promise.then(data => {\n        // 拿到data\n        document.getElementById('test-response-text').value = JSON.stringify(data);\n    });\n}\n\ndoGet();\n因此，定义异步任务时，使用async function比Promise简单，调用异步任务时，使用await比Promise简单，捕获错误时，按传统的try...catch写法，也比Promise简单。只要浏览器支持，完全可以用async简洁地实现异步操作。", 'author': {'login': 'jygzyc'}, 'category': {'name': '0102-编程'}, 'labels': {'nodes': [{'name': '010201-JavaScript'}]}, 'comments': {'nodes': []}}, {'title': '家常菜菜谱', 'number': 6, 'url': 'https://github.com/jygzyc/notes/discussions/6', 'createdAt': '2024-04-19T02:35:45Z', 'lastEditedAt': '2024-05-27T06:48:41Z', 'updatedAt': '2024-05-27T06:48:41Z', 'body': '<!-- cookbook -->\r\n\r\n## 荤菜\r\n\r\n### 羊肉汤\r\n\r\n1. 羊肉漂洗（可加面粉）\r\n2. 羊肉冷水下锅飞水，捞出冲洗干净\r\n3. 砂锅一次性水加够，拍破的生姜，大葱，适量花椒，冷水浸泡后的当归（胡须形状为宜），白胡椒粉，料酒；烧开关小火\r\n4. 90分钟后捞出大葱，下白萝卜，大枣，开大火，炖15分钟\r\n5. 加盐，加枸杞，再炖5分钟\r\n6. 下葱花，香菜，出锅\r\n\r\n### 大虾炒白菜\r\n\r\n食材：大虾、500g白菜、30g葱姜、3g盐、2g糖、1g味精、3g淀粉\r\n\r\n1. 大虾须子剪掉，前面的虾腔剪掉，虾头内沙包剪掉，虾头剪掉（稍后熬虾汤用）虾背剪开，去掉虾线（去腥，便于入味）处理好的虾洗净\r\n2. 锅中放油，放入虾头，慢慢煎出香味。放入30g葱姜（去腥）放入热水。熬至虾汤浓稠。捞出虾皮，虾汤放一旁备用\r\n3. 重新倒油，放入白菜煸炒（锅中干的话烹水）\r\n4. 锅中放入干净油，放入大虾煎炒，大虾煎透后加入虾汤，白菜。放3g盐、2g糖、1g味精，定味。白菜软烂入味时，收汁勾芡。出锅\r\n\r\n### 番茄炖牛腩\r\n\r\n食材：牛肋腩1000g，西红柿700g，葱100g，姜30g，大料4个，油50g，番茄酱50g，盐6g，味精1g，糖15g\r\n\r\n1. 牛肋腩切成肉块，去皮西红柿切块备用\r\n2. 牛腩块冷水下锅，另备高压锅烧水并加入葱，姜，大料；牛腩块撇出血沫，捞入高压锅中上汽煮30分钟\r\n3. 起锅烧油（干净油），加入葱和少量蒜，葱煸黄后倒入西红柿、适量番茄酱，炒香后倒入煮好的牛腩和适量煮牛腩的汤，加入适量盐、糖、味精（个人口味，偏酸可加糖）调味，小火煮2-3分钟直至味道融合\r\n4. 加香菜，出锅\r\n\r\n### 红汁牛肉\r\n\r\n食材：牛上脑，口蘑，洋葱，红酒，番茄酱\r\n\r\n1. 牛上脑肉切大丁，加白胡椒粉，半勺盐，红酒，揉匀腌制（10分钟即可）\r\n2. 口蘑改刀，分离伞柄和伞盖，切片；洋葱切末\r\n3. 起锅烧油（干净油），煎一下刚刚切好的口蘑（增加风味），微微带色后盛出；烧油（干净油）煎牛肉，煎至上色且基本成熟后出锅；\r\n4. 锅中下黄油，色拉油两种油，化开黄油，下洋葱炒出香味，加适量番茄酱翻炒，倒入少许红酒，转大火加水，下牛肉\r\n5. 锅中加入适量盐（1g左右）、糖（2g左右），烧制10分钟，加入口蘑（连汤），再烧制3-5分钟直至收汁粘稠，出锅\r\n6. 可另摆酸黄瓜配菜\r\n\r\n## 素菜\r\n\r\n> TODO', 'bodyText': '荤菜\n羊肉汤\n\n羊肉漂洗（可加面粉）\n羊肉冷水下锅飞水，捞出冲洗干净\n砂锅一次性水加够，拍破的生姜，大葱，适量花椒，冷水浸泡后的当归（胡须形状为宜），白胡椒粉，料酒；烧开关小火\n90分钟后捞出大葱，下白萝卜，大枣，开大火，炖15分钟\n加盐，加枸杞，再炖5分钟\n下葱花，香菜，出锅\n\n大虾炒白菜\n食材：大虾、500g白菜、30g葱姜、3g盐、2g糖、1g味精、3g淀粉\n\n大虾须子剪掉，前面的虾腔剪掉，虾头内沙包剪掉，虾头剪掉（稍后熬虾汤用）虾背剪开，去掉虾线（去腥，便于入味）处理好的虾洗净\n锅中放油，放入虾头，慢慢煎出香味。放入30g葱姜（去腥）放入热水。熬至虾汤浓稠。捞出虾皮，虾汤放一旁备用\n重新倒油，放入白菜煸炒（锅中干的话烹水）\n锅中放入干净油，放入大虾煎炒，大虾煎透后加入虾汤，白菜。放3g盐、2g糖、1g味精，定味。白菜软烂入味时，收汁勾芡。出锅\n\n番茄炖牛腩\n食材：牛肋腩1000g，西红柿700g，葱100g，姜30g，大料4个，油50g，番茄酱50g，盐6g，味精1g，糖15g\n\n牛肋腩切成肉块，去皮西红柿切块备用\n牛腩块冷水下锅，另备高压锅烧水并加入葱，姜，大料；牛腩块撇出血沫，捞入高压锅中上汽煮30分钟\n起锅烧油（干净油），加入葱和少量蒜，葱煸黄后倒入西红柿、适量番茄酱，炒香后倒入煮好的牛腩和适量煮牛腩的汤，加入适量盐、糖、味精（个人口味，偏酸可加糖）调味，小火煮2-3分钟直至味道融合\n加香菜，出锅\n\n红汁牛肉\n食材：牛上脑，口蘑，洋葱，红酒，番茄酱\n\n牛上脑肉切大丁，加白胡椒粉，半勺盐，红酒，揉匀腌制（10分钟即可）\n口蘑改刀，分离伞柄和伞盖，切片；洋葱切末\n起锅烧油（干净油），煎一下刚刚切好的口蘑（增加风味），微微带色后盛出；烧油（干净油）煎牛肉，煎至上色且基本成熟后出锅；\n锅中下黄油，色拉油两种油，化开黄油，下洋葱炒出香味，加适量番茄酱翻炒，倒入少许红酒，转大火加水，下牛肉\n锅中加入适量盐（1g左右）、糖（2g左右），烧制10分钟，加入口蘑（连汤），再烧制3-5分钟直至收汁粘稠，出锅\n可另摆酸黄瓜配菜\n\n素菜\n\nTODO', 'author': {'login': 'jygzyc'}, 'category': {'name': '0201-饮食'}, 'labels': {'nodes': []}, 'comments': {'nodes': []}}, {'title': '沉潜于水下的人', 'number': 5, 'url': 'https://github.com/jygzyc/notes/discussions/5', 'createdAt': '2024-04-19T02:33:34Z', 'lastEditedAt': None, 'updatedAt': '2024-04-19T02:33:35Z', 'body': '> 谨以此文献给我三年的战友，我信赖的朋友，我热爱的亲人，以及这片我生活了十八年的土地和在这座小城中努力生存的人们。今当远离，以后的日子，愿我们在深邃的星空中，留下自己灿烂的光辉。\r\n\r\n很久以前，我的祖先就被迫迁徙到这片荒芜的土地上，在这里养育后代，至少在我太奶奶的讲述下，祖祖辈辈开始了在这儿的生活。最初，祖先们是不愿意来到这里的，不仅因为原来的日子安逸祥和，更是因为这儿除了骆驼草和石头之外别无他物，但是，头头们觉得戈壁滩不远处的荒山里的矿石有开发的价值，就把祖先们抓到这儿做劳工，这地儿才有了灵气儿。后来，娃娃们从女人的肚子里钻出来，轻轻落到土里，伴着嗷嗷的哭声，戈壁滩也成了座小城。\r\n\r\n---\r\n\r\n对于我的家族而言，我们是自豪的，因为至少我们曾分布在小城的各个角落，拥有大大小小的“领土”。在很长一段时间里，家族的成年人，作为小城的劳工，担负着水，电，食物等的供应和清洁任务。对于身材并不颀长的祖辈来说，这些任务并不简单。但是，家族的鼎盛时期，却也是这会儿，这一切，还得归功于我的祖父。\r\n\r\n---\r\n\r\n我家族里的人都姓“罗恩”，至于为什么会有这样一个奇怪的姓，我曾经为此向我的叔叔打探过，叔叔也只是摇了摇头，转而去问了祖父。出乎意料的是，祖父竟然也不大清楚，只说这名字是祖辈们生下来就有的。既然连家族中最智慧的祖父都不知道的话，问其他人也只是徒劳而已，我也只能就此作罢。祖父的全名叫“罗恩·利尼斯”，其实，我的内心很疑惑——在那么落后和闭塞的时代，太爷爷是如何想出来这样一个洋气的名字。等到成年了，我也觉得这事儿无关紧要，渐渐就淡忘了。\r\n\r\n我的祖父，是罗恩家族公认的最伟大的人之一。在祖父还小的时候，小城里只有一点点面粉，对此，作为负责饮食的劳工，我的太爷爷很是发愁，“怎样才能弥补食物的空缺呢？”\r\n就在这节骨眼上，我的祖父奇思妙想，把骆驼草割下来，暴晒成干之后再磨成粉，作为面粉的代替品，和着面粉揉成骆驼草饼。尽管这饼口感苦涩，还不能多吃（吃多了会有生命危险），但是仍然救活了不老少人，很多人也因此认识了祖父。\r\n\r\n一转眼，十年晃了过去，祖父已经从10岁的小孩，长成了20岁的青年，有了自理生活的能力，这对于晚年得子的太爷爷，莫不过是一个极大的欣慰。不仅仅是祖父，小镇也成了小城——一抛以往的落后，从地上爬了起来，耸立着稀疏的高楼。这下太爷爷吃了大半生苦，终于有机会安享晚年了，只可惜冬季一天夜里，还在睡梦中的太爷爷不知为何，身子一直，双腿一蹬便归西了。等到第二天清晨，医生们接到电话，匆忙赶往太爷爷家时，太爷爷已经死去多时，后来查清楚死因是心脏病突发，这可叫人疑惑——家族里可从来没有得心脏病的啊！\r\n\r\n太爷爷下葬的那天，听说身子直挺挺的，像根柱子一样被扔进了家族的葬井里。祖父就站在井口边上，一动不动地向下看着太爷爷一点一点沉下去，脸上没有挂着任何悲伤的信号，但是凛冽的寒风却带走了祖父眼眶中残余的泪水。这是祖父第一次流泪，也是最后一次。\r\n\r\n太爷爷死后，祖父就接替太爷爷担负起了现在的老城区的规划和建设的任务——绿色逐渐在这片戈壁滩上蔓延开来。整齐的钢铁怪兽拔地而起，这使祖父更加声名远扬。家族里的人，也都以“罗恩·利尼斯”为榜样，在各行各业大显身手，这是家族的全盛时期。但是，这短暂的辉煌，只能截止到我的父亲出生。\r\n\r\n---\r\n\r\n我的父亲是祖母第四个儿子，也是最小的那一个，据说他在娘胎里时就身材颀长，对于身材矮小的长辈们来说，这简直是一个异类，一个屈辱。自然而然地，家族逐渐开始将父亲排除在外——起初在祖父决策时，父亲的建议不被理睬；在分配生活物资时，父亲得不到公正的待遇；而在祖父最后的分家中，父亲彻底丧失了作为一个儿子应得的财产，一个人默默行走在小城里，作为新的人种独自生活。为了能够顺利找到工作，他只好避开家族所涉及的行业，不想有所牵连。长时间在小城的地基徘徊，父亲终于在小城南边的正在开发的新城区，找到了属于他自己的职业，也就是作为一盏“路灯”——父亲颀长的身体，使他可以头顶着灯，照亮周身的一小片区域。在这片土地上，父亲也找到了许许多多像他一样，被家族抑或朋友所抛弃的，直立于大地上的“路灯”。每当夜幕降临，这些“路灯”就接连闪烁起光芒，但是尽管孩子们在灯下嬉戏，小狗在灯下侧卧休憩，工作了一天而疲惫的人们借助着灯光回到家中，却没有一个人对“路灯”表现出关心或同情，甚至没有一句简单的问候；而“路灯”似乎也不以为然，凭着逐渐硬化而变灰的身子，瞒过了几乎所有人，就连父亲的问好也异常冷漠。不过很可惜，父亲是一个人，这冷淡丝毫不会影响到父亲的心情。看起来，生活似乎步入了正轨，但在这幸福的时刻，父亲却听说了一个令人吃惊的消息——祖父去世了。\r\n\r\n下葬的那天，殡仪馆原本空旷的大厅里，摆满了五颜六色花圈和脸上挂着悲伤的人们，一下子显得金碧辉煌起来。大厅的正中央，不大的水晶棺里躺着矮小的祖父的遗体，家族的人们站在祖父两侧，议论着祖父的功绩。祖母站在棺材头，双手扶着棺材两侧，望着里面躺着的小小的人儿，泪水扑簌簌地往下掉；太奶奶则坐在一旁，一边安抚着祖母，一边叹息着聆听人们的言语。\r\n\r\n“可怜我的老父亲啊，声名远播也没能留住他自己……”大女儿罗恩·哈皮哀婉地用手遮住了脸。“如果父亲再多活一会儿，他就能得到更多的名誉了啊，只可惜……”长子罗恩·普莱森特向周身的人遗憾地摆了摆手，以表示自己内心的伤痛。葬礼的一切，都按照程序机械地推进着。\r\n\r\n---\r\n\r\n三挂鞭炮“噼里啪啦”胡乱一通地炸掉，空气中四处弥漫着蓝色而呛人的火药烟，家族的葬井也在烟灰中渐变模糊——祖父就要下井了。祖父众多的子女也如当年的祖父一般，注视而等待着僵直的祖父缓缓落入井中，这短短两分钟也仿佛凝固了，一秒，两秒……突然，人群中传来了莫名其妙的骚动，一个身材颀长，通体灰色的人气势汹汹闯入了墓地，原本拥挤的人们因为恐惧，纷纷向两边让道。就连井前的子女也瞪圆了眼睛，令他们没想到的是，父亲竟然来送葬了。\r\n\r\n高大的人影在移动到井前的一刻戛然而止，坚硬的双膝“扑通”一声重重地撞击在灰色的水泥地上，甚至敲出了微弱的火花，泪水不自觉的从父亲坚毅的脸颊流淌下来。这一切发生的如此突然，甚至连掌家的大儿子都不由得惊愕了一下，但作为家族的掌门人，他又很快清醒过来，对着跪在井前的父亲大声斥责：\r\n\r\n“滚！你这个不孝子，还有脸来见父亲，父亲之前有病的时候，你在哪？！赶紧给我滚，别再让我看见你！”\r\n\r\n两名看上去孔武有力的保安闻讯从门口赶来，见此情景，一边粗鲁地架起父亲的双臂，把他向外拖；一边连连给罗恩·普莱森特赔礼，说大少爷您受惊了。父亲看着罗恩·普莱森特蔑视般的撇嘴越来越远，自己的意识也随之越来越远。在父亲即将被拖出墓区的一刹那，他突然感觉手心被塞入了什么东西，侧头一看，只有太奶奶欲言又止的悲伤。飘回新城区，父亲借助着自己头顶微弱的灯光，手指一颤一颤地张开，手心里，是太奶奶给父亲留下的东西——一张皱巴巴纸条，上面歪歪曲曲地写着：\r\n\r\n“我们都是沉潜于水下的人。\r\n\r\n罗恩·利尼斯”\r\n\r\n这是祖父真正的，也是唯一的遗书。\r\n\r\n---\r\n\r\n从此以后，父亲就像变了一个人——不，准确来说不是一个人，而是更加专职——身体仿佛被浇灌了水泥，变得又灰又硬，表情也冷漠的一如旁边的“路灯”，不再乐观开朗——他成为了一盏真正的路灯。这样麻木的时间在灯光中蒸腾，在空气中摇曳，无声无息地窜上穹顶，却在我的母亲到来之时戛然而止。\r\n\r\n我的母亲是原来地主家的大小姐，但是却没有公主一般挑剔的毛病。那天夜里，她检查完外祖父在新城区的投资工作之后，沿着父亲所在的道路骑车回家。自行车飞速压过水泥地面，却在父亲的前面缓缓停了下来。\r\n\r\n“这是一个人。”深夜的街道上，这句话格外清晰。\r\n\r\n父亲的喉咙眼艰难地吐出低沉的吼声，似乎是想回应这个女人的话——我相信，当时除了母亲，再没有任何人感受到父亲的存在，这是第一个，也是唯一一个认出他的人。尽管身体变硬，五官已经半陷到身体里，父亲还是稍稍睁开了一只眼睛，观察这个身材高挑，秀色可餐的大小姐，而女人只是抬头，静静观察着这盏“路灯”。\r\n\r\n大小姐留了下来，不是因为爱上了他，或许只是想拯救这个人。\r\n\r\n---\r\n\r\n父亲开始抖落身体沾上的尘埃，努力想撑开浇筑在一起四肢，头顶的灯光也随着身体的晃动开始闪烁，这使得睡在一旁的大小姐也被惊醒，惊喜地望着父亲的变化——至少他作为一个人开始行动了。与之同时，新闻报道也铺天盖地而来，唤醒了人们对“路灯”们过去的回忆，三五成群的人们从远方赶来，只为在“路灯”下坐一坐，“路灯”的五官也从厚厚的尘埃中浮出来，显出从未有过的表情。\r\n\r\n每天晚上，大小姐结束了一天繁忙的工作之后，总会来到父亲身边安心地休息。一天，两天，一月，两月，日久生情，父亲爱上了大小姐，清晨因她去工作而失落，傍晚因她骑车归来而欣喜。父亲的身体也逐渐变矮，褪去了身上的灰色，露出了黄色的皮肤，虽然这些变化一一映在大小姐眼里，但是父亲并没有察觉，只是一心想着她。终于，在父亲的指尖露出黄色，外祖父工程竣工的那一天，他们俩结婚了。起初，在父亲向大小姐求婚的时候，外祖父是不同意的，因为他认为父亲什么也不会做，挣不到钱也养活不了自己，然而在见过父亲之后，外祖父却把最重要的女儿放心地交给了父亲，理由我也不太清楚，似乎是因为父亲看上去很坚硬。\r\n\r\n---\r\n\r\n父母结婚后一年，我就出生了。和父亲一样，我幼年就身材颀长，听父亲说出生前我还在母亲的肚子里大闹过一通，半夜里让母亲难受地翻来覆去，最后还是在父亲的安抚下，我才安静下来。出生之后，我不得不躺在娃娃车里，胳膊被架在车体外面，双脚则被固定在一个大概的范围。在我出生两天后，父母就轮换着开始了长远的教育大计——白天父亲负责哄我入睡，当朦胧的山脊线融入苍蓝的夜色时，母亲就结束工作回到父亲和我的身边，给我喂奶，唱歌：“遥远的夜空/有一个弯弯的月亮/弯弯的月亮下面/是那弯弯的小桥……”这样的轮班持续了一个星期，我就长的和父亲一样高，说话也俨然一副大人的模样——我的幼年时代就这样结束了。\r\n\r\n尽管如此，我的思维依然很幼稚，父母仍然每天教导我。但是，两个月后，一家三口的幸福生活被一场突如其来的车祸扯的支离破碎——母亲的自行车弯曲变形，浸没在母亲的鲜血中，不，不仅是自行车，整条大街都流淌着鲜红色的河流。这血液漫无目的地流淌，渗入了每一辆汽车的轮胎，渗入了每一座大楼的地基，也渗入了每一盏“路灯”脚底长年累月形成的伤口，这自然也包括父亲的。\r\n\r\n父亲干巴巴的眼睛，竟然湿润起来，喉咙眼里再一次挤出低沉的吼声，与上次不一样的是，略带血腥的风中夹杂的不仅仅是无尽的悲伤，还有对命运不公的控诉和愤慨。从这之后，父亲彻底沉默了，身体再一次硬化，身高却没有变化，一如祖父的矮小，这盏“路灯”，不再派上用场，仅仅只是作为一个摆设——父亲的冬天来了，他终究，还是没能躲过家族的命运。\r\n\r\n---\r\n\r\n为了找到工作，我开始像父亲曾经做过的那样，在小城的地基周围徘徊，狼一样寻找猎物。之所以不选择成为一盏“路灯”，是因为我一反父亲的踏实，天生就喜欢四处游荡，这不仅决定了我最终从事经商，而且也不可避免地决定了我与家族的会面，在我十岁那天，我决定踏入祖宅的大门，迎接长辈们的挑战。出人意料的是，长辈们已经不那么在意身材的颀长了（因为宅子里的孩子们长的越来越高，长辈们习以为常，反而将矮个的孩子认为是异类）。我很是失望，身体就像被掏空了，无头苍蝇一般失去了长期以来生存的意义和方向，既然一切都被妥协，那我鼓起这莫大的勇气又是为了什么呢？仿佛在迷雾中航行，我悻悻离开了祖宅。\r\n\r\n怀着怨恨，我一人走在深夜的大街上，一抬头，街角站着的，是打扮的异常妖娆的“接客的”。我二话不说，急行到那女的面前，那女的也只说了一句“这边走”，就缓缓把我带进了一个三回九转的小巷子里。来到巷子的最深处，柔和的红色的灯光从模糊的白色窗帘里溢出来，不时还能听到淫荡的声音从破旧的房子里传出来。那女的带我来到其中一间房，随意把门掩上就问我“你要啥样的服务？”\r\n\r\n突然，我开始害怕起来——在这红色灯光下，我惊奇地发现这女的竟然长的和母亲如此之像。此刻仿佛母亲浸在血里，却赤裸裸站在反光的地面上，面无表情地注视着我。我害怕极了，额头上渗出大滴大滴的汗珠，硬生生顺着耳边流下来，身子也不听使唤没命地颤抖。最后一瞬间，我的大脑脱离了对自己身体仅剩的控制，还没听清这女的又说了什么，就撇下三百元抱着头夺门而出，在漆黑的巷子里摸爬滚打，一味地逃离，逃离，直到精疲力竭，意识于小巷出口的青灰色地面上消失。\r\n\r\n---\r\n\r\n之后的三年，我开始在生意场上打拼，结识了不少朋友，可是再也没有回到小城——我担心在这里会再次遇到母亲，遇到祖祖辈辈们，再一次不得不忍受无尽的空虚和抱怨。这样的境况一直持续着，直到某一天，当我还在谈生意的时候，突然传来了噩耗——父亲去世了。听到这个，我才急忙赶回小城，布置父亲的葬礼。这是也是三年内，我第一次回到这里。\r\n\r\n看着陌生的徘徊在小城地基的年轻人，望着熟悉而老旧的街道，我的心脏竟然莫名其妙地抽搐了一下——是因为怀念起过去了吗？我无从知道，只是不知不觉地，就走进了殡仪馆。令我没想到的是，家族的人，童年时期认识的朋友，三年间一起在商场中战斗过的“战友”，竟然都聚集到了殡仪馆大厅，父亲在正中的水晶棺里静静地躺着，比起一位老人，他更像一个婴儿，一个乖巧的婴儿。\r\n\r\n五挂鞭炮“噼里啪啦”齐鸣，迷蒙的雨雾和蓝色的烟灰和在一起，模糊了人脸。父亲就和祖父与太爷爷一样，身体直挺挺的，即将落入井中。但本应无比悲伤的我，却突然想起了我这三年间认识的已经分了手的女友。在分手时，她接连问了我三个问题，而我却未能立即给出答案。\r\n\r\n“这地方比起你的故乡哪个更好一点？”\r\n\r\n“我和你的母亲相比，谁更贤惠一点？”\r\n\r\n“你能学学人家，活在现实之中吗？”\r\n\r\n清脆的唢呐声将我的意识拽了回来——父亲即将入水了。这是我第一次，看清井水的颜色，是血一样的红色。我恍然大悟，仿佛看见——不，不是仿佛，是真真切切看见在小城的地基之下，大陆之下，在深邃的血海里，身体坚硬的祖父，太爷爷，以及祖先们沉潜于水中，柱子一般用头支撑着一整座大陆，亘古不变。\r\n\r\n此时此刻，我才明白祖父的遗书——“我们都是沉潜于水下的人”。原来，我一直以为我已经摆脱了家族，但我错了，而且大错特错——我一直都与父亲同在，与家族同在，我的灵魂，一直都在水下长眠。这样想着，我凝视着鲜红色的井水缓慢地没过了父亲的头颅。\r\n\r\n我一直，都是沉潜于水下的人。\r\n\r\n于2016年8月29日', 'bodyText': '谨以此文献给我三年的战友，我信赖的朋友，我热爱的亲人，以及这片我生活了十八年的土地和在这座小城中努力生存的人们。今当远离，以后的日子，愿我们在深邃的星空中，留下自己灿烂的光辉。\n\n很久以前，我的祖先就被迫迁徙到这片荒芜的土地上，在这里养育后代，至少在我太奶奶的讲述下，祖祖辈辈开始了在这儿的生活。最初，祖先们是不愿意来到这里的，不仅因为原来的日子安逸祥和，更是因为这儿除了骆驼草和石头之外别无他物，但是，头头们觉得戈壁滩不远处的荒山里的矿石有开发的价值，就把祖先们抓到这儿做劳工，这地儿才有了灵气儿。后来，娃娃们从女人的肚子里钻出来，轻轻落到土里，伴着嗷嗷的哭声，戈壁滩也成了座小城。\n\n对于我的家族而言，我们是自豪的，因为至少我们曾分布在小城的各个角落，拥有大大小小的“领土”。在很长一段时间里，家族的成年人，作为小城的劳工，担负着水，电，食物等的供应和清洁任务。对于身材并不颀长的祖辈来说，这些任务并不简单。但是，家族的鼎盛时期，却也是这会儿，这一切，还得归功于我的祖父。\n\n我家族里的人都姓“罗恩”，至于为什么会有这样一个奇怪的姓，我曾经为此向我的叔叔打探过，叔叔也只是摇了摇头，转而去问了祖父。出乎意料的是，祖父竟然也不大清楚，只说这名字是祖辈们生下来就有的。既然连家族中最智慧的祖父都不知道的话，问其他人也只是徒劳而已，我也只能就此作罢。祖父的全名叫“罗恩·利尼斯”，其实，我的内心很疑惑——在那么落后和闭塞的时代，太爷爷是如何想出来这样一个洋气的名字。等到成年了，我也觉得这事儿无关紧要，渐渐就淡忘了。\n我的祖父，是罗恩家族公认的最伟大的人之一。在祖父还小的时候，小城里只有一点点面粉，对此，作为负责饮食的劳工，我的太爷爷很是发愁，“怎样才能弥补食物的空缺呢？”\n就在这节骨眼上，我的祖父奇思妙想，把骆驼草割下来，暴晒成干之后再磨成粉，作为面粉的代替品，和着面粉揉成骆驼草饼。尽管这饼口感苦涩，还不能多吃（吃多了会有生命危险），但是仍然救活了不老少人，很多人也因此认识了祖父。\n一转眼，十年晃了过去，祖父已经从10岁的小孩，长成了20岁的青年，有了自理生活的能力，这对于晚年得子的太爷爷，莫不过是一个极大的欣慰。不仅仅是祖父，小镇也成了小城——一抛以往的落后，从地上爬了起来，耸立着稀疏的高楼。这下太爷爷吃了大半生苦，终于有机会安享晚年了，只可惜冬季一天夜里，还在睡梦中的太爷爷不知为何，身子一直，双腿一蹬便归西了。等到第二天清晨，医生们接到电话，匆忙赶往太爷爷家时，太爷爷已经死去多时，后来查清楚死因是心脏病突发，这可叫人疑惑——家族里可从来没有得心脏病的啊！\n太爷爷下葬的那天，听说身子直挺挺的，像根柱子一样被扔进了家族的葬井里。祖父就站在井口边上，一动不动地向下看着太爷爷一点一点沉下去，脸上没有挂着任何悲伤的信号，但是凛冽的寒风却带走了祖父眼眶中残余的泪水。这是祖父第一次流泪，也是最后一次。\n太爷爷死后，祖父就接替太爷爷担负起了现在的老城区的规划和建设的任务——绿色逐渐在这片戈壁滩上蔓延开来。整齐的钢铁怪兽拔地而起，这使祖父更加声名远扬。家族里的人，也都以“罗恩·利尼斯”为榜样，在各行各业大显身手，这是家族的全盛时期。但是，这短暂的辉煌，只能截止到我的父亲出生。\n\n我的父亲是祖母第四个儿子，也是最小的那一个，据说他在娘胎里时就身材颀长，对于身材矮小的长辈们来说，这简直是一个异类，一个屈辱。自然而然地，家族逐渐开始将父亲排除在外——起初在祖父决策时，父亲的建议不被理睬；在分配生活物资时，父亲得不到公正的待遇；而在祖父最后的分家中，父亲彻底丧失了作为一个儿子应得的财产，一个人默默行走在小城里，作为新的人种独自生活。为了能够顺利找到工作，他只好避开家族所涉及的行业，不想有所牵连。长时间在小城的地基徘徊，父亲终于在小城南边的正在开发的新城区，找到了属于他自己的职业，也就是作为一盏“路灯”——父亲颀长的身体，使他可以头顶着灯，照亮周身的一小片区域。在这片土地上，父亲也找到了许许多多像他一样，被家族抑或朋友所抛弃的，直立于大地上的“路灯”。每当夜幕降临，这些“路灯”就接连闪烁起光芒，但是尽管孩子们在灯下嬉戏，小狗在灯下侧卧休憩，工作了一天而疲惫的人们借助着灯光回到家中，却没有一个人对“路灯”表现出关心或同情，甚至没有一句简单的问候；而“路灯”似乎也不以为然，凭着逐渐硬化而变灰的身子，瞒过了几乎所有人，就连父亲的问好也异常冷漠。不过很可惜，父亲是一个人，这冷淡丝毫不会影响到父亲的心情。看起来，生活似乎步入了正轨，但在这幸福的时刻，父亲却听说了一个令人吃惊的消息——祖父去世了。\n下葬的那天，殡仪馆原本空旷的大厅里，摆满了五颜六色花圈和脸上挂着悲伤的人们，一下子显得金碧辉煌起来。大厅的正中央，不大的水晶棺里躺着矮小的祖父的遗体，家族的人们站在祖父两侧，议论着祖父的功绩。祖母站在棺材头，双手扶着棺材两侧，望着里面躺着的小小的人儿，泪水扑簌簌地往下掉；太奶奶则坐在一旁，一边安抚着祖母，一边叹息着聆听人们的言语。\n“可怜我的老父亲啊，声名远播也没能留住他自己……”大女儿罗恩·哈皮哀婉地用手遮住了脸。“如果父亲再多活一会儿，他就能得到更多的名誉了啊，只可惜……”长子罗恩·普莱森特向周身的人遗憾地摆了摆手，以表示自己内心的伤痛。葬礼的一切，都按照程序机械地推进着。\n\n三挂鞭炮“噼里啪啦”胡乱一通地炸掉，空气中四处弥漫着蓝色而呛人的火药烟，家族的葬井也在烟灰中渐变模糊——祖父就要下井了。祖父众多的子女也如当年的祖父一般，注视而等待着僵直的祖父缓缓落入井中，这短短两分钟也仿佛凝固了，一秒，两秒……突然，人群中传来了莫名其妙的骚动，一个身材颀长，通体灰色的人气势汹汹闯入了墓地，原本拥挤的人们因为恐惧，纷纷向两边让道。就连井前的子女也瞪圆了眼睛，令他们没想到的是，父亲竟然来送葬了。\n高大的人影在移动到井前的一刻戛然而止，坚硬的双膝“扑通”一声重重地撞击在灰色的水泥地上，甚至敲出了微弱的火花，泪水不自觉的从父亲坚毅的脸颊流淌下来。这一切发生的如此突然，甚至连掌家的大儿子都不由得惊愕了一下，但作为家族的掌门人，他又很快清醒过来，对着跪在井前的父亲大声斥责：\n“滚！你这个不孝子，还有脸来见父亲，父亲之前有病的时候，你在哪？！赶紧给我滚，别再让我看见你！”\n两名看上去孔武有力的保安闻讯从门口赶来，见此情景，一边粗鲁地架起父亲的双臂，把他向外拖；一边连连给罗恩·普莱森特赔礼，说大少爷您受惊了。父亲看着罗恩·普莱森特蔑视般的撇嘴越来越远，自己的意识也随之越来越远。在父亲即将被拖出墓区的一刹那，他突然感觉手心被塞入了什么东西，侧头一看，只有太奶奶欲言又止的悲伤。飘回新城区，父亲借助着自己头顶微弱的灯光，手指一颤一颤地张开，手心里，是太奶奶给父亲留下的东西——一张皱巴巴纸条，上面歪歪曲曲地写着：\n“我们都是沉潜于水下的人。\n罗恩·利尼斯”\n这是祖父真正的，也是唯一的遗书。\n\n从此以后，父亲就像变了一个人——不，准确来说不是一个人，而是更加专职——身体仿佛被浇灌了水泥，变得又灰又硬，表情也冷漠的一如旁边的“路灯”，不再乐观开朗——他成为了一盏真正的路灯。这样麻木的时间在灯光中蒸腾，在空气中摇曳，无声无息地窜上穹顶，却在我的母亲到来之时戛然而止。\n我的母亲是原来地主家的大小姐，但是却没有公主一般挑剔的毛病。那天夜里，她检查完外祖父在新城区的投资工作之后，沿着父亲所在的道路骑车回家。自行车飞速压过水泥地面，却在父亲的前面缓缓停了下来。\n“这是一个人。”深夜的街道上，这句话格外清晰。\n父亲的喉咙眼艰难地吐出低沉的吼声，似乎是想回应这个女人的话——我相信，当时除了母亲，再没有任何人感受到父亲的存在，这是第一个，也是唯一一个认出他的人。尽管身体变硬，五官已经半陷到身体里，父亲还是稍稍睁开了一只眼睛，观察这个身材高挑，秀色可餐的大小姐，而女人只是抬头，静静观察着这盏“路灯”。\n大小姐留了下来，不是因为爱上了他，或许只是想拯救这个人。\n\n父亲开始抖落身体沾上的尘埃，努力想撑开浇筑在一起四肢，头顶的灯光也随着身体的晃动开始闪烁，这使得睡在一旁的大小姐也被惊醒，惊喜地望着父亲的变化——至少他作为一个人开始行动了。与之同时，新闻报道也铺天盖地而来，唤醒了人们对“路灯”们过去的回忆，三五成群的人们从远方赶来，只为在“路灯”下坐一坐，“路灯”的五官也从厚厚的尘埃中浮出来，显出从未有过的表情。\n每天晚上，大小姐结束了一天繁忙的工作之后，总会来到父亲身边安心地休息。一天，两天，一月，两月，日久生情，父亲爱上了大小姐，清晨因她去工作而失落，傍晚因她骑车归来而欣喜。父亲的身体也逐渐变矮，褪去了身上的灰色，露出了黄色的皮肤，虽然这些变化一一映在大小姐眼里，但是父亲并没有察觉，只是一心想着她。终于，在父亲的指尖露出黄色，外祖父工程竣工的那一天，他们俩结婚了。起初，在父亲向大小姐求婚的时候，外祖父是不同意的，因为他认为父亲什么也不会做，挣不到钱也养活不了自己，然而在见过父亲之后，外祖父却把最重要的女儿放心地交给了父亲，理由我也不太清楚，似乎是因为父亲看上去很坚硬。\n\n父母结婚后一年，我就出生了。和父亲一样，我幼年就身材颀长，听父亲说出生前我还在母亲的肚子里大闹过一通，半夜里让母亲难受地翻来覆去，最后还是在父亲的安抚下，我才安静下来。出生之后，我不得不躺在娃娃车里，胳膊被架在车体外面，双脚则被固定在一个大概的范围。在我出生两天后，父母就轮换着开始了长远的教育大计——白天父亲负责哄我入睡，当朦胧的山脊线融入苍蓝的夜色时，母亲就结束工作回到父亲和我的身边，给我喂奶，唱歌：“遥远的夜空/有一个弯弯的月亮/弯弯的月亮下面/是那弯弯的小桥……”这样的轮班持续了一个星期，我就长的和父亲一样高，说话也俨然一副大人的模样——我的幼年时代就这样结束了。\n尽管如此，我的思维依然很幼稚，父母仍然每天教导我。但是，两个月后，一家三口的幸福生活被一场突如其来的车祸扯的支离破碎——母亲的自行车弯曲变形，浸没在母亲的鲜血中，不，不仅是自行车，整条大街都流淌着鲜红色的河流。这血液漫无目的地流淌，渗入了每一辆汽车的轮胎，渗入了每一座大楼的地基，也渗入了每一盏“路灯”脚底长年累月形成的伤口，这自然也包括父亲的。\n父亲干巴巴的眼睛，竟然湿润起来，喉咙眼里再一次挤出低沉的吼声，与上次不一样的是，略带血腥的风中夹杂的不仅仅是无尽的悲伤，还有对命运不公的控诉和愤慨。从这之后，父亲彻底沉默了，身体再一次硬化，身高却没有变化，一如祖父的矮小，这盏“路灯”，不再派上用场，仅仅只是作为一个摆设——父亲的冬天来了，他终究，还是没能躲过家族的命运。\n\n为了找到工作，我开始像父亲曾经做过的那样，在小城的地基周围徘徊，狼一样寻找猎物。之所以不选择成为一盏“路灯”，是因为我一反父亲的踏实，天生就喜欢四处游荡，这不仅决定了我最终从事经商，而且也不可避免地决定了我与家族的会面，在我十岁那天，我决定踏入祖宅的大门，迎接长辈们的挑战。出人意料的是，长辈们已经不那么在意身材的颀长了（因为宅子里的孩子们长的越来越高，长辈们习以为常，反而将矮个的孩子认为是异类）。我很是失望，身体就像被掏空了，无头苍蝇一般失去了长期以来生存的意义和方向，既然一切都被妥协，那我鼓起这莫大的勇气又是为了什么呢？仿佛在迷雾中航行，我悻悻离开了祖宅。\n怀着怨恨，我一人走在深夜的大街上，一抬头，街角站着的，是打扮的异常妖娆的“接客的”。我二话不说，急行到那女的面前，那女的也只说了一句“这边走”，就缓缓把我带进了一个三回九转的小巷子里。来到巷子的最深处，柔和的红色的灯光从模糊的白色窗帘里溢出来，不时还能听到淫荡的声音从破旧的房子里传出来。那女的带我来到其中一间房，随意把门掩上就问我“你要啥样的服务？”\n突然，我开始害怕起来——在这红色灯光下，我惊奇地发现这女的竟然长的和母亲如此之像。此刻仿佛母亲浸在血里，却赤裸裸站在反光的地面上，面无表情地注视着我。我害怕极了，额头上渗出大滴大滴的汗珠，硬生生顺着耳边流下来，身子也不听使唤没命地颤抖。最后一瞬间，我的大脑脱离了对自己身体仅剩的控制，还没听清这女的又说了什么，就撇下三百元抱着头夺门而出，在漆黑的巷子里摸爬滚打，一味地逃离，逃离，直到精疲力竭，意识于小巷出口的青灰色地面上消失。\n\n之后的三年，我开始在生意场上打拼，结识了不少朋友，可是再也没有回到小城——我担心在这里会再次遇到母亲，遇到祖祖辈辈们，再一次不得不忍受无尽的空虚和抱怨。这样的境况一直持续着，直到某一天，当我还在谈生意的时候，突然传来了噩耗——父亲去世了。听到这个，我才急忙赶回小城，布置父亲的葬礼。这是也是三年内，我第一次回到这里。\n看着陌生的徘徊在小城地基的年轻人，望着熟悉而老旧的街道，我的心脏竟然莫名其妙地抽搐了一下——是因为怀念起过去了吗？我无从知道，只是不知不觉地，就走进了殡仪馆。令我没想到的是，家族的人，童年时期认识的朋友，三年间一起在商场中战斗过的“战友”，竟然都聚集到了殡仪馆大厅，父亲在正中的水晶棺里静静地躺着，比起一位老人，他更像一个婴儿，一个乖巧的婴儿。\n五挂鞭炮“噼里啪啦”齐鸣，迷蒙的雨雾和蓝色的烟灰和在一起，模糊了人脸。父亲就和祖父与太爷爷一样，身体直挺挺的，即将落入井中。但本应无比悲伤的我，却突然想起了我这三年间认识的已经分了手的女友。在分手时，她接连问了我三个问题，而我却未能立即给出答案。\n“这地方比起你的故乡哪个更好一点？”\n“我和你的母亲相比，谁更贤惠一点？”\n“你能学学人家，活在现实之中吗？”\n清脆的唢呐声将我的意识拽了回来——父亲即将入水了。这是我第一次，看清井水的颜色，是血一样的红色。我恍然大悟，仿佛看见——不，不是仿佛，是真真切切看见在小城的地基之下，大陆之下，在深邃的血海里，身体坚硬的祖父，太爷爷，以及祖先们沉潜于水中，柱子一般用头支撑着一整座大陆，亘古不变。\n此时此刻，我才明白祖父的遗书——“我们都是沉潜于水下的人”。原来，我一直以为我已经摆脱了家族，但我错了，而且大错特错——我一直都与父亲同在，与家族同在，我的灵魂，一直都在水下长眠。这样想着，我凝视着鲜红色的井水缓慢地没过了父亲的头颅。\n我一直，都是沉潜于水下的人。\n于2016年8月29日', 'author': {'login': 'jygzyc'}, 'category': {'name': '0301-文章'}, 'labels': {'nodes': []}, 'comments': {'nodes': []}}, {'title': 'Android源码编译', 'number': 4, 'url': 'https://github.com/jygzyc/notes/discussions/4', 'createdAt': '2024-04-19T02:15:04Z', 'lastEditedAt': '2024-05-15T06:45:11Z', 'updatedAt': '2024-05-15T06:45:11Z', 'body': '<!-- android_source_compile -->\r\n编译Android系统的时候遇到了环境不同，稳定性不同的问题，选择docker解决问题\r\n\r\n> 以编译Google Pixel 3，lineageOS 21.0为例\r\n\r\n## 下载源码\r\n\r\n第一步，安装repo\r\n\r\n```bash\r\nmkdir ~/bin\r\nPATH=~/bin:$PATH\r\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\r\nchmod a+x ~/bin/repo\r\n```\r\n\r\n第二步，配置git\r\n\r\n```bash\r\ngit config --global user.email "you@example.com"\r\ngit config --global user.name "Your Name"\r\n```\r\n\r\n由于其大小，一些存储库配置为 lfs 或大文件存储，需要安装git-lfs：\r\n\r\n```bash\r\ngit lfs install # apt install git-lfs\r\n```\r\n\r\n第三步，初始化LineageOS存储库\r\n\r\n```bash\r\nrepo init -u https://github.com/LineageOS/android.git -b lineage-21.0 --git-lfs\r\n```\r\n\r\n第四步，同步源码并准备，这里可以先参考[清华lineageOS 源代码镜像使用帮助](https://mirrors.tuna.tsinghua.edu.cn/help/lineageOS/)，先使用清华源同步，但是最后还是需要切回github同步一下，不然指定机型编译后会报错\r\n\r\n```bash\r\nrepo sync\r\n\r\n# after finished\r\nsource build/envsetup.sh\r\nbreakfast blueline\r\n```\r\n\r\n第五步，同步设备特定固件代码\r\n\r\n方法一，先刷机再执行`device/google/blueline`目录下的`./extract-files.sh`\r\n\r\n方法二，从OTA包中获取固件，此处可以参考 [Extracting proprietary blobs from LineageOS zip files](https://wiki.lineageos.org/extracting_blobs_from_zips)\r\n\r\n## docker安装\r\n\r\n由于我需要对制作好的image进行上传，所以这里就采用官方源进行安装了\r\n\r\n```bash\r\n$ curl -fsSL get.docker.com -o get-docker.sh\r\n```\r\n\r\n执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。\r\n\r\n之后我们启动docker\r\n\r\n```bash\r\n$ sudo systemctl enable docker\r\n$ sudo systemctl start docker\r\n```\r\n\r\n默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组，或者安装rootless的docker\r\n\r\n```bash\r\n$ sudo groupadd docker\r\n$ sudo usermod -aG docker $USER\r\n# 或者使用脚本变为rootless模式\r\n$ dockerd-rootless.sh\r\n```\r\n\r\n新建终端测试\r\n\r\n```bash\r\n$ docker run --rm hello-world\r\nUnable to find image \'hello-world:latest\' locally\r\nlatest: Pulling from library/hello-world\r\n719385e32844: Pull complete \r\nDigest: sha256:dcba6daec718f547568c562956fa47e1b03673dd010fe6ee58ca806767031d1c\r\nStatus: Downloaded newer image for hello-world:latest\r\n\r\nHello from Docker!\r\nThis message shows that your installation appears to be working correctly.\r\n\r\nTo generate this message, Docker took the following steps:\r\n 1. The Docker client contacted the Docker daemon.\r\n 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.\r\n    (amd64)\r\n 3. The Docker daemon created a new container from that image which runs the\r\n    executable that produces the output you are currently reading.\r\n 4. The Docker daemon streamed that output to the Docker client, which sent it\r\n    to your terminal.\r\n\r\nTo try something more ambitious, you can run an Ubuntu container with:\r\n $ docker run -it ubuntu bash\r\n\r\nShare images, automate workflows, and more with a free Docker ID:\r\n https://hub.docker.com/\r\n\r\nFor more examples and ideas, visit:\r\n https://docs.docker.com/get-started/\r\n```\r\n\r\n## 定制镜像\r\n\r\n`Dockerfile`文件如下\r\n\r\n```dockerfile\r\nFROM ubuntu:22.04\r\n\r\n# Modify the sources.list for improving download speed \r\nRUN sed -i \'s@//.*archive.ubuntu.com@//mirrors.ustc.edu.cn@g\' /etc/apt/sources.list\r\n\r\n# Create environment\r\nENV DEBIAN_FRONTEND noninteractive\r\nRUN apt-get -qq update\r\nRUN apt-get -y install bc bison build-essential ccache cpio curl flex g++-multilib gcc-multilib \r\nRUN apt-get -y install git git-lfs gnupg gperf imagemagick libc6-dev libelf-dev libgl1-mesa-dev liblz4-tool\r\nRUN apt-get -y install libncurses5 libncurses5-dev libsdl1.2-dev libssl-dev libx11-dev libxml2 libxml2-utils \r\nRUN apt-get -y install lzop lzip m4 make ncurses-dev patch pngcrush python3 python3-pip rsync schedtool \r\nRUN apt-get -y install squashfs-tools unzip x11proto-core-dev xsltproc zip zlib1g-dev openjdk-11-jdk\r\nRUN ln -s /usr/bin/python3 /usr/bin/python\r\n\r\n# Install repo\r\nRUN curl https://storage.googleapis.com/git-repo-downloads/repo > /usr/bin/repo\r\n\r\n# Turn on caching\r\nENV USE_CCACHE 1\r\nENV CCACHE_EXEC /usr/bin/ccache\r\nENV CCACHE_DIR=/ccache\r\nRUN ccache -M 50G\r\n\r\n# Mount source code directory\r\nVOLUME /source\r\nENV WORKDIR /source\r\nWORKDIR $WORKDIR\r\n```\r\n\r\n`docker-compose.yml`配置如下\r\n\r\n```yml\r\nversion: "3"\r\nservices:\r\n  android_builder:\r\n    build: .\r\n    command: /bin/bash\r\n    tty: true\r\n    stdin_open: true\r\n    volumes:\r\n      - /home/${USER}/android/lineage/:/source # SourceCode Directory\r\n      - /home/${USER}/.ccache:/ccache # ccache directory\r\n```\r\n\r\n在执行前先配置好`ccache`的目录和源码目录，再使用``docker compose run --rm android_builder bash`启动\r\n\r\n> 整理了一个项目 [PersonalDocker](https://github.com/jygzyc/PersonalDocker/)\r\n\r\n## 执行编译\r\n\r\n```bash\r\nsource build/envsetup.sh\r\nbreakfast blueline # 若编译user系统，则执行 breakfast blueline user，下同\r\n\r\nbrunch blueline\r\n```\r\n\r\n## 参考文献\r\n\r\n- [Docker - 从入门到实践](https://yeasy.gitbook.io/docker_practice)\r\n- [Build LineageOS for Google Pixel 3](https://wiki.lineageos.org/devices/blueline/build)\r\n', 'bodyText': '编译Android系统的时候遇到了环境不同，稳定性不同的问题，选择docker解决问题\n\n以编译Google Pixel 3，lineageOS 21.0为例\n\n下载源码\n第一步，安装repo\nmkdir ~/bin\nPATH=~/bin:$PATH\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\nchmod a+x ~/bin/repo\n第二步，配置git\ngit config --global user.email "you@example.com"\ngit config --global user.name "Your Name"\n由于其大小，一些存储库配置为 lfs 或大文件存储，需要安装git-lfs：\ngit lfs install # apt install git-lfs\n第三步，初始化LineageOS存储库\nrepo init -u https://github.com/LineageOS/android.git -b lineage-21.0 --git-lfs\n第四步，同步源码并准备，这里可以先参考清华lineageOS 源代码镜像使用帮助，先使用清华源同步，但是最后还是需要切回github同步一下，不然指定机型编译后会报错\nrepo sync\n\n# after finished\nsource build/envsetup.sh\nbreakfast blueline\n第五步，同步设备特定固件代码\n方法一，先刷机再执行device/google/blueline目录下的./extract-files.sh\n方法二，从OTA包中获取固件，此处可以参考 Extracting proprietary blobs from LineageOS zip files\ndocker安装\n由于我需要对制作好的image进行上传，所以这里就采用官方源进行安装了\n$ curl -fsSL get.docker.com -o get-docker.sh\n执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。\n之后我们启动docker\n$ sudo systemctl enable docker\n$ sudo systemctl start docker\n默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组，或者安装rootless的docker\n$ sudo groupadd docker\n$ sudo usermod -aG docker $USER\n# 或者使用脚本变为rootless模式\n$ dockerd-rootless.sh\n新建终端测试\n$ docker run --rm hello-world\nUnable to find image \'hello-world:latest\' locally\nlatest: Pulling from library/hello-world\n719385e32844: Pull complete \nDigest: sha256:dcba6daec718f547568c562956fa47e1b03673dd010fe6ee58ca806767031d1c\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n定制镜像\nDockerfile文件如下\nFROM ubuntu:22.04\n\n# Modify the sources.list for improving download speed \nRUN sed -i \'s@//.*archive.ubuntu.com@//mirrors.ustc.edu.cn@g\' /etc/apt/sources.list\n\n# Create environment\nENV DEBIAN_FRONTEND noninteractive\nRUN apt-get -qq update\nRUN apt-get -y install bc bison build-essential ccache cpio curl flex g++-multilib gcc-multilib \nRUN apt-get -y install git git-lfs gnupg gperf imagemagick libc6-dev libelf-dev libgl1-mesa-dev liblz4-tool\nRUN apt-get -y install libncurses5 libncurses5-dev libsdl1.2-dev libssl-dev libx11-dev libxml2 libxml2-utils \nRUN apt-get -y install lzop lzip m4 make ncurses-dev patch pngcrush python3 python3-pip rsync schedtool \nRUN apt-get -y install squashfs-tools unzip x11proto-core-dev xsltproc zip zlib1g-dev openjdk-11-jdk\nRUN ln -s /usr/bin/python3 /usr/bin/python\n\n# Install repo\nRUN curl https://storage.googleapis.com/git-repo-downloads/repo > /usr/bin/repo\n\n# Turn on caching\nENV USE_CCACHE 1\nENV CCACHE_EXEC /usr/bin/ccache\nENV CCACHE_DIR=/ccache\nRUN ccache -M 50G\n\n# Mount source code directory\nVOLUME /source\nENV WORKDIR /source\nWORKDIR $WORKDIR\ndocker-compose.yml配置如下\nversion: "3"\nservices:\n  android_builder:\n    build: .\n    command: /bin/bash\n    tty: true\n    stdin_open: true\n    volumes:\n      - /home/${USER}/android/lineage/:/source # SourceCode Directory\n      - /home/${USER}/.ccache:/ccache # ccache directory\n在执行前先配置好ccache的目录和源码目录，再使用``docker compose run --rm android_builder bash`启动\n\n整理了一个项目 PersonalDocker\n\n执行编译\nsource build/envsetup.sh\nbreakfast blueline # 若编译user系统，则执行 breakfast blueline user，下同\n\nbrunch blueline\n参考文献\n\nDocker - 从入门到实践\nBuild LineageOS for Google Pixel 3', 'author': {'login': 'jygzyc'}, 'category': {'name': '0101-Android'}, 'labels': {'nodes': [{'name': '010101-ROM定制'}]}, 'comments': {'nodes': []}}]}